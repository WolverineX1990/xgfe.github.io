<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2020-02-20T03:16:46.917Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SharedPreference导致的ANR优化实践</title>
    <link href="http://xgfe.github.io/2020/02/09/shenyanghong/anr-and-gradle-plugin/"/>
    <id>http://xgfe.github.io/2020/02/09/shenyanghong/anr-and-gradle-plugin/</id>
    <published>2020-02-09T07:07:40.000Z</published>
    <updated>2020-02-20T03:16:46.917Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了ANR相关原理，以及如何通过插件方式解决SharedPreference导致的ANR。</p><a id="more"></a><h2 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR"></a>什么是ANR</h2><p>ANR是“Application Not Responding”的简称，当Android应用程序的UI线程被阻止时间太长时，将触发应用程序无响应（ANR）的错误，如下图。如果应用程序位于前台，则系统会向用户显示一个对话框，使得用户可以强制退出该应用。开发者模式下可以设置后台程序也展示ANR对话框。<br><img src="/uploads/shenyanghong/anr/pic1.png" alt="" width="200"></p><h3 id="通常哪些情况会触发ANR"><a href="#通常哪些情况会触发ANR" class="headerlink" title="通常哪些情况会触发ANR"></a>通常哪些情况会触发ANR</h3><p>1.在主线程做耗时的IO操作<br>2.在主线程中做耗时计算<br>3.主线程中做跨进程操作<br>4.主线程中使用同步锁，或者sleep等，导致线程长时间等待</p><h3 id="线下如何检测和排查ANR"><a href="#线下如何检测和排查ANR" class="headerlink" title="线下如何检测和排查ANR"></a>线下如何检测和排查ANR</h3><p>1.在开发者模式下，开启“显示所有应用程序无响应”选项，后台应用程序也会显示ANR对话框<br>2.开启StrictMode( 严苛模式)，帮助检测主线程中的磁盘操作和网络请求<br>3.从设备中提取/data/anr/anr_* 文件分析，需要root权限，无权限时可以执行adb bugreport &gt; trace.txt 命令，将ANR信息导入trace.txt文件</p><h2 id="线上ANR如何监控"><a href="#线上ANR如何监控" class="headerlink" title="线上ANR如何监控"></a>线上ANR如何监控</h2><p>要想监控ANR，首先需要了解系统是何时抛出ANR对话框的。然后可以模拟系统做相同的监控，或者在系统监控到ANR的，通过手段获取到该通知。</p><h3 id="系统定义的ANR场景有哪些"><a href="#系统定义的ANR场景有哪些" class="headerlink" title="系统定义的ANR场景有哪些"></a>系统定义的ANR场景有哪些</h3><p>ANR都会走到AMS的mAppErrors.appNotResponding方法，通过查看该方法调用，主要有以下场景：<br>1.前台服务在20s内未执行完成 或者 android 8.0调用startForegroundService() 后，5秒内没有调用startForeground()也会触发ANR<br>2.前台广播在10s内未执行完成，默认的后台广播超时时间是60s<br>3.ContentProviderClient 也可能会调用ams.appNotRespondingViaProvider。ContentProviderClient中所有操作都会先调用beforeRemote()，最后调用afterRemote()，在beforeRemote时就会开始ANR计时。ContentProviderClient主要是用来缓存ContentResolver的，使用较少，一般都是使用getContentResolver()。<br>4.输入事件分发超时5s，包括按键和触摸事件，当native层监控到超时后，会调用InputManagerService.notifyANR，方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Native callback.</span><br><span class="line">private long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">        InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">    return mWindowManagerCallbacks.notifyANR(</span><br><span class="line">            inputApplicationHandle, inputWindowHandle, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mWindowManagerCallbacks的实现是InputMonitor，InputMonitor的notifyANR，最终会调用AMS的inputDispatchingTimeOut方法，notifyANR中关键代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // Notify the activity manager about the timeout and let it decide whether</span><br><span class="line">    // to abort dispatching or keep waiting.</span><br><span class="line">    long timeout = ActivityManager.getService().inputDispatchingTimedOut(</span><br><span class="line">            windowState.mSession.mPid, aboveSystem, reason);</span><br><span class="line">    if (timeout &gt;= 0) &#123;</span><br><span class="line">        // The activity manager declined to abort dispatching.</span><br><span class="line">        // Wait a bit longer and timeout again later.</span><br><span class="line">        return timeout * 1000000L; // nanoseconds</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (RemoteException ex) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AMS.inputDispatchingTimeOut方法，最终会调用AppErrors.appNotResponding方法，该方法主要做了以下几件事：<br>1.前台应用ANR时存储各个线程调用栈信息到/data/anr/目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// For background ANRs, don&apos;t pass the ProcessCpuTracker to</span><br><span class="line">// avoid spending 1/2 second collecting stats to rank lastPids.</span><br><span class="line">File tracesFile = mService.dumpStackTraces(true, firstPids,</span><br><span class="line">                                           (isSilentANR) ? null : processCpuTracker,</span><br><span class="line">                                           (isSilentANR) ? null : lastPids,</span><br><span class="line">                                           nativePids);</span><br></pre></td></tr></table></figure></p><p>2.存储未响应状态到进程中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void makeAppNotRespondingLocked(ProcessRecord app,</span><br><span class="line">            String activity, String shortMsg, String longMsg) &#123;</span><br><span class="line">    app.notResponding = true;</span><br><span class="line">    app.notRespondingReport = generateProcessError(app,</span><br><span class="line">            ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING,</span><br><span class="line">            activity, shortMsg, longMsg, null);</span><br><span class="line">    startAppProblemLocked(app);</span><br><span class="line">    app.stopFreezingAllLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.显示ANR对话框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Bring up the infamous App Not Responding dialog</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">msg.obj = map;</span><br><span class="line">msg.arg1 = aboveSystem ? 1 : 0;</span><br><span class="line">map.put(&quot;app&quot;, app);</span><br><span class="line">if (activity != null) &#123;</span><br><span class="line">    map.put(&quot;activity&quot;, activity);</span><br><span class="line">&#125;</span><br><span class="line">mService.mUiHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure></p><p>4.发送ANR广播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;android.intent.action.ANR&quot;);</span><br><span class="line">if (!mService.mProcessesReady) &#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">            | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">&#125;</span><br><span class="line">mService.broadcastIntentLocked(null, null, intent,</span><br><span class="line">        null, null, 0, null, null, null, AppOpsManager.OP_NONE,</span><br><span class="line">        null, false, false, MY_PID, Process.SYSTEM_UID, 0);</span><br></pre></td></tr></table></figure></p><p>通过上述分析，ANR发生在发送，启动服务，按键或者触摸事件时；而Activity生命周期耗时，并不会导致ANR，但是如果此时有service启动，用户操作等，则可能会出现ANR</p><h3 id="线上监控方案"><a href="#线上监控方案" class="headerlink" title="线上监控方案"></a>线上监控方案</h3><h4 id="判断ANR时机"><a href="#判断ANR时机" class="headerlink" title="判断ANR时机"></a>判断ANR时机</h4><p>通过上述分析，判断ANR时机，较好的办法是通过FileObserver监听/data/anr/目录或者 “android.intent.action.ANR”广播。<br>而由于没有root权限，/data/anr/目录或文件的监听会无效，ANR广播在部分手机上不ok，因此大部分线上监控方案还会结合5秒轮询的方式。轮询时判断AMS.getProcessesInErrorState()中是否有ANR异常信息。或者监听主线程Looper.loop时，每条Message的执行时间。而ANR问题基本上同一个APP不同用户的现象相差不大，因此会设置一个采样率，不用所有人都监控采样。</p><h4 id="输出anr堆栈信息"><a href="#输出anr堆栈信息" class="headerlink" title="输出anr堆栈信息"></a>输出anr堆栈信息</h4><p>堆栈信息可以通过提取/data/anr/目录中文件或者调用AMS.getProcessesInErrorState()，该方法返回进程所有错误信息，在发生ANR之后过滤出包含ANR的ProcessErrorStateInfo即可。</p><h2 id="SharedPreference导致的ANR"><a href="#SharedPreference导致的ANR" class="headerlink" title="SharedPreference导致的ANR"></a>SharedPreference导致的ANR</h2><p>我们遇到过一个占比较高的ANR和SharedPreference有关，堆栈信息如下：<br><img src="/uploads/shenyanghong/anr/pic2.png" alt="" width="600"></p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h4 id="调用QueueWork-waitToFinish时机有哪些？"><a href="#调用QueueWork-waitToFinish时机有哪些？" class="headerlink" title="调用QueueWork.waitToFinish时机有哪些？"></a>调用QueueWork.waitToFinish时机有哪些？</h4><p>我们查看到调用路径为QueueWork.waitToFinish， 那么哪些情况下会调用该方法，查看ActivityThread源码发现有以下情况：<br>1.Service onStartCommand被调用时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (data.args != null) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            int res;</span><br><span class="line">            if (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.Service onStop时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopService(IBinder token) &#123;</span><br><span class="line">    Service s = mServices.remove(token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Destroying service &quot; + s);</span><br><span class="line">            s.onDestroy();</span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            Context context = s.getBaseContext();</span><br><span class="line">            if (context instanceof ContextImpl) &#123;</span><br><span class="line">                final String who = s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, &quot;Service&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.i(TAG, &quot;handleStopService: token=&quot; + token + &quot; not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.Activity不可见时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">    StopInfo info = new StopInfo();</span><br><span class="line">    performStopActivityInner(r, info, show, true, &quot;handleStopActivity&quot;);</span><br><span class="line">    updateVisibility(r, show);</span><br><span class="line">    // Make sure any pending writes are now committed.</span><br><span class="line">    if (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？"><a href="#为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？" class="headerlink" title="为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？"></a>为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？</h4><p>SharedPreferencesImpl 是 SharedPreference的实现类，其中apply() 和 commit() 都调用了QueuedWork，apply()方法中写文件是调用QueuedWork中的Handler来延时执行的。<br>commit()方法是立即执行 或者调用QueuedWork中的Handler 批量立即执行的。其中加入QueuedWork.sFinishers列表的只有apply()<br>apply方法代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();//立即修改内存</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await(); //等待该apply数据写完文件</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);//加入QueuedWork的Finisher队列，检查时机见下文</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123; //写入文件完毕的回调，从QueuedWork移除等待</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);//加入QueuedWork队列，并延时执行</span><br><span class="line"></span><br><span class="line">    notifyListeners(mcr);//回调通过registerOnSharedPreferenceChangeListener注册的listener，⚠️回调时不等文件写完成。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>commit方法代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean commit() &#123;</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();//写入内存</span><br><span class="line"></span><br><span class="line">    //如果所有的apply commit 文件都写入完成，则在当前线程执行写入，否则丢到QueuedWork队列，且立即在子线程中执行队列中的runnable</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        mcr.writtenToDiskLatch.await();//等待本次写完</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>apply中关键的异步写方法enqueueDiskWrite代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                              final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</span><br><span class="line"></span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    //写入完成，减少计数器</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable != null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // commit操作</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty = false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            //mDiskWritesInFlight==1表示只有本次写入未完成</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            //如果所有的apply commit 文件都写入完成，则在当前线程执行写入</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //丢到QueuedWork队列，由子线程执行writeToDiskRunnable，commit操作会理解执行，apply会延时100ms执行</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正写数据到文件的方法writeToFile代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) &#123;</span><br><span class="line">    boolean fileExists = mFile.exists();</span><br><span class="line">    // Rename the current file so it may be used as a backup during the next read</span><br><span class="line">    // 如果文件存在，则先备份，写入时会写到mFile中</span><br><span class="line">    if (fileExists) &#123;</span><br><span class="line">        boolean needsWrite = false;</span><br><span class="line">        // 当磁盘缓存的版本低于需要写入的版本时，才写入</span><br><span class="line">        if (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line">            if (isFromSyncCommit) &#123;</span><br><span class="line">                needsWrite = true;// 当commit时，由于外面在等待写入结果，因此每次都写入</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    // 当内存的版本等于要写入的版本时，才写入，也就是多个apply操作，只写入最后一个apply时的内存</span><br><span class="line">                    if (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</span><br><span class="line">                        needsWrite = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!needsWrite) &#123;</span><br><span class="line">            //如果不需要写入时，实际是否写入文件为false，是否操作成功为true</span><br><span class="line">            mcr.setDiskWriteResult(false, true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean backupFileExists = mBackupFile.exists();</span><br><span class="line">        if (!backupFileExists) &#123;</span><br><span class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                //备份失败则算没有写入，且写入失败</span><br><span class="line">                mcr.setDiskWriteResult(false, false);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mFile.delete();//backup文件存在，则丢弃mFile，因为backupFile永远是完整的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //真正开始写入mFile，出现任何异常，删除写入异常的mFile</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(false, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line">        ...略</span><br><span class="line"></span><br><span class="line">        // 写入成功，mBackupFile就无用了，删除</span><br><span class="line">        mBackupFile.delete();</span><br><span class="line">        mDiskStateGeneration = mcr.memoryStateGeneration;</span><br><span class="line"></span><br><span class="line">        //更新写入成功回调</span><br><span class="line">        mcr.setDiskWriteResult(true, true);</span><br><span class="line"></span><br><span class="line">        long fsyncDuration = fsyncTime - writeTime;</span><br><span class="line">        mSyncTimes.add(Long.valueOf(fsyncDuration).intValue());</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 出现异常，删除写入异常的mFile</span><br><span class="line">    if (mFile.exists()) &#123;</span><br><span class="line">        mFile.delete()</span><br><span class="line">    &#125;</span><br><span class="line">    mcr.setDiskWriteResult(false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ANR原因"><a href="#ANR原因" class="headerlink" title="ANR原因"></a>ANR原因</h3><p>通过上面汇总的waitToFinish调用时机，我们了解到，它都是在主线程执行的。而apply方法执行时，往sFinishes添加了一个等待写入完成的Runnable，因此在触发waitToFinish时，由于主线程等待子线程写入执行完成，从而可能造成ANR，因此主要原因在于QueuedWork.addFinisher代码。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>初步解决思路是，apply时，不将等待写入完成runnable加入sFinishes 队列。设计原因在代码中未说明，可能是为了防止丢失数据，让写入线程有更多时机写入。经过分析和讨论这个不是必须的，因为该方案无法保证进程被杀时的数据丢失问题，修改前后，通过杀进程测试，发现被杀前apply的数据都无法保留下来。而通过和其他端解决方案对比，发现也有将sFinishers 队列清空的方案，这种方案改动更大且未暴露出其他问题，因此我们决定采用apply()时，不将等待写入完成的runnable加入sFinishes 队列。经过多个版本灰度，未见异常，最终全量后没有SharedPreference相关的ANR。</p><h3 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h3><p>重写了SharedPreferencesImpl的包装类，该包装类中改变了Editor的apply方法的实现。<br>apply()重新实现时，将不包含QueuedWork.addFinisher(awaitCommit)，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    if (!SafeSp.sEnable) &#123;</span><br><span class="line">        //如果未开启优化，则调用原apply方法</span><br><span class="line">        this.mEditor.apply();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //通过反射，调用commitToMemory</span><br><span class="line">            final Object mcr = this.commitToMemoryWrapper();</span><br><span class="line">            Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //通过反射，调用真正写文件方法writtenToDiskLatch</span><br><span class="line">                        SafeApplyEditor.this.startDiskLatchAwait(mcr);</span><br><span class="line">                    &#125; catch (Exception var2) &#123;</span><br><span class="line">                        SafeSp.setEnable(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            //通过反射，调用enqueueDiskWrite</span><br><span class="line">            this.enqueueDiskWriteWrapper(mcr, postWriteRunnable);</span><br><span class="line">            //通过反射，调用notifyListeners</span><br><span class="line">            this.notifyListenersWrapper(mcr);</span><br><span class="line">        &#125; catch (Exception var3) &#123;</span><br><span class="line">            //API有变更时，关闭优化</span><br><span class="line">            this.mEditor.apply();</span><br><span class="line">            SafeSp.setEnable(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用时通过SafeSp.getSP(sharedPreferences) 可以返回一个修复了ANR的sharedPreferences，由于SDK中可能也使用了sharedPreferences，因此可以通过gradle插件修改字节码的方式，将app中所有使用SharedPreference的地方都进行替换，替换后是否开启优化可以由上层控制。</p><h2 id="插件化方案"><a href="#插件化方案" class="headerlink" title="插件化方案"></a>插件化方案</h2><h3 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h3><p>插件方案为通过自定义Transform，实现在编译成class后，打包成dex前扫描所有class，找到所有Context.getSharedPreferences(“name”,mode) 和 PreferenceManager.getDefaultSharedPreferences(context) 代码，替换为SafeSp.getSP(原代码).</p><p>为了减少class扫描，因此增加一个外部配置，可以用正则表达式，配置不需要检查的class，默认配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SPManagerPlugin &#123;</span><br><span class="line">    skipClass = [&apos;R\\..*&apos;, &apos;R\\$.*&apos;, &apos;.*BuildConfig.*&apos;,&apos;.*SafeSharedPreferenceUtil.*&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建Plugin工程"><a href="#新建Plugin工程" class="headerlink" title="新建Plugin工程"></a>新建Plugin工程</h3><p>自定义Plugin可以在build.gradle文件中直接定义，为了方便复用，我们这里新建一个独立的Plugin工程来实现，由于AndroidStudio下没有提供直接创建Plugin工程的快捷方式，但可以用AndroidStudio新建一个Java-Library，将build.gradle文件中apply plugin: ‘java’ 改成 apply plugin: ‘groovy’，且在dependencies中添加依赖：compile gradleApi() 和 compile ‘com.android.tools.build:gradle:2.3.3’ ，这样才可以导入gradle.api 以及gradle相关的类。同时为了兼容java7，需要制定jdk编译版本：</p><p>sourceCompatibility = “7”<br>targetCompatibility = “7”</p><p>将src/main下的java目录改名为groovy，在groovy同级目录下新建resources/META-INF/gradle-plugins目录，并在该目录下新建一个文件按以下规则命名：插件名称.properties，插件名称将决定了如何使用该Plugin，用法如apply plugin: ‘插件名称’，文件内容为implementation-class=Plugin接口的实现类完整名称。如：implementation-class=com.sjst.xgfe.android.plugin.SPManagerPlugin</p><p>最后的目录结构如下:<br>├── build.gradle<br>├── gradle.properties<br>└── src<br>    └── main<br>        ├── groovy<br>        └── resources<br>            └── META-INF<br>                └── gradle-plugins<br>                    └── SPManagerPlugin.properties</p><h3 id="实现Plugin"><a href="#实现Plugin" class="headerlink" title="实现Plugin"></a>实现Plugin</h3><p>在groovy目录下新建plugin入口类：SPManagerPlugin.java ，也可以使用.groovy后缀，使用groovy语言开发。SPManagerPlugin需要实现Plugin接口的apply方法，该方法在apply插件的时候会被调用。在该方法中我们可以操作Project。通过Project，可以对已有的Task进行修改或者新增Task，同时也可以注册Transform来实现我们所需要的扫描class 以及新增class功能，注册Transform其本质也是添加一个TransformTask，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SPManagerPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void apply(Project project) &#123;</span><br><span class="line">        if (project == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.sLogger = project.getLogger();//初始化log</span><br><span class="line">        PluginConfig pluginConfig = project.getExtensions().create(&quot;SPManagerPlugin&quot;, PluginConfig.class);//加载插件配置</span><br><span class="line"></span><br><span class="line">        AppExtension appExtension = project.getExtensions().findByType(AppExtension.class);</span><br><span class="line">        //注册Transform来处理字节，TransformProcessor为具体替换处理类</span><br><span class="line">        appExtension.registerTransform(new ReplaceSPTransform(pluginConfig, new TransformProcessor(project,</span><br><span class="line">                pluginConfig)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReplaceSPTransform继承自Transform，它是Android官方提供的在项目构建class到生成dex期间修改class或资源的一套API。主要有以下方法需要实现:<br>1.getInputTypes:该方法用于指定需要处理的源，这里不需要处理资源，则只需要返回CONTENT_CLASS，如果需要处理资源和class，则返回CONTENT_JARS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">    //这里只需要处理class</span><br><span class="line">    return TransformManager.CONTENT_CLASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.getScopes:用于指明Transform的作用域，需要返回各种Scope集合，这里需要支持所有工程，因此返回SCOPE_FULL_PROJECT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">    //所有module都检查</span><br><span class="line">    return TransformManager.SCOPE_FULL_PROJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.isIncremental:是否支持增量编译，如果支持增量编译，则需要判断输入源的状态，根据状态处理。如jarInput 通过jarInput.getStatus()判断，directoryInput通过directoryInput.getChangedFiles()判断，来分别处理。当前该插件是不支持增量编译。</p><p>Transform执行的入口方法是transform(TransformInvocation invocation)，其中invocation参数包含了输入、输出相关信息，在该方法中我们需要将输入源拷贝到输出目录，输入源中就包含了class文件或jar包，因此可以扫描所有类。同时如果需要修改或新增class，可以在拷贝的过程中处理。invocation输入源分为 JarInput 和 DirectoryInput，JarInput包含的是jar文件地址，DirectoryInput包含的是类或资源文件位置，因此需要分别处理，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void transform(TransformInvocation invocation) throws TransformException, InterruptedException,</span><br><span class="line">        IOException &#123;</span><br><span class="line">    Collection&lt;TransformInput&gt; inputs = invocation.getInputs();</span><br><span class="line">    TransformOutputProvider outputProvider = invocation.getOutputProvider();</span><br><span class="line"></span><br><span class="line">    for (TransformInput input : inputs) &#123;</span><br><span class="line">        //处理jar文件，处理完后，需要将jar文件写入targetFile</span><br><span class="line">        for (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class="line"></span><br><span class="line">            File targetFile = outputProvider.getContentLocation(</span><br><span class="line">                    jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(),</span><br><span class="line">                    Format.JAR);</span><br><span class="line">            processor.processJarFile(jarInput.getFile(), targetFile);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理目录，处理完每个文件后，需要将文件拷贝到targetDir目录</span><br><span class="line">        for (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class="line">            File targetDir = outputProvider.getContentLocation(</span><br><span class="line">                    directoryInput.getName(), directoryInput.getContentTypes(),</span><br><span class="line">                    directoryInput.getScopes(), Format.DIRECTORY);</span><br><span class="line">            processor.processDir(directoryInput.getFile(), targetDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扫描Class"><a href="#扫描Class" class="headerlink" title="扫描Class"></a>扫描Class</h3><p>JarInput数据源处理方式实际上是解压jar文件，并解析jar中的class，DirectoryInput数据源处理实际是直接解析dir中class文件，或者jar文件，总之最终都会走到解析class文件流。</p><h3 id="替换Class中内容"><a href="#替换Class中内容" class="headerlink" title="替换Class中内容"></a>替换Class中内容</h3><p>替换class中内容原理为通过asm API解析字节码，然后再通过visitor去遍历变量，方法或者注解，在遍历的时候可以修改内容，最后再取出修改后的字节码。<br>解析类内容的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private byte[] processClassStream(InputStream inputStream) throws Exception &#123;</span><br><span class="line">    ClassReader classReader = new ClassReader(inputStream);</span><br><span class="line"></span><br><span class="line">    ClassWriter cw = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    MyClassVisitor cv = new MyClassVisitor(cw);</span><br><span class="line">    classReader.accept(cv, EXPAND_FRAMES);</span><br><span class="line"></span><br><span class="line">    return cw.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历方法并替换内容的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassVisitor extends ClassVisitor &#123;</span><br><span class="line">    public MyClassVisitor(ClassVisitor cv) &#123;</span><br><span class="line">        super(Opcodes.ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;</span><br><span class="line">        super.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">        //遍历方法时，还需要进一步遍历方法中的内容</span><br><span class="line">        return new MyMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    public class MyMethodVisitor extends MethodVisitor &#123;</span><br><span class="line">        public MyMethodVisitor(MethodVisitor mv) &#123;</span><br><span class="line">            super(Opcodes.ASM5, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">            if (!needReplace(opcode, owner, name, desc, itf)) &#123;</span><br><span class="line">                super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //替换实现</span><br><span class="line">        private boolean needReplace(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">            boolean result = false;</span><br><span class="line">            boolean isGetSharedPreferences =</span><br><span class="line">                    &quot;android/content/Context&quot;.equals(owner) &amp;&amp; &quot;getSharedPreferences&quot;.equals(name);</span><br><span class="line">            boolean isGetDefaultSharedPreferences = &quot;android/preference/PreferenceManager&quot;.equals(owner) &amp;&amp;</span><br><span class="line">            &quot;getDefaultSharedPreferences&quot;.equals(name);</span><br><span class="line">            if (isGetSharedPreferences || isGetDefaultSharedPreferences) &#123;</span><br><span class="line">                super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">                //如何替换，可以通过前后代码的asm字节码进行比较</span><br><span class="line">                super.visitMethodInsn(INVOKESTATIC, &quot;com/sjst/xgfe/android/safesp/SafeSp&quot;,</span><br><span class="line">                        &quot;getSP&quot;, &quot;(Landroid&quot; +</span><br><span class="line">                                &quot;/content/SharedPreferences;)Landroid/content/SharedPreferences;&quot;, false);</span><br><span class="line"></span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于ASM api比较复杂也容易出错，这里我们借助AndroidStudio  asm-bytecode-outline 插件，可以直接查看这个java文件的class类需要用什么asm api来生成。然后通过前后asm字节码文件进行比较即可。</p><h3 id="本地发布aar"><a href="#本地发布aar" class="headerlink" title="本地发布aar"></a>本地发布aar</h3><p>远程发布无法快速测试，因此开发期间可以先采用本地发布aar。主要实现为在plugin工程的build.gradle中添加maven配置，然后在命令行调用  ./gradlew install，就会生成aar到本地mavenLocal目录：~/.m2/repository。maven配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">//arr打包配置</span><br><span class="line">group = &apos;com.sjst.xgfe.android.plugin&apos;</span><br><span class="line">version = &apos;1.0.3&apos;</span><br><span class="line">project.archivesBaseName = &apos;SPManagerPlugin&apos;</span><br></pre></td></tr></table></figure></p><p>因此调试的时候，在测试工程的repositories 中加入mavenLocal() 即可加载到本地插件aar。</p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>Android运行时代码调试只需要打上断点，选择调试进程即可。而编译期的代码调试则需要做如下处理：<br>1.添加远程debug运行模式，操作步骤如图1，图2，添加后如图3，名称可以自选，选需要调试的工程<br><img src="/uploads/shenyanghong/anr/debug1.png" alt="" width="200"> <img src="/uploads/shenyanghong/anr/debug2.png" alt="" width="400"><br>2.执行编译命令，在正常的编译命令后加–no-daemon -Dorg.gradle.debug=true 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean assembleDebug -p plugintest --no-daemon -Dorg.gradle.debug=true</span><br></pre></td></tr></table></figure><p>3.打上断点，选中刚创建的远程调试模式，也可以在执行命令前选中，点击Debug即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先介绍了ANR相关概念，以及ANR是如何由系统底层产生的。了解底层原理后，我们又分析了如何在线上监控ANR。同时通过剖析SharedPreference实现原理，找到了产生ANR的原因，以及解决办法。为了彻底解决App中此类问题，我们用到了Gradle插件。最后，本文介绍了Gradle插件的开发、调试以及发布技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了ANR相关原理，以及如何通过插件方式解决SharedPreference导致的ANR。&lt;/p&gt;
    
    </summary>
    
      <category term="shenyanghong" scheme="http://xgfe.github.io/categories/shenyanghong/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="anr" scheme="http://xgfe.github.io/tags/anr/"/>
    
      <category term="plugin" scheme="http://xgfe.github.io/tags/plugin/"/>
    
      <category term="gradle" scheme="http://xgfe.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>代理工具whistle的基本使用</title>
    <link href="http://xgfe.github.io/2019/09/17/qiuwei/whistle/"/>
    <id>http://xgfe.github.io/2019/09/17/qiuwei/whistle/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.656Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍代理工具whistle的基本功能以及实际应用。<br><a id="more"></a></p><h1 id="whistle是干嘛用的"><a href="#whistle是干嘛用的" class="headerlink" title="whistle是干嘛用的"></a>whistle是干嘛用的</h1><p>whistle(读音[ˈwɪsəl]，拼音[wēisǒu])基于Node实现的跨平台web调试代理工具，类似的工具有Fiddler、Charles，主要用于查看、修改HTTP、HTTPS、Websocket的请求、响应，也可以作为HTTP代理服务器使用。</p><h1 id="有了charles为什么还用whistle"><a href="#有了charles为什么还用whistle" class="headerlink" title="有了charles为什么还用whistle"></a>有了charles为什么还用whistle</h1><ul><li>whistle是开源的，安装也更简单。（安装：npm i -g whistle   启动：w2 start   操作：浏览器访问127.0.0.0:8899）</li><li>官方文档清晰、全面。 （<a href="http://wproxy.org/whistle/" target="_blank" rel="noopener">文档链接</a>）</li><li>代码式操作。(请求转发、编辑等都是以代码行的形式进行，相比较于charles这种图形化操作，效率更高，更灵活)</li><li>默认集成vconsole、weinre等调试功能。（例如vconsole这种客户端控制台日志打印功能都默认集成，而且是在PC的控制台显示客户端日志）</li></ul><h1 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h1><p><a href="http://wproxy.org/whistle/install.html" target="_blank" rel="noopener">安装启动、代理配置移步官方文档</a></p><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="hosts配置"><a href="#hosts配置" class="headerlink" title="hosts配置"></a>hosts配置</h2><p>  提供类似switchhosts的修改域名解析的功能，并且可以做到单独对浏览器生效或本机全局生效，无需刷新dns缓存。<br>  更强大的是他支持同一个域名下的不同链接解析到不同的ip、支持正则匹配、支持端口转发等等。</p><pre><code>以下规则在whistle rules窗口下添加：127.0.0.1 a.meituan.com             # a.meituan.com下的请求代理到本机192.168.191.1 b.meituan.com/list/   # b.meituan.com下list路径的请求代理到192.168.191.1192.168.191.2 b.meituan.com         # b.meituan.com下的其余请求代理到192.168.191.2d.metuan.com e.meituan.com          # d.metuan.com的请求转发到e.meituan.com127.0.0.1:8080 f.meituan.comn       # f.meituan.comn的请求转发到本地8080端口192.168.191.3 /./                   # 除以上规则匹配到的请求以外，其他请求均代理到192.168.191.3</code></pre><p>  注：更高级别的规则放在前面 否则不会执行 如b.meituan.com/list/需放在b.meituan.com前面。</p><h2 id="https转http"><a href="#https转http" class="headerlink" title="https转http"></a>https转http</h2><p>  很多客户端强制要求页面是https，这样连带着所有请求也都是https了，本地调试不方便，可以把https转为http。</p><ol><li>解析https请求 请看<a href="http://wproxy.org/whistle/webui/https.html" target="_blank" rel="noopener">官方文档</a>。</li><li>按照以上操作执行后，whistle可以解析https了，然后只需在rules窗口下添加以下规则，则请求便由https转为http了。</li></ol><h2 id="客户端日志-错误打印"><a href="#客户端日志-错误打印" class="headerlink" title="客户端日志/错误打印"></a>客户端日志/错误打印</h2><p>  我们一般本地调试时，想看H5页面运行在客户端的日志或者报错，只能用charles代理，然后alert或者程序中加vconsole在手机上看。<br>  有了whistle这两步就可以合在一起，并且在电脑上看日志了。</p><p>  (1）在whistle rules窗口下添加以下规则:</p><pre><code>127.0.0.1 a.meituan.com             # a.meituan.com下的请求代理到本机a.meituan.com log://test            # a.meituan.com下的consolelog打印  ://后面的名字随便起 这只是一个标识</code></pre><p>  (2）在network窗口右侧的tools下的Console窗口可查看客户端的console.log打印以及异常报错。<br><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic1.png"></p><p>  注：whistle也整合了weinre远程调试的功能，可以直接看<a href="http://wproxy.org/whistle/webui/weinre.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="延迟、限速"><a href="#延迟、限速" class="headerlink" title="延迟、限速"></a>延迟、限速</h2><p>  这两个功能做功能测试以及性能优化时经常用。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/js/ resSpeed://1000     # 限速 kb/s/./ resDelay://3000                   # 延迟 3秒</code></pre><h2 id="修改响应内容"><a href="#修改响应内容" class="headerlink" title="修改响应内容"></a>修改响应内容</h2><p>  在mock数据或者本地调试时，我们经常要将线上文件替换为本地文件，或者对接口的响应内容做修改。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/home/ file:///Users/xxx/Desktop/test.html             #替换页面a.meituan.com/unify.min.js file:///Users/xxx/Desktop/test.js        #替换jsa.meituan.com/api/list resBody://{myRes}                            #替换响应内容 myRes为自定义变量 可以紧跟规则在下面用```定义 也可在Values窗口内定义`` ` myRes    {&quot;code&quot;:200,&quot;data&quot;:{&quot;list&quot;:[]},&quot;message&quot;:&quot;请求成功&quot;,&quot;status&quot;:1}`` `</code></pre><p>  注：因为不能转义 所以把<code>`</code>中间加了个空格 实际操作时应该是连续的。</p><h2 id="修改响应头"><a href="#修改响应头" class="headerlink" title="修改响应头"></a>修改响应头</h2><p>  有时我们需要修改响应头，比如cors跨域头。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list resHeaders://{myRes1}`` ` myRes1    Access-Control-Allow-Origin: https://a.meituan.com`` `</code></pre><p>  注：因为不能转义 所以把<code>`</code>中间加了个空格 实际操作时应该是连续的。</p><h2 id="修改请求参数"><a href="#修改请求参数" class="headerlink" title="修改请求参数"></a>修改请求参数</h2><p>  测试环境有时我们没法通过代码修改入参，我们可以通过代理修改。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list reqMerge://(name=test&amp;brand=nokia)</code></pre><h2 id="修改请求头"><a href="#修改请求头" class="headerlink" title="修改请求头"></a>修改请求头</h2><p>  referer、origin、ua这些请求头我们都可以修改。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list reqHeaders://{myReq}`` ` myReq    referer: b.meituan.com    origin: http://b.meituan.com`` `</code></pre><p>  注：因为不能转义 所以把<code>`</code>中间加了个空格 实际操作时应该是连续的。    </p><h2 id="通过js代码动态获取请求-响应内容-编辑请求-响应"><a href="#通过js代码动态获取请求-响应内容-编辑请求-响应" class="headerlink" title="通过js代码动态获取请求/响应内容 编辑请求/响应"></a>通过js代码动态获取请求/响应内容 编辑请求/响应</h2><p>  有很多情况我们的响应不是固定的，而是根据请求参数动态变化的，whistle同样可以帮我们做到。<br>  whistle内置了一些全局变量，我们可以获取链接参数，动态生成一条rule，然后push到whislte规则中。<br>  这是最灵活，最全面的，理论上我们掌握这一种就可以实现上述所有功能。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list resScript://{myScript}`` ` myScript    const queryMap = parseQuery(parseUrl(url).query);    const res = {        &quot;code&quot;: queryMap.isLogin ? 200 : 400,        &quot;data&quot;: {}    };    console.log(res);    values.myScript_res = res;    rules.push(`${url} resBody://{myScript_res}}`);`` `</code></pre><p>  注：因为不能转义 所以把<code>`</code>中间加了个空格 实际操作时应该是连续的。<br>  注：上述js的控制台打印可在（network - tools - Server）看到，这也就让我们拥有了调试能力。<br><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic2.png" width="800px"></p><h2 id="页面注入js-css"><a href="#页面注入js-css" class="headerlink" title="页面注入js/css"></a>页面注入js/css</h2><p>  直接往线上注入我们本地的js/css。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com js:///Users/xxx/Desktop/test.js         #追加jsa.meituan.com css:///Users/xxx/Desktop/test.css       #追加css</code></pre><h1 id="其他小点"><a href="#其他小点" class="headerlink" title="其他小点"></a>其他小点</h1><h2 id="本地ip查看"><a href="#本地ip查看" class="headerlink" title="本地ip查看"></a>本地ip查看</h2><p><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic3.png"></p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic4.png"></p><h2 id="Rules窗口、Values窗口"><a href="#Rules窗口、Values窗口" class="headerlink" title="Rules窗口、Values窗口"></a>Rules窗口、Values窗口</h2><p><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍代理工具whistle的基本功能以及实际应用。&lt;br&gt;
    
    </summary>
    
      <category term="qiuwei" scheme="http://xgfe.github.io/categories/qiuwei/"/>
    
    
      <category term="代理" scheme="http://xgfe.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="charles" scheme="http://xgfe.github.io/tags/charles/"/>
    
  </entry>
  
  <entry>
    <title>JS异步语法</title>
    <link href="http://xgfe.github.io/2019/08/07/linxiaowen/Javascript-asynchronous/"/>
    <id>http://xgfe.github.io/2019/08/07/linxiaowen/Javascript-asynchronous/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.648Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对Javascript中异步编程的几种语法以及使用方式进行了介绍。</p><a id="more"></a><h2 id="前言-同步与异步"><a href="#前言-同步与异步" class="headerlink" title="前言 同步与异步"></a>前言 同步与异步</h2><p>在JS中，通常代码按顺序从上到下同步执行，但某些特殊场景/操作下需要以异步的方式执行，即将代码划分为至少两部分，先执行一部分代码，在进行耗时操作时将主线程的执行权交出，执行其他代码，待耗时任务完成后以一定规则触发使得另一部分代码被继续执行。</p><p>JS中常见的异步执行场景：网络请求（Ajax等）、定时器（SetTimeout等）、IO操作（readFile等）…</p><p>对于JS的这些异步场景，有两个重点：</p><p>1.得知异步任务何时结束，以便进行后续操作；<br>2.处理多个异步任务按顺序执行/并发执行的场景；</p><p>在处理JS异步场景方法的衍化过程当中，逐步出现了几种方式：</p><ul><li>回调函数</li><li>事件监听</li><li>发布订阅</li><li>Promise</li><li>Generator/yield</li><li>Async/await</li></ul><hr><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>JS中最常见的处理异步问题的方法，将任务结束时要做的事（或者说必须拿到异步任务的结果才能进行的操作）包装成函数作为参数传递给异步操作，待异步操作结束后执行函数，称之为“回调”函数。如SetTimeout函数就接受一个函数参数作为回调函数，在指定延迟时间后执行该回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步操作setTimeout示例</span><br><span class="line">setTimeout(function()&#123;//延迟100ms后执行“代码块”；延迟即视为异步操作，代码块则是异步操作结束后的“回调函数”；</span><br><span class="line">  //代码块</span><br><span class="line">&#125;，100);</span><br></pre></td></tr></table></figure><p>回调函数的异步方法简单易理解，但不利于代码维护，尤其在多个异步任务继发执行使得回调函数嵌套的情况下，代码耦合度高不利于代码的阅读和维护，且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。</p><p>虽然回调函数这种方式问题很多，但是不可否认的是在ES6之前，他就是处理异步问题普遍较好的方式，而且后面很多方式仍然基于回调函数。</p><hr><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>JS中关于DOM操作的一系列监听事件也属于异步方法，如监听各种元素的onclick、onload等方法。只有当监听元素对应的事件被发生时对应的代码才会被执行。</p><p>回调函数与事件监听的区别：</p><ul><li>回调函数多是一对一的关系，事件监听可以是多对一。</li><li>运行异步函数，在一个不确定的时间段之后运行回调函数；不确定何时触发事件，但是触发事件同步响应事件的回调。</li><li>事件监听相对于回调函数，可配置的监听（可增可减）关系减少了耦合性。</li></ul><p>不过事件监听也存在问题：</p><ul><li>多对多的监听组成了一个复杂的事件网络，单个节点通常监听了多个事件，维护成本很大。</li><li>多个异步事件仍然还是回调的形式。</li></ul><hr><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>和事件监听非常类似的是发布/订阅者模式，在事件监听的基础上，假定存在一个 “ 消息中心 “，某个任务执行完成，就向消息中心 “ 发布 “（publish）一个消息，其他任务可以向消息中心 “ 订阅 “（subscribe）这个消息，从而知道什么时候自己可以开始执行。（直观产品就是微信的公众号模式）</p><p>发布订阅模式在事件监听的基础上增加消息中心的概念，使得多个监听事件的运转流程和消息传递更加有序。但与事件监听相同的是发布订阅者模式也是“事件驱动”型，无法预知到事件何时发生/发布。</p><hr><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise的三种状态：pending（进行中），fulfilled（已成功），rejected（已失败），其状态只能从进行中到成功或者是失败，不可逆。而当Promise成功/失败/发生错误时可以调用不同的回调函数来处理不同的情况。当状态定型后称为resolved(已定型)，为了方便表述，后续所有resolved统一只指fulfilled状态，不包含rejected状态。基本使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = new Promise((resolve, reject) =&gt; &#123;//传入resolve和reject两个函数(自带，名字也随意)来改变Promise的状态</span><br><span class="line">  //一顿操作</span><br><span class="line">  if(/*异步操作成功*/)&#123;</span><br><span class="line">  resolve(&apos;success&apos;); //调用resolve函数使Promise状态从pengding=&gt;fulfilled,reject则相反；</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   reject(&apos;reject&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  //还可以操作，promise状态变化后仍会继续执行代码，但原则上不应该，因此可以用return resolve();的方式避免该情况；</span><br><span class="line">&#125;);</span><br><span class="line">promise1.then(//then方法是在Promise结束(成功/失败)后进行调用，可以传入两个回调函数作为参数分别对应成功/失败的状态；</span><br><span class="line">  value =&gt; &#123;//回调函数的参数(此为value)则是Promise状态转换时传递出的信息，resolve(&quot;success&quot;)中的“success”；</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;//then方法的第二个回调函数为可选；</span><br><span class="line">    console.log(reason);//reject</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="当resolve-a-传递的参数a也是一个Promise时"><a href="#当resolve-a-传递的参数a也是一个Promise时" class="headerlink" title="当resolve(a)传递的参数a也是一个Promise时"></a>当resolve(a)传递的参数a也是一个Promise时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2</span><br><span class="line">  .then(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail，3秒后</span><br></pre></td></tr></table></figure><p>由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p><h3 id="Promise的链式调用-then"><a href="#Promise的链式调用-then" class="headerlink" title="Promise的链式调用(then)"></a>Promise的链式调用(then)</h3><p>then函数定义在原型对象Promise.prototype.then()上，then函数可以链式调用，因为每次调用返回的都是一个新的 Promise 实例；promise1.then().then().then()…</p><ul><li>在 then 中使用了 return，那么 return 的值会被 Promise.resolve() 包装，传递给下一次 then 中的成功回调 ；</li><li>then 中可以不传递参数，如果不传递（then().then(…)？）会透到下一个 then 中 ；</li><li>如果 then 中出现异常, 会走下一个 then 的失败回调/被最近的catch捕获；</li></ul><h3 id="Promise的异常捕获（catch）"><a href="#Promise的异常捕获（catch）" class="headerlink" title="Promise的异常捕获（catch）"></a>Promise的异常捕获（catch）</h3><p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。当异步操作抛出错误时状态会变为rejected，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=new Promise(function(res,rej)&#123;//当Promise内抛出错误，且then函数有rejected的回调函数以及存在catch函数</span><br><span class="line">throw new Error(&quot;cuowu&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,function(val)&#123;</span><br><span class="line">console.log(&quot;rej&quot;+val);</span><br><span class="line">  throw new Error(&quot;reject error&quot;);//在rejected回调函数中抛出错误会被catch捕获</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(e)&#123;</span><br><span class="line">console.log(&quot;err&quot;+e);</span><br><span class="line">&#125;);</span><br><span class="line">//rejError: cuowu//即会直接被rejected回调函数捕获而不被catch捕获</span><br><span class="line">//errError: reject error</span><br></pre></td></tr></table></figure><ol><li><p>Promise 在resolve语句后面，再抛出错误不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p></li><li><p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法(还可以捕获then中的错误)。</p></li><li><p>catch方法返回的还是一个 Promise 对象，状态变为resolve，因此后面还可以接着调用then方法。</p></li><li><p>catch不会捕获其之后的错误（catch().then().then(),后面两个then函数中错误与catch无关）。</p></li><li><p>catch中报错与then一样向下传递，若有catch则能被捕获。</p></li></ol><p>若没有用catch方法捕获错误，Promise 对象抛出的错误不会传递到外层代码，即运行出错仍然会报错，但不会退出进程终止运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    resolve(x + 2);// 下面一行会报错，因为x没有声明</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  console.log(&apos;everything is great&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);</span><br><span class="line">// Uncaught (in promise) ReferenceError: x is not defined</span><br><span class="line">// 123    //即使报错但2秒后仍然输出123；</span><br></pre></td></tr></table></figure></p><p>Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=new Promise(function(res,rej)&#123;</span><br><span class="line">rej(&quot;rej&quot;);</span><br><span class="line">  //res(&quot;ok&quot;);</span><br><span class="line">  setTimeout(()=&gt;&#123;throw new Error(&quot;cuowu&quot;)&#125;,0);</span><br><span class="line">&#125;)</span><br><span class="line">.then(val=&gt;console.log(&quot;res:&quot;+val),function(val)&#123;</span><br><span class="line">console.log(&quot;rej&quot;+val);&#125;)</span><br><span class="line">.catch(function(e)&#123;console.log(&quot;err&quot;+e);&#125;);</span><br><span class="line">//rejrej</span><br><span class="line">//Uncaught Error: cuowu//无论用rej还是res,Promise里设置延时报错都不会被catch捕获（Promise已经结束了）</span><br></pre></td></tr></table></figure></p><h3 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all/Promise.race"></a>Promise.all/Promise.race</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。（and的判定方式）</p><p>Promise.all一般使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br><span class="line">//p的状态由p1/p2/p3决定，p1&amp;&amp;p2&amp;&amp;p3的关系，均resolve才resolve,任意一个rejected就rejected.</span><br><span class="line">//传值：p状态resolve时，p1/p2/p3的返回值组成数组传给p的回调函数，</span><br><span class="line">//p状态rejected时，第一个被rejected的实例返回值传给p的回调函数。</span><br></pre></td></tr></table></figure></p><ul><li>接受一个数组参数（非数组也可，必须有Iterator接口），且返回的每个成员都是Promise实例。</li><li>若参数成员不是Promise实例会调用Promise.resolve方法将其转为Promise实例，再进一步处理。</li><li>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法，会被自己的catch方法捕获，而后返回的实例状态变成resolve，使得Promise.all()的整体状态可能变成resolve。</li></ul><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。（or的判定方式）</p><ul><li>只要参数中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</li><li>若参数成员不是Promise实例会调用Promise.resolve方法将其转为Promise实例（与all相同）。</li></ul><h3 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve/Promise.reject"></a>Promise.resolve/Promise.reject</h3><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>Promise.resolve方法可以将现有对象转为Promise对象。根据resolve()方法参数的不同有4种情况：</p><ol><li>参数是Promise对象，则不做任何修改、原封不动返回实例。</li><li>参数是一个thenable对象（即对象具有then方法）<ul><li>thenable被转为Promise实例后会直接调用then方法。</li><li>thenable的then函数中，使用rej和res可以改变实例状态,return不会被当成res对待，error会被当成rej对待。</li><li>thenable的then函数中，不使用res和rej则状态为pending，p1将不会执行then和catch。</li></ul></li><li>参数不是具有then方法的对象，或根本就不是对象<ul><li>返回一个新的Promise对象，状态为resolved，同时可以传值给回调函数(Promise.resolve(“abc”))。</li></ul></li><li>不带任何参数(Promise.resolve())<ul><li>直接返回Promise对象，状态为resolved。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let thenable = &#123;//thenable被转为Promise实例后会直接调用then方法。</span><br><span class="line">  then: function(res, rej) &#123;</span><br><span class="line">    rej(42);//res(3);//使用rej和res可以改变实例状态,return不会被当成res对待，error会被当成rej对待。</span><br><span class="line">    //console.log(1);//不使用res和rej则状态为pending，p1将不会执行then和catch。</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let p1 = Promise.resolve(thenable);</span><br><span class="line">p1.then(function(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;).catch(val=&gt;console.log(val));//thenable中then函数rejected/error会被捕获</span><br></pre></td></tr></table></figure><p>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时（宏任务与微任务）。</p><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>Promise.reject方法与Promise.resolve类似，返回一个新的Promise实例，只是状态为rejected。</p><p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p><p>Promise.reject(thenable)参数的thenable函数reject后，其信息不会被后续catch捕获，而是thenable对象被捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(&apos;出错了&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.reject(thenable)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">  console.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line">//true  //catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><ul><li>finally用于指定不管Promise对象最后状态如何都会执行的操作，ES2018引入。</li><li>finally不接受任何参数，因此也无法得知Promise的状态是fulfilled还是rejected，这表明finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li><li>finally的回调函数中写不写return都不影响finally函数将前面Promise的状态和值（PromiseStatus和PromiseValue）往后传递。</li><li>finally函数执行后返回的还是一个Promise。</li></ul><p>finally特性（不接受参数+传递状态和值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(2).finally((val) =&gt; &#123;console.log(val)&#125;);</span><br><span class="line">//undefined   //finally中参数val无效</span><br><span class="line">//[[PromiseStatus]]: &quot;resolved&quot;  [[PromiseValue]]: 2    //可以传递Promise的状态和值</span><br><span class="line">Promise.resolve(2).finally((val=3) =&gt; &#123;console.log(val+1)&#125;) //4   //默认参数有效但与Promise无关</span><br></pre></td></tr></table></figure></p><h3 id="Promise-try"><a href="#Promise-try" class="headerlink" title="*Promise.try()"></a>*Promise.try()</h3><p>用于处理不区分/确认是同步or异步操作的情况，可以做到若try(a)的a是同步函数则同步执行，是异步函数则异步执行。浏览器还未原生支持，romise 库Bluebird、Q和when提供了该方法。自己实现该功能则是使用立即执行函数+async/promise：</p><p>async函数实现-同步操作同步执行，异步操作异步执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(async () =&gt; f())()//f若是同步则会立即得到同步结果（后续有then函数则进入then函数），</span><br><span class="line">.then(...)          //若异步则可以用then和catch进行下一步操作。</span><br><span class="line">.catch(...);      //async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure></p><p>new Promise实现-同步操作同步执行，异步操作异步执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(() =&gt; new Promise(</span><br><span class="line">    resolve =&gt; resolve(f());  //使用resolve时用”f()“立即执行f函数。</span><br><span class="line">))();</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure></p><p>Promise.try可以更好地管理异常，不论是同步操作or异步操作时抛出的错误。</p><ol><li>在构造 Promise 的时候，构造函数内部的代码是立即执行的；</li><li>Promise一旦运行，不能终止。</li><li>利用Promise处理一个异步的后续处理十分简便，但是处理多个请求按顺序执行仍然很不方便。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><hr><h2 id="Generator-yield"><a href="#Generator-yield" class="headerlink" title="Generator/yield"></a>Generator/yield</h2><p>ES6中提供的一种异步编程解决方案，中文称为生成器，生成器可以在执行的时候暂停，交出函数执行权给其他函数，然后其他函数可以在需要的时候让该函数再次运行。</p><ol><li>function和函数名之间加星号*，函数内部用yield划分不同操作or状态来暂停函数，函数外部用next方法重新启动。</li><li>yield 表达式本身没有返回值，返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。</li></ol><p>generator函数使用基本方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;  //加星号（无规范，在function与函数名之间即可，空格在哪边或者没有空格均可）</span><br><span class="line">  console.log(&quot;begin&quot;);</span><br><span class="line">  let y = 2 * (yield (x + 1));  //yield表达式作为暂停标记</span><br><span class="line">  let z = yield (y / 3);</span><br><span class="line">  return (x + y + z); //若此处return换成yield，则next执行至此返回的done=false，需再执行一次next，done=true；</span><br><span class="line">&#125;</span><br><span class="line">let it = foo(5);  //首次执行函数不会执行函数内部（begin不会被打印），只传递参数，返回的是一个指向内部状态的指针对象（遍历器）。</span><br><span class="line">console.log(it.next());   //next执行后函数内部继续执行，停在下一个yield处，返回的对象包含value和done两个属性；</span><br><span class="line">// =&gt; &#123;value: 6, done: false&#125; //value为yield后面的表达式的值，done表示遍历是否结束；</span><br><span class="line">console.log(it.next(12))  //next(12)函数可以传入参数，会传到继续执行的yield处代替上一次的yield表达式；</span><br><span class="line">// =&gt; &#123;value: 8, done: false&#125; //12代替(x+1)因此y=24,本次next停在y/3处所以next.value=8</span><br><span class="line">console.log(it.next(13))  //13传入即z=13</span><br><span class="line">// =&gt; &#123;value: 42, done: true&#125;   //next.value=5+24+13=42,因为本次next执行至return所以done=true；</span><br></pre></td></tr></table></figure></p><p>当一个对象的属性是 Generator 函数，可以简写成 ：* 属性名(){}的形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;  * myGeneratorMethod() &#123; ···&#125;&#125;; //属性前加*,表明属性是个generator函数。</span><br><span class="line">let obj = &#123; myGeneratorMethod : function* () &#123;...&#125;&#125;;  //两种写法等价</span><br></pre></td></tr></table></figure></p><h3 id="yield与yield"><a href="#yield与yield" class="headerlink" title="yield与yield*"></a>yield与yield*</h3><h4 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h4><ul><li>yield关键词作为每次函数执行next方法的分界点，其后面跟着的表达式会等到调用了next方法并执行到此处时才会进行计算。</li><li>当generator函数里没有使用yield表达式时，此时函数变成一个单纯的暂缓执行函数。（f.()不会执行内部语句，f.().next();才会执行）</li><li>yield关键词若不在generator函数里会报错（即函数是否加*)。</li></ul><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>用来在一个generator函数里执行另一个generator函数。当yield后面跟着的对象是另一个generator函数时，使用yield*可以进入其内部继续遍历状态。</p><p>yield*使用对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* inner() &#123;</span><br><span class="line">  yield &apos;hello!&apos;;</span><br><span class="line">&#125;</span><br><span class="line">function* outer() &#123;</span><br><span class="line">  yield &apos;open&apos;;</span><br><span class="line">  yield inner();</span><br><span class="line">  yield* inner();</span><br><span class="line">  yield &apos;close&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var gen = outer();</span><br><span class="line">gen.next().value // &quot;open&quot;</span><br><span class="line">gen.next().value // 返回一个遍历器对象。（不会进入内部）</span><br><span class="line">gen.next().value // &quot;hello!&quot;    //该yield带*表明后续表达式也是generator函数，会进入内部遍历状态。</span><br><span class="line">gen.next().value // &quot;close&quot;</span><br></pre></td></tr></table></figure></p><ul><li>yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for…of循环。</li><li>有return语句时，则需要用let value = yield* iterator的形式获取return语句的值（done=true时会直接略过value跳出函数继续寻找yield，但整个函数返回值为return后的值）。</li><li>任何数据结构只要有 Iterator 接口，就可以被yield*遍历（数组，字符串等等）。</li></ul><p>yield*后跟着一个带有return语句的generator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* genFuncWithReturn() &#123;</span><br><span class="line">  yield &apos;a&apos;;</span><br><span class="line">  yield &apos;b&apos;;</span><br><span class="line">  return &apos;The result&apos;;</span><br><span class="line">&#125;</span><br><span class="line">function* logReturned(genObj) &#123;</span><br><span class="line">  let result = yield* genObj;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">[...logReturned(genFuncWithReturn())]</span><br><span class="line">// The result</span><br><span class="line">// 值为 [ &apos;a&apos;, &apos;b&apos; ]</span><br></pre></td></tr></table></figure></p><h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><ul><li>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li><li>由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。</li></ul><p>如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p><p>包装generator函数，首次next()在内部执行，外部从第二次开始（对于外部而言为第一次）即可传入参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function wrapper(generatorFunction) &#123;</span><br><span class="line">  return function (...args) &#123; //return第一个函数：包涵generator函数并执行一次的next.</span><br><span class="line">    let generatorObject = generatorFunction(...args);</span><br><span class="line">    console.log(args[0]);</span><br><span class="line">    generatorObject.next();</span><br><span class="line">    return generatorObject;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const wrapped = wrapper(function* () &#123;</span><br><span class="line">  console.log(`First input: $&#123;yield&#125;`);</span><br><span class="line">  return &apos;DONE&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">wrapped(1).next(&apos;hello!&apos;);  //1   // First input: hello!</span><br></pre></td></tr></table></figure></p><h3 id="generator函数遍历–针对同步操作"><a href="#generator函数遍历–针对同步操作" class="headerlink" title="generator函数遍历–针对同步操作"></a>generator函数遍历–针对同步操作</h3><p>（iterator接口：for…of、…扩展运算符、Array.from）</p><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p><p>generator函数执行后，返回的遍历器对象，其本身也具有Symbol.iterator属性，执行后返回自身。</p><p>gen() === gen()[Symbol.iterator]()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br><span class="line">let g = gen();</span><br><span class="line">g[Symbol.iterator]() === g   //// true</span><br></pre></td></tr></table></figure></p><p>generator函数赋值给对象的Symbol.iterator后，对象就可以被”…“扩展运算符遍历。</p><p>generator函数赋值给Symbol.iterator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p><p>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以下面代码的return语句返回的7，不包括在for…of循环之中。</p><p>generator函数用for循环自动执行(方便地取出嵌套数组的内容)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [[2, 3], 4], [5, 6]];</span><br><span class="line">let flat = function* (a) &#123;</span><br><span class="line">  let length = a.length;</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    let item = a[i];</span><br><span class="line">    if (typeof item !== &apos;number&apos;) &#123;</span><br><span class="line">      yield* flat(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 7； //for...of循环不会返回7，因为此时done=true。</span><br><span class="line">&#125;;</span><br><span class="line">for (let f of flat(arr)) &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">// 1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure></p><p>原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 generator 函数为它加上这个接口，就可以用了。可以把对象作为参数传递给generator函数，然后使用for…of  gen(object)方式来遍历对象属性。也可以直接把写好的generator函数赋值给对象的Symbol.iterator属性，然后再遍历（后者更直观）。</p><p>除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><p>扩展运算符，Array.from，解构赋值，for…of循环分别遍历generator函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  return 3;</span><br><span class="line">&#125;</span><br><span class="line">[...numbers()]        // 扩展运算符  // [1, 2]</span><br><span class="line">Array.from(numbers());    // Array.from 方法  // [1, 2]</span><br><span class="line">let [x, y] = numbers();   // 解构赋值   //x=&gt; 1,y =&gt; 2</span><br><span class="line">for (let n of numbers()) &#123;    // for...of 循环</span><br><span class="line">  console.log(n);         // 1  // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="generator函数throw、return方法"><a href="#generator函数throw、return方法" class="headerlink" title="generator函数throw、return方法"></a>generator函数throw、return方法</h3><h4 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h4><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误(gen.throw())，然后在 Generator 函数体内捕获(try…catch)。</p><p>gen.throw()示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var g = function* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    yield 2.5;    //2.5会成为throw的返回值，若没有执行throw方法此yield会被略过。</span><br><span class="line">    yield 2.7;    //2.7因为throw只会被捕获一次，因此会被throw紧接着的next取得，若throw紧接着还是throw则略过。</span><br><span class="line">    console.log(&apos;内部捕获&apos;, e);</span><br><span class="line">  &#125;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">var i = g();</span><br><span class="line">i.next();   //value:1</span><br><span class="line">try &#123;</span><br><span class="line">  i.throw(&apos;a&apos;);   //value=2.5; throw除了抛出错误的语义外同时兼顾执行一次yield（catch内部的或是后续的，try里的略过）。</span><br><span class="line">  i.throw(&apos;b&apos;);   //第二次执行throw函数由于内部已经执行过catch了，不会再捕获一次。</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&apos;外部捕获&apos;, e);       // 内部捕获 a   // 外部捕获 b</span><br><span class="line">&#125;</span><br><span class="line">i.next();   //value:undefined,done:true</span><br><span class="line">i.next();   //由于第二次throw被外部捕获，对内部而言即出错终止了，因此后续都是undefined。</span><br><span class="line">//若没有第二次throw，则后两次next函数的value为2.7和3（2被第一次throw方法跳过了）。</span><br></pre></td></tr></table></figure></p><ul><li>generator函数的throw方法与全局throw方法不同，后者只能被函数外的catch捕获（即在generator函数内部用全局throw抛出错误）。</li><li>如果 generator 函数内部没有部署try…catch代码块，那么generator的throw方法抛出的错误，将被外部try…catch代码块捕获。generator函数则相当于出错终止继续执行外部代码，使用next方法会返回{value:undefined, done=true}。</li><li>如果 generator 函数内部和外部都没有部署try…catch代码，那么执行generator函数的throw方法程序将报错直接中断所有代码执行。</li><li>throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法（这样才启动执行了内部代码）。</li><li>throw方法被generator内部try模块捕获进入catch会默认执行一次next，停在catch内部或后续代码中的yield处。</li><li>generator 函数体内抛出的错误，可以被函数体外的catch捕获。</li></ul><h4 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h4><p>generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 generator 函数。</p><p>gen.return()示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;   //当外部使用numbers.return()方法时，会等待finally执行完成后再执行return。</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g = numbers();</span><br><span class="line">g.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">g.return(7) // &#123; value: 4, done: false &#125;  //本次return因为内部有finally存在因此返回其内部的4。</span><br><span class="line">g.next() // &#123; value: 5, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 7, done: true &#125;  //finally模块内执行完成后的下一次next直接是当时return的效果。</span><br></pre></td></tr></table></figure></p><h4 id="next-throw-return-的共同点"><a href="#next-throw-return-的共同点" class="headerlink" title="next(),throw(),return()的共同点"></a>next(),throw(),return()的共同点</h4><p>next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。</p><ul><li>next()是将yield表达式替换成一个值。</li><li>throw()是将yield表达式替换成一个throw语句(需要被内部try模块catch，否则寻求外部try模块)。</li><li>return()是将yield表达式替换成一个return语句(函数终止效果，遇上finally需等待finally内部执行完毕再终止)。</li></ul><h3 id="generator函数的this"><a href="#generator函数的this" class="headerlink" title="generator函数的this"></a>generator函数的this</h3><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。但如果把generator函数当作普通的构造函数，并不会生效，因为其返回的总是遍历器对象，而不是this对象。</p><p>generator函数的this使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function* g() &#123; </span><br><span class="line">  this.a = 1; </span><br><span class="line">  yield this.b = 2;  </span><br><span class="line">  yield this.c = 3; </span><br><span class="line">&#125;</span><br><span class="line">g.prototype.hello = function () &#123; return &apos;hi!&apos;;&#125;;</span><br><span class="line">let obj = g();</span><br><span class="line">obj instanceof g // true    //obj是g的实例，继承了g.prototype</span><br><span class="line">obj.hello() // &apos;hi!&apos;</span><br><span class="line">obj.next();</span><br><span class="line">obj.a     //undefined   //obj拿不到this对象的属性。</span><br><span class="line">new g();  /// TypeError: g is not a constructor   //使用new来创建实例报错，g不是构造函数。</span><br><span class="line">​</span><br><span class="line">//generator函数用call方法绑定对象，指向函数内部的this对象。</span><br><span class="line">let o = &#123;&#125;;</span><br><span class="line">let gen = g.call(o);</span><br><span class="line">gen.next(); gen.next();   // value分别为2和3 与正常generator函数相同。</span><br><span class="line">console.log(&quot;a:&quot;+o.a+&quot; b:&quot;+o.b+&quot; c:&quot;+o.c);  // a:1 b:2 c:3  </span><br><span class="line">//obj对象成为了g函数的实例，但与g函数执行返回遍历器对象gen是分离的。</span><br><span class="line">​</span><br><span class="line">//将generator函数用call方法绑定自身prototype对象。</span><br><span class="line">let gg = g.call(g.prototype);</span><br><span class="line">gg.next();gg.next();  //value分别为2和3 与正常generator函数相同。</span><br><span class="line">console.log(&quot;a:&quot;+gg.a+&quot; b:&quot;+gg.b+&quot; c:&quot;+gg.c); // a:1 b:2 c:3</span><br><span class="line">​</span><br><span class="line">//将g改造成构造函数，就可以执行new命令</span><br><span class="line">function G()&#123;</span><br><span class="line">  return g.call(g.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="generator函数自动执行–针对异步操作（thunk、co）"><a href="#generator函数自动执行–针对异步操作（thunk、co）" class="headerlink" title="generator函数自动执行–针对异步操作（thunk、co）"></a>generator函数自动执行–针对异步操作（thunk、co）</h3><p>generator函数解决了使用Promise时多个异步操作顺序执行代码冗余、语义模糊的问题，在多个异步操作顺序执行的表示上非常清晰。</p><p>generator函数最大的问题是如何在函数外部用next重新启动函数，手动执行在多个异步操作嵌套时异常繁琐，因此有thunk函数、co库可以自动执行generator函数。而简易版实现就是配合Promise实现自动执行。</p><h4 id="thunk函数"><a href="#thunk函数" class="headerlink" title="thunk函数"></a>thunk函数</h4><p>thunk函数在JavaScript中是用于将多参数函数封装成只接受一个回调函数参数的单参数函数。</p><p>现有的thunkify模块就是实现这样的一个封装器。</p><p>thunkify模块使用示例及源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let thunkify = require(&apos;thunkify&apos;); //事先需要安装模块  npm install thunkify 。</span><br><span class="line">let f = thunkify(fn);   //封装方法：将需要封装的带有回调函数参数的方法传入thunkify即可。</span><br><span class="line">f(para1,para2...)(cb);  //使用方法：将回调函数作为第二次执行（第一次执行后返回函数）的参数，其余参数在第一次执行时传入。</span><br><span class="line">​</span><br><span class="line">//源码</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line">function thunkify(fn)&#123;</span><br><span class="line">  assert(&apos;function&apos; == typeof fn, &apos;function required&apos;); //判断fn是否为函数。</span><br><span class="line">​</span><br><span class="line">  return function()&#123;</span><br><span class="line">    var args = new Array(arguments.length); //根据返回的function执行时传入的参数个数创建数组。</span><br><span class="line">    var ctx = this;     //保留上下文环境this。</span><br><span class="line">​</span><br><span class="line">    for(var i = 0; i &lt; args.length; ++i) &#123;  //传入参数赋值给数组args。</span><br><span class="line">      args[i] = arguments[i];         </span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return function(done)&#123;    //返回函数，参数为回调函数。</span><br><span class="line">      var called;             //标记，是否执行过回调函数。</span><br><span class="line">​</span><br><span class="line">      args.push(function()&#123;   //将回调函数封装推入args参数数组，作为最后一个参数。</span><br><span class="line">        if (called) return;   //封装回调函数主要是判断是否已执行过回调函数，执行过则直接return，推入args的相当于一个空函数。</span><br><span class="line">        called = true;</span><br><span class="line">        done.apply(null, arguments);  </span><br><span class="line">      &#125;);</span><br><span class="line">​</span><br><span class="line">      try &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>thunk函数简单来说就是将带有回调函数的方法的执行方式从f(a, b, c, callback)包装成f(a, b, c)(callback)。<br>thunk函数的作用本身并不显著，关键在于和generator函数结合在一起，使generator函数可以自动执行。</p><p>thunk函数与generator函数结合，自动执行（针对异步操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//针对同步操作的generator函数自动执行方法有几种，核心都是借助generator函数执行后返回的是一个遍历器，但这仅仅适合同步操作。</span><br><span class="line">//thunk函数自动执行generator函数的核心点在于用递归的方式在回调函数中使用next重新启动generator函数。</span><br><span class="line">var fs = require(&apos;fs&apos;);var thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">var readFileThunk = thunkify(fs.readFile);//将文件读取函数封装为thunk函数。</span><br><span class="line">​</span><br><span class="line">//generator函数示例，内部包含两次文件读取操作。</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    console.log(&quot;进入generator&quot;);</span><br><span class="line">      //当run函数第二次执行gen.next(data)时，r1=data取到文件读取结果。</span><br><span class="line">      //value= readFileThunk(&apos;test2.txt&apos;, &apos;utf8&apos;)，执行后返回thunk函数接收回调函数作为参数。</span><br><span class="line">    var r1 = yield readFileThunk(&apos;test.txt&apos;, &apos;utf8&apos;);//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r1);    </span><br><span class="line">    var r2 = yield readFileThunk(&apos;test2.txt&apos;, &apos;utf8&apos;);//test2-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r2);</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">//配合thunk递归调用自动执行generator函数</span><br><span class="line">function thunkGenerator(f)&#123;</span><br><span class="line">    let fn=f();     //执行一次generator函数，得到遍历器。</span><br><span class="line">    let time=0;     </span><br><span class="line">    function next(err,data)&#123;  //thunk回调函数，因此要求generator函数中yield后跟着的必须是一个thunk函数（接收回调函数参数）。</span><br><span class="line">        if(err)throw err;</span><br><span class="line">        console.log(&quot;第&quot;+(++time)+&quot;次进入自定义next函数&quot;);</span><br><span class="line">        let res=fn.next(data);  //执行next，定位到下一个yield，传入data使gen函数拿到文件读取结果。</span><br><span class="line">        if (res.done) return;  //若done=true表明generator函数执行完毕，直接返回。</span><br><span class="line">        res.value(next);      //result.value是一个接收回调函数作为参数的thunk函数，next作为回调函数传入，当文件读取成功后执行。</span><br><span class="line">                              //此处真正执行读取文件操作，待读取成功后执行回调函数next。</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">thunkGenerator(gen);//用thunkGenerator函数自动执行gen函数。</span><br><span class="line">//第1次进入自定义next函数</span><br><span class="line">//进入generator</span><br><span class="line">//第2次进入自定义next函数</span><br><span class="line">//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">//第3次进入自定义next函数</span><br><span class="line">//test2-When you look long into an abyss, the abyss looks into you.</span><br></pre></td></tr></table></figure></p><p>thunk函数跟在yield后面，在thunk的回调函数中执行next重新启动generator函数，递归方式遍历generator。</p><h4 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h4><p>co模块是结合promise对象来使generator函数自动执行。co(gen)执行后返回一个promise对象，用then方法添加最后的回调函数。</p><p>co模块使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);var co = require(&quot;co&quot;);var readFileThunk = thunkify(fs.readFile);</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    console.log(&quot;进入generator&quot;);</span><br><span class="line">    var r1 = yield readFileThunk(&apos;test.txt&apos;, &apos;utf8&apos;);//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r1);</span><br><span class="line">    var r2 = yield readFileThunk(&apos;test2.txt&apos;, &apos;utf8&apos;);//test2-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r2);</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">//使用co函数库自动执行generator函数</span><br><span class="line">//co(gen);co函数返回的事一个promise对象，可以用then添加回调函数；</span><br><span class="line">co(gen).then(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;generator函数执行完毕。&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">//进入generator</span><br><span class="line">//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">//test2-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">//generator函数执行完毕。</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>co模块源码中，自动执行generator函数的next函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function next(ret) &#123;</span><br><span class="line">  if (ret.done) return resolve(ret.value); //判断generator函数是否执行完毕。</span><br><span class="line">  var value = toPromise.call(ctx, ret.value); //将每一步返回的value都转为promise对象。</span><br><span class="line">  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);  //用then方法传入回调函数onFulfilled和onRejected，在两个函数内部继续调用next函数。</span><br><span class="line">  return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos;</span><br><span class="line">     + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));  //参数不符合要求（函数、promise、generator、array、object以外）的情况下直接rejected，终止执行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对比thunk函数与co模块中自动执行generator的next函数，核心逻辑都是在递归调用next，在回调函数里重启generator。</li><li>在自动执行generator上，相较于使用 thunk函数, 使用co模块能够接受的参数种类更多。</li><li>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。只需把并发的操作都放在数组或对象里面，跟在yield语句后面。</li></ul><hr><h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p>async函数在generator函数的基础上进行了改进。</p><ul><li>语义清晰。async表示异步，await表示等待。</li><li>自动执行。async函数执行后，自动逐步执行内部各个语句，在await处等待操作完成后自动继续往下执行。</li><li>返回值为Promise对象。可以执行async函数后使用then函数进行下一步操作。</li></ul><p>async函数使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//函数声明</span><br><span class="line">async function f()&#123;&#125;</span><br><span class="line">//表达式</span><br><span class="line">let fn = async function ()&#123;&#125;;</span><br><span class="line">//对象的方法</span><br><span class="line">let obj = &#123;async f()&#123;&#125;&#125;;  obj.f().then();</span><br><span class="line">//Class的方法</span><br><span class="line">Class Test()&#123;</span><br><span class="line">  async fn()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = new Test();  test.fn().then();</span><br><span class="line">//箭头函数</span><br><span class="line">let func = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>基本使用方法：</p><ul><li>async函数内部用await暂停函数，用法类似yield，但await会在后面跟着的异步操作执行完成后自动继续执行。</li><li>await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li>返回的Promise对象的状态取决于async函数内部，return  aa，则promise对象状态为resolved，aa作为then函数参数；throw 错误则promise对象状态为rejected，错误作为参数传入catch函数or then函数的第二个参数函数。</li><li>async函数绑定的then方法必须等到async内部的所有异步操作执行完才会被调用，即遇到有return or 错误抛出，若都没有的话，执行完最后的语句后async函数仍然返回一个状态为resolved的promise对象，但无任何数据传递。</li></ul><p>await后面跟着的命令：</p><ul><li>通常await后面跟着promise对象，返回该对象的结果，如果不是promise对象，就直接返回对应值，如 await 123，若想向async函数外传值则可以 return await 123，等同于return 123。</li><li>若await后面跟着的promise对象状态返回为rejected，则会中断整个async函数，并且返回rejected传递的参数（前面不需要return，因为等同于报错，会被外面的catch捕获），若rejected的promise对象被try…catch模块包含or promise对象本身带有catch方法，可以捕获到该rejected或者错误，进行一些处理，并继续执行async函数。</li><li>await后面若跟着一个thenable对象（定义了then方法的对象），await也会将其视为promise对象处理，执行其then方法。</li><li>多个异步操作可以同时触发，可以使用Promise.all/race 或用同步语句分别执行异步操作，后续使用await分别等待异步操作的返回结果。</li><li>await命令在async函数外会报错。</li><li>async函数在遇到await时暂停执行（转而执行await后面带的命令），此时会保留上下文环境。</li></ul><p>async函数是目前最集大成的JS异步操作方式，但回调函数、promise、generator同样适合许多应用场景。在实际环境中，根据不同的需求来选取不同的方法才是最合适的。 </p><hr><h2 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h2><p></p><p class="codepen" data-height="465" data-theme-id="0" data-default-tab="js,result" data-user="linxiaowen0127" data-slug-hash="BaBYMvN" style="height: 465px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="BaBYMvN"><br>  <span>See the Pen <a href="https://codepen.io/linxiaowen0127/pen/BaBYMvN/" target="_blank" rel="noopener"><br>  BaBYMvN</a> by linxiaowen0127 (<a href="https://codepen.io/linxiaowen0127" target="_blank" rel="noopener">@linxiaowen0127</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>异步方式</th><th>优点</th><th>缺点</th><th>备注</th></tr></thead><tbody><tr><td>1、回调函数</td><td>简单、逻辑上易理解、易实现</td><td>多个嵌套时：代码耦合高难以维护，程序结构混乱；流程难以追踪；错误捕获困难；</td><td>1-2个异步操作按顺序执行时，使用回调函数显得很便捷很简单，也不会造成难以维护的情况。多个异步操作时谢绝直接使用回调函数进行流程控制。回调函数是其他所有异步操作的基石。</td></tr><tr><td>2、事件监听</td><td>理解也较为容易；有效去耦合；多对多（事件与触发的函数），更灵活；</td><td>事件驱动型，流程不清晰；多对多也会造成事件的监听与触发混乱；</td><td>非常常用，最多的应该是点击事件触发。事件监听同样不建议用来控制大型/较复杂的流程运转。</td></tr><tr><td>3、发布订阅（事件监听升级版）</td><td>消息中心的存在让消息（事件）、订阅者（回调函数）更加清晰且更好掌控；</td><td>实现较为复杂（特别是包含取消订阅等功能时）则占用内存也多；大量使用时跟踪bug较为困难；</td><td>Vue也是基于发布-订阅（可能3+版会更改实现方式）。要实现较为完备的发布订阅相当复杂。少数异步操作不建议使用。感觉是系统级的而不是用来操控几个异步流程。</td></tr><tr><td>4、Promise</td><td>链式调用，流程清晰；</td><td>配套方法较完善；可串行可并行执行多个异步操作；一旦开始，无法取消；pending状态无法确认是刚开始还是即将结束；复杂情况时代码冗余、语义不清；</td><td>也非常常用，并且可以配合async达到自动按顺序执行效果。实际运用中例如HTTP请求会封装在promise里，更好的进行请求返回的下一步操作以及错误捕获处理。</td></tr><tr><td>5、Generator（生成遍历器对象）</td><td>将异步操作表达得像同步操作一样；语法简单，流程清晰，代码实现简洁；外部调用next可携带数据到内部；</td><td>手动迭代较麻烦（有thunk、co库可辅助）；yield语义不清；</td><td>generator返回遍历器对象的特性，让其拥有了进行异步操作流程控制以外的功能，例如可利用generator进行对象的属性遍历并进行一定的操作。甚至可以被视为一种数据结构。</td></tr><tr><td>6、Async（基于Promise，Gnerator升级版）</td><td>可自动执行流程（对于generator的next方法的改进）；语法简单，流程清晰，代码实现简洁；</td><td>多个异步操作若不存在依赖关系时，使用async降低性能；</td><td>await后面直接跟着回调函数不生效（例如await setTimout(500,()=&gt;{…})，并不会等延迟操作结束后再继续往下），需将其封装为Promise。</td></tr></tbody></table><p>本文主要JS的几种异步语法进行介绍，对JS异步语法的发展过程及各API进行了学习举例，其中很多结论及代码例子来源于下列参考文献，总结不到位的地方还请大家批评指正。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>阮一峰ES6入门 <a href="http://es6.ruanyifeng.com/#docs/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/</a><br>详解前端异步编程的六种方案 <a href="https://www.infoq.cn/article/zwowtega7KjC4Ad-trp4" target="_blank" rel="noopener">https://www.infoq.cn/article/zwowtega7KjC4Ad-trp4</a><br>夯实基础-JavaScript异步编程 <a href="https://segmentfault.com/a/1190000014874668" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014874668</a><br>co源码 <a href="https://github.com/tj/co" target="_blank" rel="noopener">https://github.com/tj/co</a><br>thunkify 源码 <a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener">https://github.com/tj/node-thunkify</a><br>Javascript设计模式之发布-订阅模式 <a href="https://juejin.im/post/5a9108b6f265da4e7527b1a4" target="_blank" rel="noopener">https://juejin.im/post/5a9108b6f265da4e7527b1a4</a><br>JS 异步编程六种方案 <a href="https://juejin.im/post/5c30375851882525ec200027" target="_blank" rel="noopener">https://juejin.im/post/5c30375851882525ec200027</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对Javascript中异步编程的几种语法以及使用方式进行了介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Linxiaowen" scheme="http://xgfe.github.io/categories/Linxiaowen/"/>
    
    
      <category term="JS异步" scheme="http://xgfe.github.io/tags/JS%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 异步</title>
    <link href="http://xgfe.github.io/2019/07/29/hardhpp/javascript%20%E5%BC%82%E6%AD%A5/"/>
    <id>http://xgfe.github.io/2019/07/29/hardhpp/javascript 异步/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.646Z</updated>
    
    <content type="html"><![CDATA[<p>介绍JavaScript异步的四种实现方式：1&gt;回调函数；2&gt;Promise；3&gt;生成器Gererator；4&gt;Async/Await。</p><a id="more"></a><p><strong>异步编程的核心：处理程序中现在运行的部分和将来运行的部分之间的关系。</strong></p><h2 id="方法一：回调函数"><a href="#方法一：回调函数" class="headerlink" title="方法一：回调函数"></a>方法一：回调函数</h2><p>回调是JavaScript中最基础的异步模式，常见于一个耗时操作后执行某个函数。</p><h3 id="例1-一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数"><a href="#例1-一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数" class="headerlink" title="例1: 一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数"></a>例1: 一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( function() &#123;</span><br><span class="line">  console.log(&apos;Time out&apos;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><h3 id="例2-异步读取文件后执行回调函数"><a href="#例2-异步读取文件后执行回调函数" class="headerlink" title="例2: 异步读取文件后执行回调函数"></a>例2: 异步读取文件后执行回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;); </span><br><span class="line">fs.readFile(&apos;./text1.txt&apos;, &apos;utf8&apos;, function(err, data)&#123;</span><br><span class="line">  if (err)&#123;</span><br><span class="line">    throw err;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>下面，我们使用回调函数实现一个简单的需求：某应用希望根据登录人的信息，获取不同的筛选项，再根据筛选项获取到相应的数据。</p><p>整个过程分为3步：</p><ol><li>调用获取登录人岗位接口，获取登录人信息</li><li>根据登录人的信息，获取相应的筛选项</li><li>根据筛选项信息，获取该登录人默认查看的信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let position, filter, source;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &apos;get&apos;,</span><br><span class="line">    url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">        position = data;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                position</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                filter = data;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    type: &apos;get&apos;,</span><br><span class="line">                    url: &apos;http://xx/getSource&apos;,</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        filter</span><br><span class="line">                    &#125;,</span><br><span class="line">                    success: function (data) &#123;</span><br><span class="line">                        console.log(&apos;查看数据：&apos;, data);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: function (err) &#123;</span><br><span class="line">                        console.log(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码存在两个问题：</p><ol><li><p>回调嵌套层数过多，调试困难，如果需求增加或者改变，代码难以维护和更新，即回调地狱</p></li><li><p>控制反转，即把sucess 和 error函数的执行控制交付给了第三方的ajax(..)，无法控制第三方工具的执行且第三方工具可能会出错</p></li></ol><p><strong>控制反转(inversion of control)</strong>：把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具(一组你希望有人维护的东西)之间有一份并没有明确表达的契约。</p><p>以下列出了三方工具可能出错的情况:</p><ul><li>调用回调过早(在追踪之前);</li><li>调用回调过晚(或没有调用);</li><li>调用回调的次数太少或太多(就像你遇到过的问题!);</li><li>没有把所需的环境 / 参数成功传给你的回调函数;</li><li>吞掉可能出现的错误或异常;</li><li>……</li></ul><p><strong>总结：回调函数存在的主要缺陷:缺乏顺序性和可信任性。</strong></p><h2 id="方法二：Promise"><a href="#方法二：Promise" class="headerlink" title="方法二：Promise"></a>方法二：Promise</h2><p>1.Promise解决回调函数中的信任问题，不是将自己的程序交给第三方，而是希望第三方给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。</p><p>2.链式的写法，能够使得代码表达的有顺序性。</p><h3 id="promise解决信任问题"><a href="#promise解决信任问题" class="headerlink" title="promise解决信任问题"></a>promise解决信任问题</h3><p><strong>1&gt;调用过早</strong></p><p>根据定义，Promise 就不必担心这种问题，因为即使是立即完成的 Promise(类似于 new Promise(function(resolve){ resolve(42); }))也无法被同步观察到。</p><p>也就是说，对一个 Promise 调用 then(..) 的时候，即使这个 Promise 已经决议，提供给then(..) 的回调也总会被异步调用。</p><p><strong>2&gt;调用过晚</strong></p><p>和前面一点类似，Promise 创建对象调用 resolve(..) 或 reject(..) 时，这个 Promise 的then(..) 注册的观察回调就会被自动调度。可以确信，这些被调度的回调在下一个异步事件点上一定会被触发。</p><p><strong>3&gt;回调未调用</strong></p><p>首先，没有任何东西(甚至 JavaScript 错误)能阻止 Promise 向你通知它的决议(如果它决议了的话)。如果你对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise在决议时总是会调用其中的一个。</p><p><strong>4&gt;调用次数过少或过多</strong><br>根据定义，回调被调用的正确次数应该是 1。“过少”的情况就是调用 0 次，和前面解释过的“未被”调用是同一种情况。</p><p>“过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次。如果出于某种原因，Promise 创建代码试图调用 resolve(..) 或 reject(..) 多次，或者试图两者都调用，那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。</p><p>由于 Promise 只能被决议一次，所以任何通过 then(..) 注册的(每个)回调就只会被调用一次。</p><p>当然，如果你把同一个回调注册了不止一次(比如p.then(f); p.then(f);)，那它被调用的次数就会和注册次数相同。响应函数只会被调用一次，但这个保证并不能预防你搬起石头砸自己的脚。</p><p><strong>5&gt;未能传递参数 / 环境值</strong></p><p>Promise 至多只能有一个决议值(完成或拒绝)。如果你没有用任何值显式决议，那么这个值就是 undefined，这是 JavaScript 常见的处理方式。但不管这个值是什么，无论当前或未来，它都会被传给所有注册的(且适当的完成或拒绝)回调。</p><p>还有一点需要清楚:如果使用多个参数调用 resovle(..) 或者 reject(..)，第一个参数之后的所有参数都会被默默忽略。这看起来似乎违背了我们前面介绍的保证，但实际上并没有，因为这是对 Promise 机制的无效使用。对于这组 API 的其他无效使用(比如多次重复调用 resolve(..))，也是类似的保护处理，所以这里的 Promise 行为是一致的(如果不是有点令人沮丧的话)。</p><p>如果要传递多个值，你就必须要把它们封装在单个值中传递，比如通过一个数组或对象。对环境来说，JavaScript 中的函数总是保持其定义所在的作用域的闭包(参见《你不知道的 JavaScript(上卷)》的“作用域和闭包”部分)，所以它们当然可以继续访问你提供的环境状态。当然，对于只用回调的设计也是这样，因此这并不是 Promise 特有的优点——但不管怎样，这仍是我们可以依靠的一个保证。</p><p><strong>6&gt; 吞掉错误或者异常</strong></p><p>如果在Promise的创建过程或在查看其决议结果过程中的任何时间点上出现了一个JavaScript异常错误，比如一个TypeError或RerenceError，那这个异常就会被捕获，并且会使这个Promise被拒绝。</p><h3 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h3><p>Promise 固有行为特性:</p><ul><li><p>每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来;</p></li><li><p>不管从 then(..) 调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置为被链接 Promise(第一点中的)的完成;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve( 21 );</span><br><span class="line">var p2 = p.then( function(v)&#123;</span><br><span class="line">  console.log( v );</span><br><span class="line">  // 用值42填充p2</span><br><span class="line">  return v * 2;</span><br><span class="line">&#125;);</span><br><span class="line">// 连接p2</span><br><span class="line">p2.then( function(v)&#123;</span><br><span class="line">    console.log( v ); // 42</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>改写上面应用中回调函数实现的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">let getPositionPromise = function () &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">               resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getFilterPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getListPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getSource&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getPositionPromise()</span><br><span class="line">    .then(function (data) &#123;</span><br><span class="line">        return getTokenPromise(&#123;position: data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (data) &#123;</span><br><span class="line">        return getDataPromise(&#123;filter: data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (data) &#123;</span><br><span class="line">        console.log(&apos;数据：&apos;, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法三：生成器Gererator"><a href="#方法三：生成器Gererator" class="headerlink" title="方法三：生成器Gererator"></a>方法三：生成器Gererator</h2><p><strong>ES6中的生成器（Gererator）是</strong>一种顺序、看似同步的异步流程控制表达风格。</p><h3 id="可迭代协议和迭代器协议"><a href="#可迭代协议和迭代器协议" class="headerlink" title="可迭代协议和迭代器协议"></a>可迭代协议和迭代器协议</h3><p><strong>可迭代协议</strong>运行JavaScript对象去定义或定制它们的迭代行为，例如（定义）在一个for…of结构中什么值可以被循环（得到）。以下内置类型都是内置的可迭代对象并且有默认的迭代行为：</p><ol><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的Arguments对象</li><li>NodeList对象</li></ol><p><strong>注意，Object不符合可迭代协议</strong>。</p><p>为了变成可迭代对象，一个对象必须实现@@iterator方法，意思是这个对象（或者它原型链prototype chain上的某个对象）必须有一个名字是Symbol.iterator的属性：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>[Symbol.iterator]</td><td>返回一个对象的无参函数，被返回对象符合迭代器协议</td></tr></tbody></table><p>当一个对象需要被迭代的时候（比如开始用于一个for…of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。</p><p><strong>迭代器协议</strong>定义了一种标准的方式来产生一个有限或无限序列的值。<br>当一个对象被认为是一个迭代器时，它实现了一个next()的方法并且拥有以下含义：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>next</td><td>返回一个对象的无参函数，被返回对象拥有两个属性：<br> <strong>1. done（boolean）</strong> - 如果迭代器已经经过了被迭代序列时为true。这时value可能描述了该迭代器的返回值  - 如果迭代器可以产生序列中的下一个值，则为false。这等效于连同done属性也不指定。<br><strong>2. value</strong> - 迭代器返回的任何JavaScript值。done为true时可以忽略。</td></tr></tbody></table><p>使用可迭代协议和迭代器协议的例子：</p><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;; </span><br><span class="line"></span><br><span class="line">// 可迭代协议使用for...of访问</span><br><span class="line">typeof str[Symbol.iterator]; // &apos;function&apos; </span><br><span class="line">for (var s of str) &#123;</span><br><span class="line">  console.log(s); // 分别打印 &apos;h&apos;、&apos;e&apos;、&apos;l&apos;、&apos;l&apos;、&apos;o&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 迭代器协议next方法</span><br><span class="line">var iterator = str[Symbol.iterator]();</span><br><span class="line">iterator.next(); // &#123;value: &quot;h&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;e&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;l&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;l&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;o&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p><strong>用Generator实现异步</strong></p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>如果我们用Generator改写上面回调嵌套的例子会是什么样的呢？见代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function getPosition () &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            it.next(data);</span><br><span class="line">        &#125;</span><br><span class="line">        error: function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getFilter (params) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">        data: params,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            it.next(data);</span><br><span class="line">        &#125;</span><br><span class="line">        error: function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getList (params) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;http://xx/getList&apos;,</span><br><span class="line">        data: params,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            it.next(data);</span><br><span class="line">        &#125;</span><br><span class="line">        error: function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *main () &#123;</span><br><span class="line">    let position = yield getPosition();</span><br><span class="line">    let filter = yield getFilter(&#123;position: position &#125;);</span><br><span class="line">    let List = yield getList(&#123;filter: filter&#125;);</span><br><span class="line">    console.log(&apos;列表数据：&apos;, List);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成迭代器实例</span><br><span class="line">var it = main();</span><br><span class="line"></span><br><span class="line">// 运行第一步</span><br><span class="line">it.next();</span><br><span class="line">console.log(&apos;不影响主线程执行&apos;);</span><br></pre></td></tr></table></figure><p>我们注意*main()生成器内部的代码，不看yield关键字的话，是完全符合大脑思维习惯的同步书写形式，把异步的流程封装到外面，在成功的回调函数里面调用it.next()，将传回的数据放到任务队列里进行排队，当JavaScript主线程空闲的时候会从任务队列里依次取出回调任务执行。</p><p>如果我们一直占用JavaScript主线程的话，是没有时间去执行任务队列中的任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行第一步</span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line">// 持续占用JavaScript主线程</span><br><span class="line">while(1) &#123;&#125;;// 这里是拿不到异步数据的，因为没有机会去任务队列里取任务执行</span><br></pre></td></tr></table></figure><p>综上，生成器Generator解决了回调函数处理异步流程的<strong>第一个问题：不符合大脑顺序、线性的思维方式。</strong>。</p><h2 id="方法四：Async-Await"><a href="#方法四：Async-Await" class="headerlink" title="方法四：Async/Await"></a>方法四：Async/Await</h2><p>Promise和Generator这两者结合起来，就是Async/Await。</p><p>Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。</p><p>我们把最开始的例子用Async/Await的方式改写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">let getPositionPromise = function () &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">               resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getFilterPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getListPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getList&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">async function main () &#123;</span><br><span class="line">    let position = await getPosition();</span><br><span class="line">    let filter = await getFilter(&#123;position: position &#125;);</span><br><span class="line">    let List = await getList(&#123;filter: filter&#125;);</span><br><span class="line">    console.log(&apos;列表数据：&apos;, List);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br><span class="line">console.log(&apos;不影响主线程执行&apos;);</span><br></pre></td></tr></table></figure><p>可以看到，使用Async/Await，完全就是同步的书写方式，逻辑和数据依赖都非常清楚，只需要把异步的东西用Promise封装出去，然后使用await调用就可以了，也不需要像Generator一样需要手动控制next()执行。</p><p><strong>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步流程存在的两个问题，可能是现在最好的JavaScript处理异步的方式了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过四个阶段来讲述JavaScript异步编程的发展历程：</p><ol><li><strong>第一个阶段 - 回调函数</strong>，但会导致两个问题:<ul><li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li><li>缺乏可信任性： 控制反转导致的一系列信任问题</li></ul></li><li><strong>第二个阶段 - Promise</strong>，Promise是基于PromiseA+规范的实现，它很好的解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来。</li><li><strong>第三个阶段 - 生成器函数Generator</strong>，使用Generator，可以让我们用同步的方式来书写代码，解决了顺序性的问题，但是需要手动去控制next(…)，将回调成功返回的数据送回JavaScript主流程中。</li><li><strong>第四个阶段 - Async/Await</strong>，Async/Await结合了Promise和Generator，在await后面跟一个Promise，它会自动等待Promise的决议值，解决了Generator需要手动控制next(…)执行的问题，真正实现了<strong>用同步的方式书写异步代码</strong>。</li></ol><blockquote><p>相关参考<br><a href="https://segmentfault.com/a/1190000015711829" target="_blank" rel="noopener">JavaScript异步编程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍JavaScript异步的四种实现方式：1&amp;gt;回调函数；2&amp;gt;Promise；3&amp;gt;生成器Gererator；4&amp;gt;Async/Await。&lt;/p&gt;
    
    </summary>
    
      <category term="hardhpp" scheme="http://xgfe.github.io/categories/hardhpp/"/>
    
    
      <category term="JavaScript" scheme="http://xgfe.github.io/tags/JavaScript/"/>
    
      <category term="异步" scheme="http://xgfe.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>【浅度解析】new Vue() 源码结构梳理</title>
    <link href="http://xgfe.github.io/2019/07/23/luoyu/vue/"/>
    <id>http://xgfe.github.io/2019/07/23/luoyu/vue/</id>
    <published>2019-07-23T05:47:00.000Z</published>
    <updated>2020-02-19T11:04:25.653Z</updated>
    
    <content type="html"><![CDATA[<p>new Vue() 源码结构浅度解析梳理。<br><a id="more"></a></p><h1 id="为什么是浅度解析？"><a href="#为什么是浅度解析？" class="headerlink" title="为什么是浅度解析？"></a>为什么是浅度解析？</h1><p>因为深度解析网上太多了，需要的话有太多资源，本文主要是为了帮助理解new Vue()时部分源码结构。</p><h1 id="本文适用人群？"><a href="#本文适用人群？" class="headerlink" title="本文适用人群？"></a>本文适用人群？</h1><p><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176153322.png" width="300px" height="300px"></p><p>大概知道Vue生命周期是怎么回事且琢磨过上面这张图的可放心食用。<br>当然了，没琢磨过也没有关系。<br>如果您有一定的vue开发经验以及理解可以直接Command+W。</p><hr><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>首先Git克隆项目源码:</p><pre><code>git clone https://github.com/vuejs/vue.git</code></pre><p>然后进入到路径：src/core/instance，可以看到如下文件：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176575342.jpg" width="500px" height="500px"></p><p>再来看看index.js做了什么，引入各部分初始化Mixin函数，在Vue函数中执行init.js的ths._init()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class="line">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class="line">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class="line">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class="line">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class="line">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure><p>所以，这几个文件的逻辑：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176154273.png" width="500px" height="500px"></p><h1 id="init逻辑及具体模块"><a href="#init逻辑及具体模块" class="headerlink" title="_init逻辑及具体模块"></a>_init逻辑及具体模块</h1><p>那么 _init 函数做了些什么呢？<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176566739.png" width="300px" height="300px"></p><h2 id="性能检测：开发环境下，标记时间"><a href="#性能检测：开发环境下，标记时间" class="headerlink" title="性能检测：开发环境下，标记时间"></a>性能检测：开发环境下，标记时间</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">mark(startTag)</span><br></pre></td></tr></table></figure><h2 id="合并方案：存在option且有子组件？"><a href="#合并方案：存在option且有子组件？" class="headerlink" title="合并方案：存在option且有子组件？"></a>合并方案：存在option且有子组件？</h2><p>  Y:因为Vue动态合并策略非常慢，并且内部组件的选项都不需要特殊处理。initInternalComponent，内部组件调用此快捷方法，内部组件实例化。<br>  N:策略合并options vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor),options || {},vm)</p><p>  详细解读可转至 <a href="https://github.com/CommanderXL/biu-blog/issues/20" target="_blank" rel="noopener">https://github.com/CommanderXL/biu-blog/issues/20</a></p><h2 id="代理方案："><a href="#代理方案：" class="headerlink" title="代理方案："></a>代理方案：</h2><p>  当前环境是开发环境，则调用initProxy方法。<br>  如果不是开发环境，则vue实例的_renderProxy属性指向vue实例本身。</p><p>  详细解读可看 <a href="https://juejin.im/post/5b11db686fb9a01e5b10eae7" target="_blank" rel="noopener">https://juejin.im/post/5b11db686fb9a01e5b10eae7</a></p><h2 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a>initLifecycle</h2><p>  向上循环找到第一个非抽象父组件对象，然后把当前vm实例push到定位的第一个非抽象parent的$children属性上，什么叫非抽象组件，比如transition和keep-alive。<br>  然后进行属性赋值。</p><p>  详细解读可看 <a href="https://juejin.im/post/5b1b4acf6fb9a01e573c3fcf" target="_blank" rel="noopener">https://juejin.im/post/5b1b4acf6fb9a01e573c3fcf</a><br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176547198.png" width="1000px" height="500px"></p><h2 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h2><p>  初始化父组件事件，updateListeners：遍历父组件事件组，迭代到当前组件上：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176592945.png" width="1000px" height="500px"></p><h2 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a>initRender</h2><p>  定义了各类渲染选项，并且对 （$attrs–继承所有的父组件属性）、（$listeners–子组件继承父组件的事件）进行，同时定义两个createElement方法：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/178851414.png" width="1000px" height="500px"></p><h2 id="callHook-vm-‘beforeCreate’"><a href="#callHook-vm-‘beforeCreate’" class="headerlink" title="callHook(vm, ‘beforeCreate’)"></a>callHook(vm, ‘beforeCreate’)</h2><p>  很好理解，触发beforeCreate钩子函数。</p><h2 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h2><p>  将祖先元素：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/178660101.png" width="1000px" height="500px"></p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><p>  创建数据，初始化。<br>  <strong>initProps</strong>：简单地说，遍历 props，给 props 设置响应式，给 props 设置代理，详细可见</p><p>  <strong>initMethods</strong>：这里主要是一串检测，然后绑定函数</p><p>  <strong>initData</strong>：挂载data</p><p>  <strong>initComputed</strong>：挂载Computed</p><p>  <strong>initWatch</strong>：挂载watch<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179281435.png" width="1000px" height="500px"></p><h2 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h2><p>  这里很简单,数据挂载后初始化Provide,如果时函数则call再挂在至_provided：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179310332.png" width="1000px" height="500px"></p><h2 id="callHook-vm-‘created’"><a href="#callHook-vm-‘created’" class="headerlink" title="callHook(vm, ‘created’)"></a>callHook(vm, ‘created’)</h2><p>  触发created钩子函数。</p><h2 id="mark-endTag"><a href="#mark-endTag" class="headerlink" title="mark(endTag)"></a>mark(endTag)</h2><p>  注意，created之后，计时结束。</p><h2 id="vm-mount-vm-options-el"><a href="#vm-mount-vm-options-el" class="headerlink" title="vm.$mount(vm.$options.el)"></a>vm.$mount(vm.$options.el)</h2><p>  如果存在元素,则触发mounted钩子函数：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179284931.png" width="1000px" height="500px"></p><h1 id="Minxin-funs"><a href="#Minxin-funs" class="headerlink" title="Minxin funs"></a>Minxin funs</h1><h2 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h2><p>  混入init函数，执行各部分初始化操作。</p><h2 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin"></a>stateMixin</h2><p>  设置data和props的setter，getter，并且在原型上定义其，同时定义$watch函数。</p><h2 id="eventsMixin"><a href="#eventsMixin" class="headerlink" title="eventsMixin"></a>eventsMixin</h2><p>  主要是在原型上定义事件的几种启动关闭方法。</p><h2 id="lifecycleMixin"><a href="#lifecycleMixin" class="headerlink" title="lifecycleMixin"></a>lifecycleMixin</h2><p>  主要是定义原型的_update，$forceUpdate，$destroy方法，其中beforeDestroy和destroyed周期函数在此触发。</p><h2 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin"></a>renderMixin</h2><p>  首先通过installRenderHelpers安装一系列渲染函数，然后定义$nextTick和_render：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179524442.png" width="1000px" height="500px"></p><h1 id="整体关系图"><a href="#整体关系图" class="headerlink" title="整体关系图"></a>整体关系图</h1><p><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179544311.png" width="1500px" height="500px"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;new Vue() 源码结构浅度解析梳理。&lt;br&gt;
    
    </summary>
    
      <category term="luoyu" scheme="http://xgfe.github.io/categories/luoyu/"/>
    
    
      <category term="vue" scheme="http://xgfe.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>RxJS 初探</title>
    <link href="http://xgfe.github.io/2019/07/13/JuntingLiu/rxjs/"/>
    <id>http://xgfe.github.io/2019/07/13/JuntingLiu/rxjs/</id>
    <published>2019-07-13T08:28:30.000Z</published>
    <updated>2020-02-19T11:04:25.645Z</updated>
    
    <content type="html"><![CDATA[<p>RxJS 最近经常被提起，但其实在工作中，我并没有怎么用到过 RxJS，只在公司内部封装的桥接库中使用过。所以 RxJS 是没多少使用场景么？到底为什么要学习 RxJS 呢？</p><a id="more"></a><h1 id="一、什么是-RxJS"><a href="#一、什么是-RxJS" class="headerlink" title="一、什么是 RxJS"></a>一、什么是 RxJS</h1><p>&emsp;&emsp;RxJS 是 Reactive Extension 这种模式的 JS 实现。它使用了一种不同于传统的编程模式—函数响应式编程。也有人称它为操作数据流的 「lodash」，旨在更方便的处理数据流。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>用函数来解决问题的一种编程范式，主要特点有：声明式、纯函数、数据不可变性。</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>响应式编程是一个编程范式，但是与其他编程范式不同的是它是基于数据流和变化传播的。比如 A = B + C, 如果我们运用一种机制，当 B 或 C 变化时，A 也同时变化，这样就实现了响应式。我们熟悉的 React、Redux 就利用了响应式。</p><h2 id="Reactive-Extension"><a href="#Reactive-Extension" class="headerlink" title="Reactive Extension"></a>Reactive Extension</h2><p>Reactive Extension，也叫ReactiveX，或者简称Rx，指的是实践响应式编程的一套工具，是一套通过可监听流来做异步编程的API。Rx的概念最初由微软公司实现并开源，也就是Rx.NET，因为Rx带来的编程方式大大改进了异步编程模型，在.NET之后，众多开发者在其他平台和语言上也实现了Rx的类库，如 RxJava、RxJS 、Rx.NET。</p><hr><h1 id="二、RxJS-中的基本概念与原理"><a href="#二、RxJS-中的基本概念与原理" class="headerlink" title="二、RxJS 中的基本概念与原理"></a>二、RxJS 中的基本概念与原理</h1><p>&emsp;&emsp;任何数据都可以被表达为数据流的形式，我们需要对数据流进行创建、订阅、过滤、转换、合并等各种操作，RxJS 便可以很好的解决这些问题。</p><p><img src="https://user-images.githubusercontent.com/14134344/62932664-28c1c180-bdf3-11e9-9f0f-64a648101070.png" width="600" height="400"></p><h2 id="在-RxJS-中用来解决异步事件管理的的基本概念是"><a href="#在-RxJS-中用来解决异步事件管理的的基本概念是" class="headerlink" title="在 RxJS 中用来解决异步事件管理的的基本概念是"></a>在 RxJS 中用来解决异步事件管理的的基本概念是</h2><ul><li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li><li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li><li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li><li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li><li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或requestAnimationFrame 或其他。</li></ul><p>以上概念大部分依据发布订阅模式去思考都是比较容易理解的。对我来说比较不太理解的是 Subject 的存在。为什么只有通过 Subject 才能实现多播，而多次对一个普通的 observable 进行 subscribe 不能实现多播？下面通过一段代码来解释这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers$ = interval(1000).pipe(take(3));</span><br><span class="line">numbers$.subscribe(value =&gt; &#123;</span><br><span class="line">  console.log(&quot;observer1: &quot; + value);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  numbers$.subscribe(value =&gt; &#123;</span><br><span class="line">    console.log(&quot;observer2: &quot; + value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></p><p>你觉得这段代码的输出结果是？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observer1: 0</span><br><span class="line">observer1: 1</span><br><span class="line">observer2: 1</span><br><span class="line">observer1: 2</span><br><span class="line">observer2: 2</span><br></pre></td></tr></table></figure></p><p>实际结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">observer1: 0</span><br><span class="line">observer1: 1</span><br><span class="line">observer2: 0</span><br><span class="line">observer1: 2</span><br><span class="line">observer2: 1</span><br><span class="line">observer2: 2</span><br></pre></td></tr></table></figure></p><p>虽然我们对 Observable 做了多次 subscribe，但是对于每个 Observer ，其实都有一个独立的数据流。而真正的多播应该是同一个数据源的。其实这种区别涉及了一个概念叫做 Cold Observable 和 hot Observable， interval 实际上产生的是一个 Cold Observable，而 Cold Observable 是无法实现真正的多播的。</p><h2 id="RxJS-的设计模式"><a href="#RxJS-的设计模式" class="headerlink" title="RxJS 的设计模式"></a>RxJS 的设计模式</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p><img src="https://user-images.githubusercontent.com/14134344/62932669-2bbcb200-bdf3-11e9-92bc-cf6c117505c9.png" width="500" height="200"></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器模式是指提供一种方法，顺序访问一个聚合对象中的各元素，而又不需要暴露该对象的内部表示。迭代器模式的实现主要处理以下三种情况：</p><ul><li>获取下一个值</li><li>无更多值</li><li>错误处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const observable$ = Observable.create(observer =&gt; &#123;</span><br><span class="line">  observer.next(1);</span><br><span class="line">  observer.next(2);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const observer = &#123;</span><br><span class="line">  next: x =&gt; console.log(&quot;Observer got a next value: &quot; + x),</span><br><span class="line">  error: err =&gt; console.error(&quot;Observer got an error: &quot; + err),</span><br><span class="line">  complete: () =&gt; console.log(&quot;Observer got a complete notification&quot;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observable$.subscribe(observer);</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// Observer got a next value: 1</span><br><span class="line">// Observer got a next value: 2</span><br><span class="line">// Observer got a complete notification</span><br></pre></td></tr></table></figure><hr><h1 id="三、RxJS-的使用示例"><a href="#三、RxJS-的使用示例" class="headerlink" title="三、RxJS 的使用示例"></a>三、RxJS 的使用示例</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class RxSearch extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      search: &quot;&quot;,</span><br><span class="line">      debounced: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.onSearch$ = new Subject();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.subscription = this.onSearch$</span><br><span class="line">      .pipe(debounceTime(300))</span><br><span class="line">      .subscribe(debounced =&gt; this.setState(&#123; debounced &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    this.subscription &amp;&amp; this.subscription.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onSearch = e =&gt; &#123;</span><br><span class="line">    const search = e.target.value;</span><br><span class="line">    this.setState(&#123; search &#125;);</span><br><span class="line">    this.onSearch$.next(search);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; search, debounced &#125; = this.state;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&#123;search&#125; onChange=&#123;this.onSearch&#125; /&gt;</span><br><span class="line">        &lt;div&gt;debounced value: &#123;debounced&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，防抖节流类有很多工具库，比如 lodash、Ramda 。但对于函数式编程的实践 lodash 是不够的，而且这些库更多的目的是工具库，而不是处理数据流，如果有更多的要求，这些库处理起来是不够优雅的。比如结果再延迟 1000 毫秒显示，结果做过滤、转换、取消失效结果、自动重试等等。</p><h2 id="快速切换筛选条件，结果竟态"><a href="#快速切换筛选条件，结果竟态" class="headerlink" title="快速切换筛选条件，结果竟态"></a>快速切换筛选条件，结果竟态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">this.onClickFilter$</span><br><span class="line">  .pipe(</span><br><span class="line">    debounceTime(300), // 加入 debounce 特性，停止输入 500ms 之后再发送请求</span><br><span class="line">    distinctUntilChanged(), //内容不变时不再继续流水线</span><br><span class="line">    // switchMap 后前面的请求会被自动 cancel 掉，天然避免竞态问题</span><br><span class="line">    switchMap(filter =&gt;</span><br><span class="line">      from(fetch(&quot;https://api.github.com/repos/ReactiveX/rxjs&quot;))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  .subscribe(data =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="批量请求异步数据流的集中管理与重试"><a href="#批量请求异步数据流的集中管理与重试" class="headerlink" title="批量请求异步数据流的集中管理与重试"></a>批量请求异步数据流的集中管理与重试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const source$ = range(1, 5);</span><br><span class="line">source$</span><br><span class="line">  .pipe(</span><br><span class="line">    mergeMap(x =&gt; &#123;</span><br><span class="line">      return fetch(`https://api.github.com/repos/ReactiveX/rxjs`).then(res =&gt; &#123;</span><br><span class="line">        if (res.status !== &quot;200&quot;) &#123;</span><br><span class="line">          throw new Error(&quot;Error!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return of(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">    retry(2),</span><br><span class="line">    catchError(err =&gt; of(err))</span><br><span class="line">  )</span><br><span class="line">  .subscribe(x =&gt; console.log(&quot;source1$:&quot;, x));</span><br></pre></td></tr></table></figure><h2 id="RxJS-结合-Redux-驱动-React"><a href="#RxJS-结合-Redux-驱动-React" class="headerlink" title="RxJS 结合 Redux 驱动 React"></a>RxJS 结合 Redux 驱动 React</h2><p>我们在工作中，大部分时候会用数据管理的库结合 UI 框架去开发，比如 Vuex + Vue，Redux + React 等，所以此处我们来实践一下 Rxjs + Redux + React 。<br>为什么不干脆用 RxJS 代替 Redux ？Redux 的社区相对更成熟，Redux 不足的是对异步的处理，周边已经有了 redux-thunk、redux-promise、redux-saga 等一系列的中间件。RxJS 也可以提供更优雅的异步处理能力，而与此对应的中间件便是redux-observable 。（<a href="https://juejin.im/entry/58db23552f301e007e9786a2" target="_blank" rel="noopener">对比参考</a>）</p><blockquote><p>Store.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;</span><br><span class="line">import &#123; createEpicMiddleware &#125; from &quot;redux-observable&quot;;</span><br><span class="line">import reducer from &quot;./Reducer&quot;;</span><br><span class="line">import epic from &quot;./Epic&quot;;</span><br><span class="line"></span><br><span class="line">const initValues = &#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;;</span><br><span class="line">const epicMiddleware = createEpicMiddleware();</span><br><span class="line">const store = createStore(reducer, initValues, applyMiddleware(epicMiddleware));</span><br><span class="line">epicMiddleware.run(epic);</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Epic.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; increment, decrement &#125; from &quot;./Actions&quot;;</span><br><span class="line">import * as ActionTypes from &quot;./ActionTypes&quot;;</span><br><span class="line">import &#123; delay, filter, map &#125; from &quot;rxjs/operators&quot;;</span><br><span class="line"></span><br><span class="line">const epic = (action$, state$) =&gt; &#123;</span><br><span class="line">  return action$.pipe(</span><br><span class="line">    filter(</span><br><span class="line">      action =&gt;</span><br><span class="line">        action.type === ActionTypes.DECREMENT ||</span><br><span class="line">        action.type === ActionTypes.INCREMENT</span><br><span class="line">    ),</span><br><span class="line">    delay(1000),</span><br><span class="line">    map(action =&gt; &#123;</span><br><span class="line">      const count = state$.value.count;</span><br><span class="line">      console.log(action$, state$);</span><br><span class="line">      if (count &gt; 0) &#123;</span><br><span class="line">        return decrement();</span><br><span class="line">      &#125; else if (count &lt; 0) &#123;</span><br><span class="line">        return increment();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &#123; type: &quot;no-op&quot; &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default epic;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Counter.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &quot;react-redux&quot;;</span><br><span class="line">import * as Actions from &quot;../../redux/Actions&quot;;</span><br><span class="line">import CounterView from &quot;./CounterView&quot;;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state, ownProps) &#123;</span><br><span class="line">  return &#123; count: state.count &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function mapDispatchToProps(dispatch, ownProps) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onIncrement: () =&gt; dispatch(Actions.increment()),</span><br><span class="line">    onDecrement: () =&gt; &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      const action = Actions.decrement();</span><br><span class="line">      return dispatch(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    reset: () =&gt; &#123;</span><br><span class="line">      dispatch(Actions.reset());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const ReduxCounter = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(CounterView);</span><br><span class="line">export default ReduxCounter;</span><br></pre></td></tr></table></figure></p></blockquote><p>Reducer.js Action.js 等和基础 Redux 使用时没有区别的，最需要关注的就是 Epic.js, 我们在 Epic 里，可以随意的使用 RxJS 提供的异步处理能力，而且可以保证真正的 Action 动作不需要写到组件逻辑中（可以对比 thunk 、promise 等方案的代码）</p><hr><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我认为学习 RxJS 的原因有两点: </p><ul><li>RxJS 为我们提供了便捷处理异步数据流的能力。比如上文所提到的节流防抖、结果竟态、重试、数据流合并、多播等问题。当然，RxJS 不仅限于解决这些问题，还有很多本文没有涉及到，比如调度器的提供使我们更便捷的调度异步数据流、多种 Subject 的变体使我们可以进行便捷的进行多样化的多播。</li><li>RxJS 的编程范式以及设计模式都是我们该去了解的知识。</li></ul><p>学习方法总结:</p><ul><li>掌握基础操作符，才能体会到 RxJS 的能力</li><li>利用弹珠图理解基础操作符</li></ul><hr><h1 id="五、学习资料"><a href="#五、学习资料" class="headerlink" title="五、学习资料"></a>五、学习资料</h1><ul><li><a href="https://cn.rx.js.org/manual/overview.html#h11" target="_blank" rel="noopener">中文文档</a></li><li><a href="https://rxjs.dev/api" target="_blank" rel="noopener">英文文档</a></li><li><a href="https://rxviz.com/examples/custom-operator" target="_blank" rel="noopener">弹珠图</a></li><li><a href="https://github.com/redux-observable/redux-observable" target="_blank" rel="noopener">redux-observable</a></li></ul><hr><p>本文部分内容参考自程墨的 《RxJS 深入浅出》，建议大家有时间亲自读一下这本书。<br>本文内容如有错误或不妥，欢迎交流指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RxJS 最近经常被提起，但其实在工作中，我并没有怎么用到过 RxJS，只在公司内部封装的桥接库中使用过。所以 RxJS 是没多少使用场景么？到底为什么要学习 RxJS 呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JuntingLiu" scheme="http://xgfe.github.io/categories/JuntingLiu/"/>
    
    
      <category term="RxJS" scheme="http://xgfe.github.io/tags/RxJS/"/>
    
      <category term="redux-observable" scheme="http://xgfe.github.io/tags/redux-observable/"/>
    
  </entry>
  
  <entry>
    <title>Android 着色器 tint</title>
    <link href="http://xgfe.github.io/2019/07/04/chenluan/tint/"/>
    <id>http://xgfe.github.io/2019/07/04/chenluan/tint/</id>
    <published>2019-07-04T05:08:30.000Z</published>
    <updated>2020-02-19T11:04:25.646Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了 Android 着色器的使用及其原理，在实现同等效果的情况下，减少资源图的使用以减小 apk 包的体积并降低对内存的占用。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>假设我们想实现一种效果，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/target.png" alt=""></p><p>不怎么友好的做法是让设计师给五张资源图，然后依次排列五个对应的 ImageView。这种做法是存在一些问题的，apk 包体积增加了五张图的大小；程序运行时内存增加了五张图的大小。</p><p>这时，我们就可以考虑使用着色器来简单快捷高效地实现这个效果了。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>在 drawable 中导入一张资源图，导入的这张图本身的颜色不用太在意，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/icon.png" alt=""></p><p>在布局中配置 ImageView，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中关键点即是 <strong>android:tint</strong>，这里配置多个 ImageView，<strong>tint</strong> 配置不同的颜色值，就达到了我们的目的，而且没有前述的弊端。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="Paint-amp-ColorFilter"><a href="#Paint-amp-ColorFilter" class="headerlink" title="Paint &amp; ColorFilter"></a>Paint &amp; ColorFilter</h2><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/ColorFilter" target="_blank" rel="noopener">ColorFilter</a><br>颜色过滤器，通过 Paint.setColorFilter 修改渲染某个像素时的颜色值，ColorFilter 有如下一些子类，后续着重介绍一下 PorterDuffColorFilter。</p><h3 id="BlendModeColorFilter"><a href="#BlendModeColorFilter" class="headerlink" title="BlendModeColorFilter"></a>BlendModeColorFilter</h3><p>混合模式，在 API Level 29 中添加的，类似于 Android 原生的 PorterDuffXferMode，在 Flutter、CSS中都有一些体现。</p><h3 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h3><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/ColorMatrix.html" target="_blank" rel="noopener">ColorMatrix</a><br>通过一个 4x5 的矩阵与颜色 [R, G, B, A] 进行矩阵乘积，得到目标颜色值，可以调整亮度、饱和度、色调等来实现类似 PS 中的滤镜效果，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/color_matrix.png" alt=""></p><h3 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h3><p>通过颜色的相乘与相加，模拟简单的光照效果。</p><h3 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h3><p>使用一个颜色和 PorterDuff 模式对目标进行染色。</p><h4 id="PorterDuff-Mode"><a href="#PorterDuff-Mode" class="headerlink" title="PorterDuff.Mode"></a>PorterDuff.Mode</h4><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html" target="_blank" rel="noopener">PorterDuff.Mode</a><br>假设存在两个形状 SRC 和 DST，其中带颜色的区域的像素点 alpha = 1; color = [red|blue]，其它区域像素点 alpha = 0; color = 0，则它们叠加相交得到 ABCD 4个区，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/composite.png" alt=""></p><p>通过对 SRC 和 DST 图中的像素值 ARGB 进行数学运算，得到一些裁剪混合叠加效果，展示其中三个如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/effect.png" alt=""></p><p>其中每种模式都有对应的数学公式进行运算，例如 SRC_ATOP 的计算方式，如下：<br>alpha_out = alpha_dst<br>color_out = alpha_dst * color_src + (1 - alpha_src) * color_dst</p><p>对于 AD 区，alpha 的运算结果采用了 DST 的 alpha = 0，所以 AD 区是可不见的，BC 区是可见的，最终结果在形状上表现为 DST 的样子，所以 AD 区的颜色也就没有必要计算了。</p><p>对于 B 区的颜色，如下：<br>color_out = 1 * 0 + (1 - 0) * red = red</p><p>对于 C 区的颜色，如下：<br>color_out = 1 * blue + (1 - 1) * red = blue</p><p>最终分析结果与前述图片表现一致。其它种类模式的公式可以参考 Android Developer。</p><h2 id="BitmapDrawable-setTintList"><a href="#BitmapDrawable-setTintList" class="headerlink" title="BitmapDrawable.setTintList"></a>BitmapDrawable.setTintList</h2><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html" target="_blank" rel="noopener">BitmapDrawable</a></p><p>这个方法是在 API Level 21 中添加的，将一个颜色 ColorStateList 设置给 mTintFilter 变量，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PorterDuffColorFilter mTintFilter;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(ColorStateList tint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapState state = mBitmapState;</span><br><span class="line">    <span class="keyword">if</span> (state.mTint != tint) &#123;</span><br><span class="line">        state.mTint = tint;</span><br><span class="line">        mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);</span><br><span class="line">        invalidateSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在渲染的时候，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clearColorFilter;</span><br><span class="line">    <span class="keyword">if</span> (mTintFilter != <span class="keyword">null</span> &amp;&amp; paint.getColorFilter() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paint.setColorFilter(mTintFilter);</span><br><span class="line">        clearColorFilter = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearColorFilter = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将这个 PorterDuffColorFilter 交给了 Paint 进行处理。</p><h2 id="ImageView-tint"><a href="#ImageView-tint" class="headerlink" title="ImageView_tint"></a>ImageView_tint</h2><p>ImageView 在使用 tint 属性的时候，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyImageTint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span> &amp;&amp; (mHasDrawableTint || mHasDrawableTintMode)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mHasDrawableTint) &#123;</span><br><span class="line">            mDrawable.setTintList(mDrawableTintList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHasDrawableTintMode) &#123;</span><br><span class="line">            mDrawable.setTintMode(mDrawableTintMode);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们从 ImageView 的 tint 属性到 Paint 的使用，过程如下：</p><ul><li>ImageView 读取到 tint 属性之后，将 tint color 和 tint mode 设置给 Drawable</li><li>Drawable 将 tint color 和 tint mode 组装成 PorterDuffColorFilter</li><li>Drawable 在渲染的时候，将 PorterDuffColorFilter 设置给 Paint</li><li>Paint 将效果应用到画布上</li></ul><h2 id="ImageView-tintMode"><a href="#ImageView-tintMode" class="headerlink" title="ImageView_tintMode"></a>ImageView_tintMode</h2><p>ImageView 在使用 tint 属性的时候，也可以配置 tintMode 属性，如下：</p><ul><li>add</li><li>multiply</li><li>screen</li><li>src_atop</li><li>src_in</li><li>src_over</li></ul><p>Drawable 的默认 tint mode 是 SRC_IN，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> PorterDuff.Mode DEFAULT_TINT_MODE = PorterDuff.Mode.SRC_IN;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ImageView 的默认 tint mode 是 SRC_ATOP，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tint)) &#123;</span><br><span class="line">    mDrawableTintList = a.getColorStateList(R.styleable.ImageView_tint);</span><br><span class="line">    mHasDrawableTint = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prior to L, this attribute would always set a color filter with</span></span><br><span class="line">    <span class="comment">// blending mode SRC_ATOP. Preserve that default behavior.</span></span><br><span class="line">    mDrawableTintMode = PorterDuff.Mode.SRC_ATOP;</span><br><span class="line">    mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 PorterDuff 对应的 SRC 默认是一个铺满 DST 宽高的颜色值，所以 SRC_IN 和 SRC_ATOP 效果上是一样的。<br>布局 xml 中只提供了6中模式，若想使用其它 PorterDuff 模式也可以，需要用 Java 代码去实现。</p><h1 id="使用进阶"><a href="#使用进阶" class="headerlink" title="使用进阶"></a>使用进阶</h1><h2 id="Drawable-setTintList"><a href="#Drawable-setTintList" class="headerlink" title="Drawable.setTintList"></a>Drawable.setTintList</h2><p>tint 不仅仅只是 BitmapDrawable 可以使用，setTintList 在 API Level 21 中被添加到 Drawable 中，所以 Drawable 子类都可以使用，如下：</p><ul><li>BitmapDrawable</li><li>NinePatchDrawable</li><li>LayerDrawable</li><li>StateListDrawable</li><li>LevelListDrawable</li><li>TransitionDrawable</li><li>InsetDrawable</li><li>ClipDrawable</li><li>ScaleDrawable</li><li>ShapeDrawable</li><li>GradientDrawable</li><li>AnimationDrawable</li><li>VectorDrawable</li></ul><p>其中有一些 Drawable 可以在布局 xml 中配置 tint，如下：</p><p>BitmapDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bitmap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>NinePatchDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nine-patch</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nine-patch</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>ShapeDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>VectorDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="ColorStateList"><a href="#ColorStateList" class="headerlink" title="ColorStateList"></a>ColorStateList</h2><p>我们可以在 xml 中配置一个 ColorStateList，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"#FF0000"</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"#00FF00"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后将这个 ColorStateList 设置给 ImageView，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"@color/state_color"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样当这个 ImageView 被点击的时候，颜色就可以被改变。</p><p>当然还有一种方式可以实现这种效果，使用 xml 配置两个 bitmap，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bitmap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后配置一个 selector，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon_pressed"</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon_normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>随后将这个 selector 设置给 ImageView。这种方式占用了更多的内存，因为 BitmapDrawable 在 inflate 的时候直接从输入流读取文件的，没有进行图片重用，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapDrawable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.inflate(r, parser, attrs, theme);</span><br><span class="line">        ...</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = r.openRawResource(srcResId, value)) &#123;</span><br><span class="line">            bitmap = BitmapFactory.decodeResourceStream(r, value, is, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing and pick up the error below.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>基于前述几种使用方式，我们就可以将 LevelListDrawable、LayerDrawable、StateListDrawable、BitmapDrawable 组合在一起，这就可以有无限的组合方式了。</p><h2 id="在-View-中配置-tint"><a href="#在-View-中配置-tint" class="headerlink" title="在 View 中配置 tint"></a>在 View 中配置 tint</h2><p>除了前述 ImageView 中可以配置 tint 外，View 也可以对前景和背景配置 tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:backgroundTint</span>=<span class="string">"#FF0000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:foregroundTint</span>=<span class="string">"#00FF00"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>TextView 也可以配置 drawable tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawableTint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>CompoundButton 也可以配置 button tint，所以 CheckBox、RadioButton 等也可以配置 button tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawableTint</span>=<span class="string">"#FF0000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:buttonTint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Compatible"><a href="#Compatible" class="headerlink" title="Compatible"></a>Compatible</h2><h3 id="ViewCompat"><a href="#ViewCompat" class="headerlink" title="ViewCompat"></a>ViewCompat</h3><p>由于 API Level 21 才开始支持 background tint 在 xml 中配置，可以使用 ViewCompat.setBackgroundTintList 和 ViewCompat.setBackgroundTintMode 进行兼容。</p><p>如果我们想在自定义 View 中也实现 tint 的一些特性，可以让自定义 View 实现 TintableBackgroundView 接口，然后调用 ViewCompat.setBackgroundTintList 进行设置，这样就能对 API Level 21 之前的版本进行兼容。</p><p>ViewCompat 的相关实现，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewCompatBaseImpl IMPL;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatApi26Impl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatApi24Impl();</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatBaseImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">    IMPL.setBackgroundTintList(view, tintList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCompatApi21Impl</span> <span class="keyword">extends</span> <span class="title">ViewCompatApi19Impl</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">        view.setBackgroundTintList(tintList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT == <span class="number">21</span>) &#123;</span><br><span class="line">            <span class="comment">// Work around a bug in L that did not update the state of the background</span></span><br><span class="line">            <span class="comment">// after applying the tint</span></span><br><span class="line">            Drawable background = view.getBackground();</span><br><span class="line">            <span class="keyword">boolean</span> hasTint = (view.getBackgroundTintList() != <span class="keyword">null</span>)</span><br><span class="line">                    &amp;&amp; (view.getBackgroundTintMode() != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((background != <span class="keyword">null</span>) &amp;&amp; hasTint) &#123;</span><br><span class="line">                <span class="keyword">if</span> (background.isStateful()) &#123;</span><br><span class="line">                    background.setState(view.getDrawableState());</span><br><span class="line">                &#125;</span><br><span class="line">                view.setBackground(background);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCompatBaseImpl</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> TintableBackgroundView) &#123;</span><br><span class="line">            ((TintableBackgroundView) view).setSupportBackgroundTintList(tintList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DrawableCompat"><a href="#DrawableCompat" class="headerlink" title="DrawableCompat"></a>DrawableCompat</h3><p>由于 API Level 21 才开始支持对 drawable 设置 tint，可以使用 DrawableCompat.setTintList，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(@NonNull Drawable drawable, @Nullable ColorStateList tint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        drawable.setTintList(tint);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> TintAwareDrawable) &#123;</span><br><span class="line">        ((TintAwareDrawable)drawable).setTintList(tint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用 DrawableCompat.wrap 对 drawable 进行包装兼容，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">wrap</span><span class="params">(@NonNull Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi21(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi19(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi14(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>多图并列显示，用颜色来区分类别，图的形状是一样的</li><li>简单的按钮普通、按下、置灰等状态切换</li><li>换肤换主题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了 Android 着色器的使用及其原理，在实现同等效果的情况下，减少资源图的使用以减小 apk 包的体积并降低对内存的占用。&lt;/p&gt;
    
    </summary>
    
      <category term="chenluan" scheme="http://xgfe.github.io/categories/chenluan/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="tint" scheme="http://xgfe.github.io/tags/tint/"/>
    
  </entry>
  
  <entry>
    <title>非原生 ROM 的 Crash 问题通用排查方法</title>
    <link href="http://xgfe.github.io/2019/06/17/leidiqiu/resolve-non-google-rom-crash/"/>
    <id>http://xgfe.github.io/2019/06/17/leidiqiu/resolve-non-google-rom-crash/</id>
    <published>2019-06-17T08:28:30.000Z</published>
    <updated>2020-02-19T11:04:25.647Z</updated>
    
    <content type="html"><![CDATA[<p>日常 Crash 治理过程中，经常会遇到一些比较难排查的问题，比如，Crash 堆栈信息中出现了一些本不应该出现的函数，这些函数其实是手机厂商修改了 Google 的原生 ROM，自己添加进去的。本文介绍了一种定位和排查非原生 ROM 的 Crash 问题的通用方法。</p><a id="more"></a><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>日常清理 Crash 时，遇到一些空指针异常的问题，每天不多，但是日积月累，数量并不少，堆栈信息如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">'java.lang.Class java.lang.Object.getClass()'</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">at android.os.Message.toStringLite(Message.java:<span class="number">507</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">221</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">5809</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">372</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="number">1113</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">879</span>)</span><br></pre></td></tr></table></figure></p><p>翻看 android.os.Message 的源代码，并没有 toStringLite() 这个函数，显然，这是手机厂商修改了原生 ROM，自己加上的。如何跟进此类适配性问题呢？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>此类 ROM 相关问题无法修复，只能从 App 的代码调用端进行适配，类似 H5 页面适配各种浏览器一样。所以，主要问题在于找出非原生 ROM 的执行逻辑，从而想办法避免 Crash。那么，如何发掘里面的执行逻辑呢？</p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>初步考虑，通过 ClassLoader 动态导出具体的 class 类，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            InputStream inputStream = classLoader.getResourceAsStream(<span class="string">"java/util/List.class"</span>);</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"List.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                fileOutputStream.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法对 Java 是适用的，但是在 Android 中并不适用。</p><h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>既然动态方法不行，考虑静态方法，毕竟在手机 ROM 中，必然有对应的文件。</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>首先，通过 Crash 平台的附加信息，找到手机的型号、版本「型号：OPPO R9tm，版本：5.1」，找一台同型号、同版本的手机「美团有云真机平台，上面的手机种类繁多」，连上 adb。</p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>把 boot.oat 文件从手机 pull 下来，boot.oat 包含启动相关的代码，可理解为里面有优化过的 framework.jar 文件，对应 SDK 的 android.jar 文件，文件较大，有 85M 左右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ adb -s 172.18.92.198:44429 pull /system/framework/arm64/boot.oat .</span><br><span class="line">/system/framework/arm64/boot.oat: 1 file pulled. 0.4 MB/s (85477748 bytes <span class="keyword">in</span> 229.612s)</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ ls -l boot.oat </span><br><span class="line">-rw-r--r--  1 leidiqiu  staff  85477748 May  8 16:17 boot.oat</span><br></pre></td></tr></table></figure></p><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>下载 <a href="https://github.com/testwhat/SmaliEx/releases/download/0.86/oat2dex.jar" target="_blank" rel="noopener">oat2dex.jar</a> 工具，并将 oat 文件转换成 dex 文件，会生成 odex、dex 两个文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ java -jar ~/libs/oat2dex.jar boot boot.oat </span><br><span class="line">05-08 16:23:27:465 Output raw dex: /Users/leidiqiu/Desktop/odex/core-libart.dex</span><br><span class="line">05-08 16:23:27:466 Output raw dex: /Users/leidiqiu/Desktop/odex/conscrypt.dex</span><br><span class="line">05-08 16:23:27:467 Output raw dex: /Users/leidiqiu/Desktop/odex/okhttp.dex</span><br><span class="line">05-08 16:23:27:467 Output raw dex: /Users/leidiqiu/Desktop/odex/core-junit.dex</span><br><span class="line">05-08 16:23:27:469 Output raw dex: /Users/leidiqiu/Desktop/odex/bouncycastle.dex</span><br><span class="line">05-08 16:23:27:472 Output raw dex: /Users/leidiqiu/Desktop/odex/ext.dex</span><br><span class="line">05-08 16:23:27:488 Output raw dex: /Users/leidiqiu/Desktop/odex/framework.dex</span><br><span class="line">05-08 16:23:27:503 Output raw dex: /Users/leidiqiu/Desktop/odex/framework-classes2.dex</span><br><span class="line">05-08 16:23:27:511 Output raw dex: /Users/leidiqiu/Desktop/odex/telephony-common.dex</span><br><span class="line">05-08 16:23:27:512 Output raw dex: /Users/leidiqiu/Desktop/odex/voip-common.dex</span><br><span class="line">05-08 16:23:27:516 Output raw dex: /Users/leidiqiu/Desktop/odex/ims-common.dex</span><br><span class="line">05-08 16:23:27:516 Output raw dex: /Users/leidiqiu/Desktop/odex/mms-common.dex</span><br><span class="line">05-08 16:23:27:517 Output raw dex: /Users/leidiqiu/Desktop/odex/android.policy.dex</span><br><span class="line">05-08 16:23:27:523 Output raw dex: /Users/leidiqiu/Desktop/odex/apache-xml.dex</span><br><span class="line">05-08 16:23:27:529 Output raw dex: /Users/leidiqiu/Desktop/odex/oppo-framework.dex</span><br><span class="line">05-08 16:23:27:530 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-common.dex</span><br><span class="line">05-08 16:23:27:531 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-framework.dex</span><br><span class="line">05-08 16:23:27:532 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-telephony-common.dex</span><br><span class="line">05-08 16:23:27:786 De-optimizing /system/framework/core-libart.jar</span><br><span class="line">05-08 16:23:30:094 Output to /Users/leidiqiu/Desktop/dex/core-libart.dex</span><br><span class="line">05-08 16:23:30:094 De-optimizing /system/framework/conscrypt.jar</span><br><span class="line">05-08 16:23:30:208 Output to /Users/leidiqiu/Desktop/dex/conscrypt.dex</span><br><span class="line">05-08 16:23:30:208 De-optimizing /system/framework/okhttp.jar</span><br><span class="line">05-08 16:23:30:356 Output to /Users/leidiqiu/Desktop/dex/okhttp.dex</span><br><span class="line">05-08 16:23:30:356 De-optimizing /system/framework/core-junit.jar</span><br><span class="line">05-08 16:23:30:371 Output to /Users/leidiqiu/Desktop/dex/core-junit.dex</span><br><span class="line">05-08 16:23:30:371 De-optimizing /system/framework/bouncycastle.jar</span><br><span class="line">05-08 16:23:30:928 Output to /Users/leidiqiu/Desktop/dex/bouncycastle.dex</span><br><span class="line">05-08 16:23:30:928 De-optimizing /system/framework/ext.jar</span><br><span class="line">05-08 16:23:31:483 Output to /Users/leidiqiu/Desktop/dex/ext.dex</span><br><span class="line">05-08 16:23:31:483 De-optimizing /system/framework/framework.jar</span><br><span class="line">05-08 16:23:36:301 Output to /Users/leidiqiu/Desktop/dex/framework.dex</span><br><span class="line">05-08 16:23:36:301 De-optimizing /system/framework/framework.jar:classes2.dex</span><br><span class="line">05-08 16:23:38:611 Output to /Users/leidiqiu/Desktop/dex/framework-classes2.dex</span><br><span class="line">05-08 16:23:38:611 De-optimizing /system/framework/telephony-common.jar</span><br><span class="line">05-08 16:23:40:395 Output to /Users/leidiqiu/Desktop/dex/telephony-common.dex</span><br><span class="line">05-08 16:23:40:395 De-optimizing /system/framework/voip-common.jar</span><br><span class="line">05-08 16:23:40:440 Output to /Users/leidiqiu/Desktop/dex/voip-common.dex</span><br><span class="line">05-08 16:23:40:440 De-optimizing /system/framework/ims-common.jar</span><br><span class="line">05-08 16:23:40:625 Output to /Users/leidiqiu/Desktop/dex/ims-common.dex</span><br><span class="line">05-08 16:23:40:625 De-optimizing /system/framework/mms-common.jar</span><br><span class="line">05-08 16:23:40:626 Output to /Users/leidiqiu/Desktop/dex/mms-common.dex</span><br><span class="line">05-08 16:23:40:626 De-optimizing /system/framework/android.policy.jar</span><br><span class="line">05-08 16:23:40:764 Output to /Users/leidiqiu/Desktop/dex/android.policy.dex</span><br><span class="line">05-08 16:23:40:764 De-optimizing /system/framework/apache-xml.jar</span><br><span class="line">05-08 16:23:41:178 Output to /Users/leidiqiu/Desktop/dex/apache-xml.dex</span><br><span class="line">05-08 16:23:41:178 De-optimizing /system/framework/oppo-framework.jar</span><br><span class="line">05-08 16:23:41:613 Output to /Users/leidiqiu/Desktop/dex/oppo-framework.dex</span><br><span class="line">05-08 16:23:41:613 De-optimizing /system/framework/mediatek-common.jar</span><br><span class="line">05-08 16:23:41:660 Output to /Users/leidiqiu/Desktop/dex/mediatek-common.dex</span><br><span class="line">05-08 16:23:41:660 De-optimizing /system/framework/mediatek-framework.jar</span><br><span class="line">05-08 16:23:41:889 Output to /Users/leidiqiu/Desktop/dex/mediatek-framework.dex</span><br><span class="line">05-08 16:23:41:889 De-optimizing /system/framework/mediatek-telephony-common.jar</span><br><span class="line">05-08 16:23:41:891 Output to /Users/leidiqiu/Desktop/dex/mediatek-telephony-common.dex</span><br></pre></td></tr></table></figure></p><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>查看 dex 文件夹，发现有 framework.dex 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ <span class="built_in">cd</span> dex/</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ ls</span><br><span class="line">android.policy.dex            ext.dex                       mediatek-telephony-common.dex</span><br><span class="line">apache-xml.dex                framework-classes2.dex        mms-common.dex</span><br><span class="line">bouncycastle.dex              framework.dex                 okhttp.dex</span><br><span class="line">conscrypt.dex                 ims-common.dex                oppo-framework.dex</span><br><span class="line">core-junit.dex                mediatek-common.dex           telephony-common.dex</span><br><span class="line">core-libart.dex               mediatek-framework.dex        voip-common.dex</span><br></pre></td></tr></table></figure></p><h3 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h3><p>下载 <a href="https://sourceforge.net/projects/dex2jar/files/dex2jar-2.0.zip/download" target="_blank" rel="noopener">dex2jar-2.0.zip</a> 工具，将 dex 转成 jar，并用 JD-GUI 打开，JD-GUI 下载地址：<a href="http://java-decompiler.github.io/。" target="_blank" rel="noopener">http://java-decompiler.github.io/。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ dex2jar.sh framework.dex </span><br><span class="line">dex2jar framework.dex -&gt; ./framework-dex2jar.jar</span><br><span class="line">Detail Error Information <span class="keyword">in</span> File ./framework-error.zip</span><br><span class="line">Please report this file to http://code.google.com/p/dex2jar/issues/entry <span class="keyword">if</span> possible.</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ open framework-dex2jar.jar -a JD-GUI.app</span><br></pre></td></tr></table></figure></p><h3 id="步骤六"><a href="#步骤六" class="headerlink" title="步骤六"></a>步骤六</h3><p>通过 JD-GUI 查看，终于找到了 Message 类，里面确实有 toStringLite() 方法。<br><img src="http://s3plus.sankuai.com/v1/mss_7fabbc64efb346df9722fadcafbc20bc/blog/Message.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此类方法相对通用，对定位非原生 ROM 的问题很有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常 Crash 治理过程中，经常会遇到一些比较难排查的问题，比如，Crash 堆栈信息中出现了一些本不应该出现的函数，这些函数其实是手机厂商修改了 Google 的原生 ROM，自己添加进去的。本文介绍了一种定位和排查非原生 ROM 的 Crash 问题的通用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="leidiqiu" scheme="http://xgfe.github.io/categories/leidiqiu/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Crash" scheme="http://xgfe.github.io/tags/Crash/"/>
    
      <category term="非原生ROM" scheme="http://xgfe.github.io/tags/%E9%9D%9E%E5%8E%9F%E7%94%9FROM/"/>
    
  </entry>
  
  <entry>
    <title>类Redux的数据中间层的实现</title>
    <link href="http://xgfe.github.io/2019/05/26/yangziyao/%E7%B1%BBRedux%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E9%97%B4%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2019/05/26/yangziyao/类Redux的数据中间层实现/</id>
    <published>2019-05-26T02:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.665Z</updated>
    
    <content type="html"><![CDATA[<p>关于全局单向数据流+视图层computed属性的一个简单实现。</p><a id="more"></a><h1 id="数据中间层简介"><a href="#数据中间层简介" class="headerlink" title="数据中间层简介"></a>数据中间层简介</h1><p>在上家公司工作时，由于使用自研框架比较陈旧，不支持全局的跨视图的数据复用。又由于当时react的BSD+Patents证书事件，团队决定放弃引入开源……于是就自己造了一个支持单向数据流的轮子，就是本文介绍的数据中间层。在视图数据层面，也实现了类似vue的computed属性来优化开发体验。</p><h1 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h1><p><img src="https://github.com/zero-yang/assets/blob/master/data-midware.png?raw=true" alt=""></p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store模块负责存储全局数据和定义操作数据的actions。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel模块负责维护视图自身的数据，接收来自Store的change事件以响应Store数据变更，通过dispatch action操作Store中的数据。</p><h2 id="Updater"><a href="#Updater" class="headerlink" title="Updater"></a>Updater</h2><p>Updater模块定义了数据的操作，包括set，get，assign等，可以通过指定数据源对Store或者ViewModel的实例进行操作。同时也定义了dispatch操作。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>由于这是一年半前写的代码，还有种种原因不方便透露源码，这里只介绍主要的实现思路，具体实现还需要考虑很多边界场景，这里就不细说了。</p><h2 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h2><p>Store的代码实现很简单，主要包含存储数据的对象，定义action对象的数组，以及注册action的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Store = &#123;</span><br><span class="line">    state: &#123;&#125;, </span><br><span class="line">    actions: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'setFormData'</span>,</span><br><span class="line">            <span class="keyword">async</span> method() &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    addAction(actionList) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actions.concat(actionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，action对象中的name类似于redux中的常量，method类似于reducer，可以是异步方法。不同业务模块的action可以维护在独立的模块中，通过Store.addAction注册到Store中。</p><h2 id="Updater-1"><a href="#Updater-1" class="headerlink" title="Updater"></a>Updater</h2><p>Updater负责数据的操作和不同数据实体间的交互，是三个模块中最核心的模块。包含了数据操作的set，get和assign，处理action的dispatch。还有一个buildFactory方法，是为了保证在执行action的过程中对Store数据操作的原子性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Updater = &#123;</span><br><span class="line">    find(source = &#123;&#125;, path, create) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    assign(source, path, value) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(source, path, value) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    get(source, path) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> dispatch(source, action) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    buildFactory(source) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来详细介绍这几个方法。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>对指定数据源和路径进行查找，返回对应字段的父级和对应字段的key，可指定路径中的属性不存在是否创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">find(source = &#123;&#125;, path, create) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = path.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tmp.length - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = source[tmp[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!next &amp;&amp; create) &#123;</span><br><span class="line">            source[tmp[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source = next || &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        key: tmp[tmp.length - <span class="number">1</span>],</span><br><span class="line">        source</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>设置指定数据源对应路径的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(source, path, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> setObj = <span class="keyword">this</span>.find(source, path, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    setObj.source[setObj.key] = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>跟set类似，只不过是将赋值变成对象合并。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取指定数据源对应路径的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get(source, path) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.find(source, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.source[result.key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>执行action，在执行完成后触发storeChange事件。为了保证action对Store写操作的原子性，在执行action过程中，将所有写操作先以指令的形式储存在通过buildFactory方法创建的一个factory里，再一次性进行写入操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> dispatch(source, action) &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = <span class="keyword">this</span>.buildFactory(source);</span><br><span class="line">    <span class="keyword">const</span> handler = Store.actions[action];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> handler(factory.get, factory.set, factory.assign);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> diff = factory.applyDirective();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (diff.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Event.emit(<span class="string">'storeChange'</span>, &#123;</span><br><span class="line">            diff</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="buildFactory"><a href="#buildFactory" class="headerlink" title="buildFactory"></a>buildFactory</h3><p>创建指令工厂对象，提供所有Store写操作的mock方法，mock方法将所有操作以指令形式保存在fatory里，通过applyDirective方法一次执行，并返回操作的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildFactory(source) &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = &#123;</span><br><span class="line">        directives: [],</span><br><span class="line">        source</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="string">'set'</span>, <span class="string">'assign'</span>].reduce(<span class="function">(<span class="params">fac, key</span>) =&gt;</span> &#123;</span><br><span class="line">        fac[key] = <span class="function">(<span class="params">path, value</span>) =&gt;</span> &#123;</span><br><span class="line">            fac.directives.push(&#123;</span><br><span class="line">                type: key,</span><br><span class="line">                path,</span><br><span class="line">                value</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, factory);</span><br><span class="line"></span><br><span class="line">    factory.get = <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get(factory.source, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    factory.applyDirective = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> diff = [];</span><br><span class="line"></span><br><span class="line">        factory.directives.forEach(<span class="function"><span class="params">directive</span> =&gt;</span> &#123;</span><br><span class="line">           diff = diff.concat(<span class="keyword">this</span>[directive[key]](factory.source, directive[path], directive[value]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewModel-1"><a href="#ViewModel-1" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel负责维护视图的数据，提供了类似vue的computed属性，并通过computed属性维护ViewModel实例到Store的数据依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    calDiff(diffFromStore) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    initComputed() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(path, value) &#123;</span><br><span class="line">    Updater.set(<span class="keyword">this</span>.state, path, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get(path) &#123;</span><br><span class="line">    Updater.get(<span class="keyword">this</span>.state, path);</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>监听storeChange事件，根据diff计算自身的数据变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    Event.on(<span class="string">'storeChange'</span>, diff =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'change'</span>, <span class="keyword">this</span>.calDiff(diff));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><p>初始化computed属性，建立computed属性对自身数据字段以及Store数据字段的依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">initComputed() &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.computed).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.computed[key](</span><br><span class="line">            path =&gt; &#123;</span><br><span class="line">                <span class="comment">//从自身state里获取数据方法</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.__bindWithState__[path]) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.__bindWithState__[path] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.__bindWithState__[path].push(key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Updater.get(<span class="keyword">this</span>.state, path);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            path =&gt; &#123;</span><br><span class="line">                <span class="comment">//从全局store里获取数据方法</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.__bindWithStore__[path]) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.__bindWithStore__[path] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.__bindWithStore__[path].push(key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Updater.get(store, path);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="calDiff"><a href="#calDiff" class="headerlink" title="calDiff"></a>calDiff</h3><p>根据Store数据的diff计算自身数据的变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">calDiff(diffFromStore) &#123;</span><br><span class="line">    <span class="keyword">let</span> stateDiff = [];</span><br><span class="line"></span><br><span class="line">    diffFromStore.forEach(<span class="function"><span class="params">diffPath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.__bindWithStore__[diffPath]) &#123;</span><br><span class="line">            stateDiff = stateDiff.concat(<span class="keyword">this</span>.__bindWithStore__[diffPath]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> diffDueToState = [];</span><br><span class="line"></span><br><span class="line">    stateDiff.forEach(<span class="function"><span class="params">diffPath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.__bindWithState__[diffPath]) &#123;</span><br><span class="line">            diffDueToState = diffDueToState.concat(<span class="keyword">this</span>.__bindWithState__[diffPath]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(stateDiff.concat(diffDueToState)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环依赖检测"><a href="#环依赖检测" class="headerlink" title="环依赖检测"></a>环依赖检测</h3><p>为了避免在computed属性里遇到环依赖的情况，因此需要一个环依赖检测的方法。depTree为ViewModel实例里的<strong>bindWithStore</strong>或者<strong>bindWithState</strong>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleDetection</span>(<span class="params">depTree</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="built_in">Object</span>.keys(depTree);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doDetection</span>(<span class="params">node, parentSet</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> deps = depTree[node];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!deps || deps.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">const</span> depNode = deps[i];</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (parentSet.has(depNode)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doDetection(depNode, parentSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; root.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> pSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> rNode = root[i];</span><br><span class="line"></span><br><span class="line">        pSet.add(rNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!doDetection(rNode, pSet)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>注册业务相关的action：/entity/bidword.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'common/store'</span>;</span><br><span class="line"></span><br><span class="line">Store.addAction([&#123;</span><br><span class="line">name: <span class="string">'fetchBidword'</span>,</span><br><span class="line"><span class="keyword">async</span> method(get, set, assign) &#123;</span><br><span class="line"><span class="keyword">let</span> list;</span><br><span class="line"><span class="comment">// fetch list</span></span><br><span class="line"></span><br><span class="line">set(<span class="string">'bidword/list'</span>, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">'addBidword'</span>,</span><br><span class="line"><span class="keyword">async</span> method() &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>视图viewModel：/bidword/bidword-vm.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ViewModel <span class="keyword">from</span> <span class="string">'common/view-model'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BidwordVM</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">computed = &#123;</span><br><span class="line">displayList(get, getFromStore) &#123;</span><br><span class="line"><span class="keyword">const</span> list = getFromStore(<span class="string">'bidword/list'</span>);</span><br><span class="line"><span class="keyword">const</span> date = get(<span class="string">'theDate'</span>);</span><br><span class="line"></span><br><span class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">item.date = date;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> init() &#123;</span><br><span class="line"><span class="keyword">this</span>.set(<span class="string">'date'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toDateString());</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.dispatch(<span class="string">'fetchBidword'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结束，页面开始渲染</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图文件view：/bidword/bidword.js</p><p>通过一个connect组件绑定视图和viewModel，connect负责维护view和viewModel实例的生命周期，具体细节这里就不赘述了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> connect <span class="keyword">from</span> <span class="string">'common/connect'</span>;</span><br><span class="line"><span class="keyword">import</span> BidwordVM <span class="keyword">from</span> <span class="string">'./bidword-vm'</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'common/base-view'</span>;</span><br><span class="line"></span><br><span class="line">@connect(BidwordVM)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bidword</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Bidword;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是数据中间层实现的一个大致的思路，希望能对大家有帮助，有问题欢迎指正~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于全局单向数据流+视图层computed属性的一个简单实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangziyao" scheme="http://xgfe.github.io/categories/yangziyao/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="redux" scheme="http://xgfe.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务</title>
    <link href="http://xgfe.github.io/2019/04/16/zhangpeng/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://xgfe.github.io/2019/04/16/zhangpeng/宏任务和微任务/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-16T08:45:15.191Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。</p><a id="more"></a><h2 id="一、宏任务和微任务"><a href="#一、宏任务和微任务" class="headerlink" title="一、宏任务和微任务"></a>一、宏任务和微任务</h2><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1.宏任务"></a>1.宏任务</h3><p>事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。<br>宏任务：</p><ul><li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li><li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li><li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收。</li></ul><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2.微任务"></a>2.微任务</h3><p>微任务：</p><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><h3 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h3><p>ECMA的规范没有提及到事件循环，但在HTML规范里却有提及<br>（1）里面也讨论了宏任务和微任务的概念<br>（2）ECMA规范提及到了Promise<br>（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用<br> 事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。</p><p> 事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。<br> 从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。</p><p> 当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。<br> 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。<br> 因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。</p><p> 所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。<br> 浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。<br> 现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">在另一个16ms结束前，事件循环执行到&quot;是否需要渲染&quot;的决策的环节。因为更新UI是一个复杂的操作，</span><br><span class="line">如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作</span><br><span class="line">在最后的一个渲染操作完成后大约16ms，事件循环执行到&quot;是否需要进行渲染&quot;的决策环节，</span><br><span class="line">在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。</span><br><span class="line">在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，</span><br><span class="line">且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，</span><br><span class="line">反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，</span><br><span class="line">用户可能会觉得网页挂掉了。</span><br><span class="line">在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，</span><br><span class="line">可能会导致网页的性能低下。  </span><br><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">主线程javascript代码执行时间需要15ms</span><br><span class="line">第一个单击事件处理器需要运行8ms</span><br><span class="line">第二个单击事件处理器需要运行5ms</span><br><span class="line">让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，</span><br><span class="line">我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms，</span><br><span class="line">第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript</span><br><span class="line">代码开始，立刻从DOM获取firstButton和secondButton元素，</span><br><span class="line">并注册firstHandle和secondHandle的事件处理器。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.</span><br><span class="line">由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。</span><br><span class="line">记住，一个任务一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，</span><br><span class="line">等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，</span><br><span class="line">等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。</span><br><span class="line"></span><br><span class="line">在第12ms的时候，</span><br><span class="line">1.执行主线程javascript代码，执行当前任务。</span><br><span class="line">2.单击firstButton，单击firstButton的时候，创建事件</span><br><span class="line">3.单击secondButton,单击secondButton的时候，创建事件</span><br><span class="line">在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，</span><br><span class="line">任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，</span><br><span class="line">UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。</span><br><span class="line"></span><br><span class="line">接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，</span><br><span class="line">secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，</span><br><span class="line">接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，</span><br><span class="line">浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。</span><br><span class="line">最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms，</span><br><span class="line">执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，</span><br><span class="line">但是对应的事件处理任务在第23ms时才开始执行。</span><br></pre></td></tr></table></figure></p><h3 id="4-宏任务和微任务"><a href="#4-宏任务和微任务" class="headerlink" title="4.宏任务和微任务"></a>4.宏任务和微任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;     </span><br><span class="line">第5ms单击firstButton</span><br><span class="line">第12m单击secondButton</span><br><span class="line">firstButton 的单击事件处理函数firstHandle需要执行8ms。</span><br><span class="line"></span><br><span class="line">secondButton 的单击事件的处理函数secondHandle需要执行5ms。</span><br><span class="line"></span><br><span class="line">在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。</span><br><span class="line">因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。</span><br><span class="line"></span><br><span class="line">我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，</span><br><span class="line">但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，</span><br><span class="line">需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。</span><br><span class="line"></span><br><span class="line">在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，</span><br><span class="line">单击firstButton和secondButton按钮这两个任务处于等待状态，</span><br><span class="line">但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，</span><br><span class="line">此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，</span><br><span class="line">若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，</span><br><span class="line">处理firstButton按钮单机相关任务的代码如下。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，</span><br><span class="line">此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，</span><br><span class="line">第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，</span><br><span class="line">此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，</span><br><span class="line">在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，</span><br><span class="line">添加了一个微任务处理PROMISE成功兑现。</span><br><span class="line">如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，</span><br><span class="line">微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，</span><br><span class="line">事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。</span><br><span class="line"></span><br><span class="line">正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，</span><br><span class="line">在更早的队列中secondButton单击任务执行完毕则继续等待。</span><br><span class="line"></span><br><span class="line">当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。</span><br><span class="line">可以在主线程和第一个按钮单击任务之间重新渲染页面，</span><br><span class="line">但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。</span><br><span class="line">注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，</span><br><span class="line">所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，</span><br><span class="line">事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意。</span><br></pre></td></tr></table></figure><h3 id="5-计时器"><a href="#5-计时器" class="headerlink" title="5.计时器"></a>5.计时器</h3><p>计时器是能延迟一段代码的运行，延迟时长是指定的时长，<br>将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，<br>在事件循环中执行计时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* run 18ms */</span><br><span class="line">假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，</span><br><span class="line">在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，</span><br><span class="line">发生了3件重要的事件。</span><br><span class="line">在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.</span><br><span class="line">计时器的引用保存在浏览器。</span><br><span class="line">在6ms，单击鼠标。</span><br><span class="line">在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。</span><br><span class="line"></span><br><span class="line">从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。</span><br><span class="line">新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，</span><br><span class="line">该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，</span><br><span class="line">计时器事件与input输入框的输入事件类似，都会被添加到队列中。</span><br><span class="line">注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。</span><br><span class="line">运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，</span><br><span class="line">因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，</span><br><span class="line">3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，</span><br><span class="line">这意味着单击事件处理器开始执行，setTimeout函数只到期一次，</span><br><span class="line">setInterval函数则不同，setTnterval会持续执行到被清除，</span><br><span class="line">因此，在第20ms的时候，setInterval又一次触发，</span><br><span class="line">但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发。</span><br><span class="line">但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。</span><br><span class="line">单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，</span><br><span class="line">第28ms,事件循环进行下一次迭代，执行延迟计时器任务。</span><br><span class="line"></span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。</span><br><span class="line">这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，</span><br><span class="line">至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，</span><br><span class="line">而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，</span><br><span class="line">但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，</span><br><span class="line">因为队列中已经有一个与之相匹配的间隔计时器，</span><br><span class="line">在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，</span><br><span class="line">然后进入下一个事件循环迭代。</span><br><span class="line"></span><br><span class="line">最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,</span><br><span class="line">又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。</span><br><span class="line"></span><br><span class="line">间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，</span><br><span class="line">此时，由于间隔处理器正在执行，不是在队列中等待，</span><br><span class="line">设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，</span><br><span class="line">每一个任务的执行时间有可能不同，一个接一个的完成。</span><br><span class="line"></span><br><span class="line">最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，</span><br><span class="line">事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，</span><br><span class="line">间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，</span><br><span class="line">回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。&lt;/p&gt;
    
    </summary>
    
      <category term="ZHANGPENG" scheme="http://xgfe.github.io/categories/ZHANGPENG/"/>
    
    
      <category term="宏任务和微任务" scheme="http://xgfe.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>js实现算法之动态规划</title>
    <link href="http://xgfe.github.io/2019/03/25/dengzonghui/%20dynamic/"/>
    <id>http://xgfe.github.io/2019/03/25/dengzonghui/ dynamic/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.646Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了动态规划的几种经典题型，分别为经典01背包、最少硬币、最大正方形、最大加号标志。</p><a id="more"></a><h2 id="一、经典01背包"><a href="#一、经典01背包" class="headerlink" title="一、经典01背包"></a>一、经典01背包</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>背包容量capacity=5，有三个物品(value, weight)，分别是(3,2),(4,3),(5,4)求出其搭配组合，使得背包内总价最大，且最大价值为多少？</p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先理清思路列出表格：<br>如果背包总容量为0，那么很显然地，任何物品都无法装进背包，那么背包内总价值必然是0。所以第一步先填满 j=0 的情况。<br>接下来将从上到下，从左往右地填写这个表格。分析第i行时，它的物品组合仅能是小于等于i的情况。所以现在把注意力定位到 i =0, j = 1 的空格上。<br>i=0 j=1 : 背包总容量为1，但是物品0 的重量为 2，无法装下去，所以这一格应该填 0。<br>i=0 j=2 : 背包总容量为2，刚好可以装下物品0 ，由于物品0 的价值为3，因此这一格填 3。<br>后面同理。<br>i=1 j=1 : 背包总容量为1，但是物品0 的重量为 2，物品1重量为3，背包无法装下任何物品，所以填 0。</p><table><thead><tr><th></th><th>val</th><th>weight</th><th>j=0</th><th>j=1</th><th>j=2</th><th>j=3</th><th>j=4</th><th>j=5</th></tr></thead><tbody><tr><td>i=0</td><td>3</td><td>2</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>i=1</td><td>4</td><td>3</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td></tr><tr><td>i=2</td><td>5</td><td>4</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td></tr></tbody></table><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(j&gt;w[i])&#123;</span><br><span class="line">    T[i][j] = T[i-1][j]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    T[i][j] = max(T[i-1][j-w[i]]+val[i], T[i-1][j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function backpack(w,val,capacity,n)&#123;</span><br><span class="line">    var T = []</span><br><span class="line"></span><br><span class="line">    for(let i = 0;i &lt; n;i++)&#123;</span><br><span class="line">        T[i] = [];</span><br><span class="line">        for(let j=0;j &lt;= capacity;j++)&#123;</span><br><span class="line">            if(j === 0)&#123; //容量为0</span><br><span class="line">                T[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j &lt; w[i])&#123; //容量小于物品重量，本行hold不住</span><br><span class="line">                if(i === 0)&#123;</span><br><span class="line">                    T[i][j] = 0; // i = 0时，不存在i-1，所以T[i][j]取0</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = T[i-1][j]; //容量小于物品重量，参照上一行</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i === 0)&#123;</span><br><span class="line">                T[i][j] = val[i]; //第0行，不存在 i-1, 最多只能放这一行的那一个物品</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                T[i][j] = Math.max(val[i] + T[i-1][j-w[i]],T[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findValue(w,val,capacity,n,T);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line">//找到需要的物品</span><br><span class="line">function findValue(w,val,capacity,n,T)&#123;</span><br><span class="line">    var i = n-1, j = capacity;</span><br><span class="line">    while ( i &gt; 0 &amp;&amp; j &gt; 0 )&#123;</span><br><span class="line">        if(T[i][j] != T[i-1][j])&#123;</span><br><span class="line">            console.log(&apos;选择物品&apos;+i+&apos;,重量：&apos;+ w[i] +&apos;,价值：&apos; + values[i]);</span><br><span class="line">            j = j- w[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i--;  //如果相等，那么就到 i-1 行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == 0 )&#123;</span><br><span class="line">        if(T[i][j] != 0)&#123; //那么第一行的物品也可以取</span><br><span class="line">            console.log(&apos;选择物品&apos;+i+&apos;,重量：&apos;+ w[i] +&apos;,价值：&apos; + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var values = [3,4,5],</span><br><span class="line">weights = [2,3,4],</span><br><span class="line">capacity = 5,</span><br><span class="line">n = values.length;</span><br><span class="line"></span><br><span class="line">console.log(backpack(weights,values,capacity,n));</span><br></pre></td></tr></table></figure><h2 id="二、最少硬币"><a href="#二、最少硬币" class="headerlink" title="二、最少硬币"></a>二、最少硬币</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>4种硬币 1分、2分、5分、6分<br>总共需要11分，求最少的硬币数以及组合</p><h3 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先理清思路列出表格：<br>与经典背包相同，填写第i行表示只能用i和比i小的硬币。硬币数组coins[]，需要的钱数j。<br>当我们只能使用面额为1分的硬币时，根据上面的规则，那么很显然，总额为几分，就需要几个硬币。<br>当我们有1分和2分两种面额时，那么组合方式就相对多了点。<br>i=1 j = 1：总额为1时，只能使用1分的面额。即填1。<br>i=1 j = 2：总额为2时，可以使用2个1分的，也可以使用1个2分的。<br>因为我们要求最少硬币，所以使用1个2分的。表格里填1。<br>以此类推：</p><table><thead><tr><th></th><th>j=0</th><th>j=1</th><th>j=2</th><th>j=3</th><th>j=4</th><th>j=5</th><th>j=6</th><th>j=7</th><th>j=8</th><th>j=9</th><th>j=10</th><th>j=11</th></tr></thead><tbody><tr><td>i=0 1分</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>i=1 2分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>6</td></tr><tr><td>i=2 5分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td><td>3</td></tr><tr><td>i=3 6分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td></tr></tbody></table><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(j&lt;coins[i])&#123;</span><br><span class="line">    T[i][j] = T[i-1][j]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    T[i][j] = min(T[i-1][j], T[i][j-coins[i]]+1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;number[]&#125; coins</span><br><span class="line">* @param &#123;number&#125; amount</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*/</span><br><span class="line">var coinChange = function(coins, amount) &#123;</span><br><span class="line">    coins.sort((a,b)=&gt;(a-b));</span><br><span class="line">    var T = [];</span><br><span class="line">    for(let i=0; i&lt;coins.length; i++)&#123;</span><br><span class="line">        T[i] = [];</span><br><span class="line">        for(let j=0; j&lt;=amount; j++)&#123;</span><br><span class="line">            T[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0; i&lt;T.length; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;T[i].length; j++)&#123;</span><br><span class="line">            if(j==0)&#123;</span><br><span class="line">                T[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==0)&#123;</span><br><span class="line">                if(Number.isInteger(j/coins[i]))&#123;</span><br><span class="line">                    T[i][j] = j/coins[i];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = Infinity;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(j&lt;coins[i])&#123;</span><br><span class="line">                    T[i][j] = T[i-1][j];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = Math.min(T[i-1][j], T[i][j-coins[i]]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return T[T.length-1][T[0].length-1]===Infinity?-1:T[T.length-1][T[0].length-1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、最大正方形"><a href="#三、最大正方形" class="headerlink" title="三、最大正方形"></a>三、最大正方形</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><h3 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先用例中不一定会给正方形，也可能是长方形，所以必须分别求长和宽。<br>其次如果此点的值是0，则直接将结果设为0；如果此点的值为1，则它等于它左方、上方、左上方三者的最小值+1。<br>最后是需要一个变量max，在遍历的过程中不断修改自身获取dp中的最大值。</p><p><img src="http://p0.meituan.net/xgfe/62e9135edf9a68df2624aba1d50b9582537777.jpg" alt="最大正方形的获取"></p><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; matrix</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maximalSquare = function(matrix) &#123;</span><br><span class="line">    let len1 = matrix.length, len2;</span><br><span class="line">    var dp = new Array(len1);//设置长度</span><br><span class="line">    let max = 0;//记录矩阵中最大值</span><br><span class="line">    for(let i=0; i&lt;len1; i++)&#123;</span><br><span class="line">        len2 = matrix[i].length;</span><br><span class="line">        dp[i] = new Array(len2);</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0; i&lt;len1; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;len2; j++)&#123;</span><br><span class="line">            if(i==0 || j==0)&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] == &apos;1&apos;?1:0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] == &apos;1&apos;? (Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1):0;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max*max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、最大加号标志"><a href="#四、最大加号标志" class="headerlink" title="四、最大加号标志"></a>四、最大加号标志</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。</p><p>一个 k” 阶由 1 组成的“轴对称”加号标志具有中心网格  grid[x][y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k” 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。</p><p>k 阶轴对称加号标志示例:</p><p>阶 1:<br>000<br>010<br>000</p><p>阶 2:<br>00000<br>00100<br>01110<br>00100<br>00000</p><p>阶 3:<br>0000000<br>0001000<br>0001000<br>0111110<br>0001000<br>0001000<br>0000000</p><p>示例 1：</p><p>输入: N = 5, mines = [[4, 2]]<br>输出: 2<br>解释:</p><p>11111<br>11111<br>11111<br>11111<br>11011</p><p>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。</p><p>示例 2：</p><p>输入: N = 2, mines = []<br>输出: 1<br>解释:</p><p>11<br>11</p><p>没有 2 阶加号标志，有 1 阶加号标志。</p><p>示例 3：</p><p>输入: N = 1, mines = [[0, 0]]<br>输出: 0<br>解释:</p><p>0</p><p>没有加号标志，返回 0 。</p><h3 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先要给所有位置设置最大值即边长N。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dp = [...Array(N)].map(() =&gt; Array(N).fill(N));</span><br></pre></td></tr></table></figure></p><p>循环遍历所有行，从四个方向更新dp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let l=0, left=0; l&lt;N; l++)&#123;</span><br><span class="line">            dp[i][l] = Math.min(dp[i][l], left = (dp[i][l] == 0 ? 0: left+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let r=N-1, right=0; r&gt;=0; r--)&#123;</span><br><span class="line">            dp[i][r] = Math.min(dp[i][r], right = (dp[i][r] == 0 ? 0: right+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let u=0, up=0; u&lt;N; u++)&#123;</span><br><span class="line">            dp[u][i] = Math.min(dp[u][i], up = (dp[u][i] == 0 ? 0: up+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let d=N-1, down=0; d&gt;=0; d--)&#123;</span><br><span class="line">            dp[d][i] = Math.min(dp[d][i], down = (dp[d][i] == 0 ? 0: down+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>left right up down注意每遍历一行都要更新为0。</strong></p><h3 id="3-代码-3"><a href="#3-代码-3" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; N</span><br><span class="line"> * @param &#123;number[][]&#125; mines</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var orderOfLargestPlusSign = function(N, mines) &#123;</span><br><span class="line">    let dp = [...Array(N)].map(() =&gt; Array(N).fill(N));</span><br><span class="line">    for(let i=0; i&lt;mines.length; i++)&#123;</span><br><span class="line">        dp[mines[i][0]][mines[i][1]] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let left, right, up, down;</span><br><span class="line">    for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let l=0, left=0; l&lt;N; l++)&#123;</span><br><span class="line">            dp[i][l] = Math.min(dp[i][l], left = (dp[i][l] == 0 ? 0: left+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let r=N-1, right=0; r&gt;=0; r--)&#123;</span><br><span class="line">            dp[i][r] = Math.min(dp[i][r], right = (dp[i][r] == 0 ? 0: right+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let u=0, up=0; u&lt;N; u++)&#123;</span><br><span class="line">            dp[u][i] = Math.min(dp[u][i], up = (dp[u][i] == 0 ? 0: up+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let d=N-1, down=0; d&gt;=0; d--)&#123;</span><br><span class="line">            dp[d][i] = Math.min(dp[d][i], down = (dp[d][i] == 0 ? 0: down+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var max = 0;</span><br><span class="line">    for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;N; j++)&#123;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：<br>本文主要对动态规划几种经典题做了简单介绍，希望对大家对算法方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://juejin.im/post/5affed3951882567161ad511" target="_blank" rel="noopener">https://juejin.im/post/5affed3951882567161ad511</a><br><a href="https://juejin.im/post/5b0a8e0f51882538b2592963" target="_blank" rel="noopener">https://juejin.im/post/5b0a8e0f51882538b2592963</a><br><a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了动态规划的几种经典题型，分别为经典01背包、最少硬币、最大正方形、最大加号标志。&lt;/p&gt;
    
    </summary>
    
      <category term="dengzonghui" scheme="http://xgfe.github.io/categories/dengzonghui/"/>
    
    
      <category term="算法" scheme="http://xgfe.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/"/>
    <id>http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/</id>
    <published>2019-03-09T08:15:00.000Z</published>
    <updated>2019-04-16T07:07:55.916Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。</p><a id="more"></a><h2 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</p></blockquote><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>用户注册时验证用户名是否被占用为例在输入的时候就在判断这个用户名是否已被注册。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数前<br><img src="/uploads/yangfan/DebounceThrottle/debouncebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数后<br><img src="/uploads/yangfan/DebounceThrottle/debounceafter.gif" width="400px"><br></div><br></div><p>使用防抖函数前做法存在明显缺陷当用户输入发生变化的时候，就请求判断了，不仅对服务器的压力增大了，而且用户在输入中时频繁的校验提示中断用户交互明显降低了用户体验。而理想的做法应该是，用户输入发生变化后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。而函数防抖所做的工作就是延迟一段时间去执行函数而在延迟期间又调用了此动作则重新计时。</p><h3 id="DemoCode"><a href="#DemoCode" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"ordinary"</span>&gt;</span>普通<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'ordinary'</span> <span class="attr">id</span>=<span class="string">'ordinary'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"debounce"</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'debounce'</span> <span class="attr">id</span>=<span class="string">'debounce'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ajax requestDtae:<span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ordinaryInput = <span class="built_in">document</span>.getElementById(<span class="string">'ordinary'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceInput = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceAjax = _.debounce(ajax, <span class="number">1000</span>)</span><br><span class="line">ordinaryInput.addEventListener(<span class="string">'keyup'</span>, ajax);</span><br><span class="line">debounceInput.addEventListener(<span class="string">'keyup'</span>, debounceAjax);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            func(args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Throttle（节流）"><a href="#Throttle（节流）" class="headerlink" title="Throttle（节流）"></a>Throttle（节流）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></blockquote><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>在瀑布流式布局的页面中，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。在发生滚动时就需要判断页面是否滚动到底部。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用节流函数前<br><img src="/uploads/yangfan/DebounceThrottle/throttlebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用节流函数后<br><img src="/uploads/yangfan/DebounceThrottle/throttleafter.gif" width="400px"><br></div><br></div><p>使用节流函数前明显缺点是消耗性能，因为当在滚动的时候，浏览器会无时不刻地在计算判断是否滚动到底部的逻辑，而在实际的场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间在去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时不刻地在执行的函数。</p><h3 id="DemoCode-1"><a href="#DemoCode-1" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`scroll bodyY:<span class="subst">$&#123;body.getBoundingClientRect().y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throttleScrollAnimation = _.throttle(scrollAnimation, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//window.addEventListener('scroll', scrollAnimation);</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttleScrollAnimation);</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">let</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (curr - start &gt;= wait) &#123;</span><br><span class="line">            func(args);</span><br><span class="line">            start = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                func(args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果还是不能完全体会 debounce 和 throttle 的差异，可以到 <a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">这个页面</a> 看一下两者可视化的比较。<br>在实际的开发中根据根据需求的不同合理使用 debounce 或 throttle。<br>例如：在模糊查询时使用 debounce 在无限滚动时使用 throttle。（requestAnimationFrame）</p><h2 id="附lodash实现代码"><a href="#附lodash实现代码" class="headerlink" title="附lodash实现代码"></a>附lodash实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isObject <span class="keyword">from</span> <span class="string">'./isObject.js'</span></span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">'./.internal/root.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a debounced function that delays invoking `func` until after `wait`</span></span><br><span class="line"><span class="comment"> * milliseconds have elapsed since the last time the debounced function was</span></span><br><span class="line"><span class="comment"> * invoked, or until the next browser frame is drawn. The debounced function</span></span><br><span class="line"><span class="comment"> * comes with a `cancel` method to cancel delayed `func` invocations and a</span></span><br><span class="line"><span class="comment"> * `flush` method to immediately invoke them. Provide `options` to indicate</span></span><br><span class="line"><span class="comment"> * whether `func` should be invoked on the leading and/or trailing edge of the</span></span><br><span class="line"><span class="comment"> * `wait` timeout. The `func` is invoked with the last arguments provided to the</span></span><br><span class="line"><span class="comment"> * debounced function. Subsequent calls to the debounced function return the</span></span><br><span class="line"><span class="comment"> * result of the last `func` invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **Note:** If `leading` and `trailing` options are `true`, `func` is</span></span><br><span class="line"><span class="comment"> * invoked on the trailing edge of the timeout only if the debounced function</span></span><br><span class="line"><span class="comment"> * is invoked more than once during the `wait` timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span></span><br><span class="line"><span class="comment"> * until the next tick, similar to `setTimeout` with a timeout of `0`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`</span></span><br><span class="line"><span class="comment"> * invocation will be deferred until the next frame is drawn (typically about</span></span><br><span class="line"><span class="comment"> * 16ms).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span></span><br><span class="line"><span class="comment"> * for details over the differences between `debounce` and `throttle`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 0.1.0</span></span><br><span class="line"><span class="comment"> * @category Function</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func The function to debounce.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [wait=0]</span></span><br><span class="line"><span class="comment"> *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is</span></span><br><span class="line"><span class="comment"> *  used (if available).</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; [options=&#123;&#125;] The options object.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.leading=false]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the leading edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [options.maxWait]</span></span><br><span class="line"><span class="comment"> *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.trailing=true]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125; Returns the new debounced function.</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Avoid costly calculations while the window size is in flux.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('resize', debounce(calculateLayout, 150))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Invoke `sendMail` when clicked, debouncing subsequent calls.</span></span><br><span class="line"><span class="comment"> * jQuery(element).on('click', debounce(sendMail, 300, &#123;</span></span><br><span class="line"><span class="comment"> *   'leading': true,</span></span><br><span class="line"><span class="comment"> *   'trailing': false</span></span><br><span class="line"><span class="comment"> * &#125;))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span></span><br><span class="line"><span class="comment"> * const debounced = debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;)</span></span><br><span class="line"><span class="comment"> * const source = new EventSource('/stream')</span></span><br><span class="line"><span class="comment"> * jQuery(source).on('message', debounced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Cancel the trailing debounced invocation.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('popstate', debounced.cancel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Check for pending invocations.</span></span><br><span class="line"><span class="comment"> * const status = debounced.pending() ? "Pending..." : "Ready"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastArgs, </span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> maxing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span></span><br><span class="line">    <span class="keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> root.requestAnimationFrame === <span class="string">'function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = !!options.leading</span><br><span class="line">        maxing = <span class="string">'maxWait'</span> <span class="keyword">in</span> options</span><br><span class="line">        maxWait = maxing ? <span class="built_in">Math</span>.max(+options.maxWait || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = lastArgs</span><br><span class="line">        <span class="keyword">const</span> thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params">pendingFunc, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            root.cancelAnimationFrame(timerId);</span><br><span class="line">            <span class="keyword">return</span> root.requestAnimationFrame(pendingFunc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTimeout(pendingFunc, wait)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancelTimer</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.cancelAnimationFrame(id)</span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Reset any `maxWait` timer.</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        <span class="comment">// Start the timer for the trailing edge.</span></span><br><span class="line">        timerId = startTimer(timerExpired, wait)</span><br><span class="line">        <span class="comment">// Invoke the leading edge.</span></span><br><span class="line">        <span class="keyword">return</span> leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">        <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxing ?</span><br><span class="line">            <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke) :</span><br><span class="line">            timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either this is the first call, activity has stopped and we're at the</span></span><br><span class="line">        <span class="comment">// trailing edge, the system time has gone backwards and we're treating</span></span><br><span class="line">        <span class="comment">// it as the trailing edge, or we've hit the `maxWait` limit.</span></span><br><span class="line">        <span class="comment">// timeSinceLastCall &lt; 0 修改系统时间时不会出现bug</span></span><br><span class="line">        <span class="keyword">return</span> (lastCallTime === <span class="literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class="line">            (timeSinceLastCall &lt; <span class="number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">            <span class="keyword">return</span> trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restart the timer.</span></span><br><span class="line">        timerId = startTimer(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        timerId = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only invoke if we have `lastArgs` which means `func` has been</span></span><br><span class="line">        <span class="comment">// debounced at least once.</span></span><br><span class="line">        <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timerId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            cancelTimer(timerId)</span><br><span class="line">        &#125;</span><br><span class="line">        lastInvokeTime = <span class="number">0</span></span><br><span class="line">        lastArgs = lastCallTime = lastThis = timerId = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId === <span class="literal">undefined</span> ? result : trailingEdge(<span class="built_in">Date</span>.now())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId !== <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">const</span> isInvoking = shouldInvoke(time)</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = <span class="keyword">this</span></span><br><span class="line">        lastCallTime = time</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">                <span class="comment">// Handle invocations in a tight loop.</span></span><br><span class="line">                timerId = startTimer(timerExpired, wait)</span><br><span class="line">                <span class="keyword">return</span> invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            timerId = startTimer(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = <span class="string">'leading'</span> <span class="keyword">in</span> options ? !!options.leading : leading</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。&lt;/p&gt;
    
    </summary>
    
      <category term="yangfan" scheme="http://xgfe.github.io/categories/yangfan/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="debounce&amp;throttle" scheme="http://xgfe.github.io/tags/debounce-throttle/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 使用及原理分析</title>
    <link href="http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/"/>
    <id>http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-03-09T04:05:41.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。<br><a id="more"></a><br>那么问题来了，什么是依赖注入？</p><blockquote><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。<br>—摘自百度百科</p></blockquote><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在日常编码中经常会有类之间的依赖，为了方便理解，我们举个例子。手机类Phone包含了摄像头Camera组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        mCamera = new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到 Phone 和 Carmera 是耦合的，Phone 需要知道 Camera 的实现类 BackCamera 的存在，一旦 Camera 的实现变为其他，比如 FrontCamera 时，我们还需要修改 Phone 的构造方法。类似问题就可以使用依赖注入来解决。依赖注入的常用方法有构造方法注入和 setter 方法注入，两种方式都可以对 Phone 和 Camera 解耦，使得 Phone 无需关注 Camera 的实现，即使 Camera 的类型变了也无需修改 Phone 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone(Camera camera) &#123;</span><br><span class="line">        mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCamera(Camera camera) &#123;</span><br><span class="line">        this.mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Component-和-Inject"><a href="#Component-和-Inject" class="headerlink" title="@Component 和 @Inject"></a>@Component 和 @Inject</h3><p>那使用 Dagger2 该如何注入呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BackCamera implements Camera &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getCameraType() &#123;</span><br><span class="line">        return &quot;后置摄像头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera mCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到首先需要声明一个 @Component，然后需要在 BackCamera 的构造方法前增加注解 @Inject，接着在 Phone 的 mCamera 前增加 @Inject 以及构造方法中调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，几者间关系如下：</p><p><img src="/uploads/wangwenming/dagger-1.png" alt=""></p><h3 id="Module-和-Provides"><a href="#Module-和-Provides" class="headerlink" title="@Module 和 @Provides"></a>@Module 和 @Provides</h3><p>那么问题来了，@Inject 只能标记构造方法，如果需要注入的是来自三方库的对象怎么办呢？这就需要用到 @Module，下面我们用 @Module 改造下上面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    public BackCamera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component(modules = &#123;CameraModule.class&#125;)</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Module 和 @Provides 配合可以实现对三方库对象的注入。</p><h3 id="Named-和-Qualifier"><a href="#Named-和-Qualifier" class="headerlink" title="@Named 和 @Qualifier"></a>@Named 和 @Qualifier</h3><p>@Qualifier 是限定符用于自定义注解，@Named 是 @Qualifier 的一种实现。在一些情况下我们需要两个有相同父类或实现同一接口的依赖，当需求方使用的又是他们父类时，Component 就不知道到底提供哪一个了。还是拿手机举例，我们在原有基础上增加一个前置摄像头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera provideFrontCamera() &#123;</span><br><span class="line">        return new FrontCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera mFrontCamera;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera mBackCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为 Module 中的 provide 方法加上 @Named 注解，然后在需要使用的地方加上对应的 @Named 注解。上面例子同样可以使用 @Qualifier 来实现，使用 @Qualifier 定义两个运行时注解 @Front 和 @Back，使用两个注解替换上面的 @Named 注解即可。</p><h3 id="Singleton-和-Scope"><a href="#Singleton-和-Scope" class="headerlink" title="@Singleton 和 @Scope"></a>@Singleton 和 @Scope</h3><p>@Scope 同样用于自定义注解，我能可以通过 @Scope 自定义的注解来限定注解作用域，实现局部的单例；@Singleton 是 @Scope 的一个实现。在一些场景下我们需要使用单例，@Singleton 和 @Scope 可以帮助我们实现局部单例。为什么说是局部单例呢，因为 @Singleton 或 @Scope 能保证在对应的 Component 下是单例的，如果需要全局的单例，我们就需要其他手段保证 Component 是单例。下面看个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Singleton</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">    void inject(App app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Singleton</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public Logger()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;Logger&quot;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger2;</span><br><span class="line"></span><br><span class="line">    public App()&#123;</span><br><span class="line">        DaggerAppComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;App&quot;, &quot;app:&quot; + this);</span><br><span class="line">        logger.printMessage();</span><br><span class="line">        logger2.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 @Singleton 标注 Component 和需要注入的类即可。在上面的例子中，如果调用 App 的 printMessage 方法可以看到 logger 和 logger2 为同一对象，对于不同 App 对象的 logger 则是不同对象。当然我们也可以使用 @Scope 自定义一个注解来实现局部注解，来替换 @Singleton。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>前面简单介绍了 Dagger2 使用，接下来我们分析一下实现原理。Dagger2 在编译时根据注解生成一些辅助类，接下来我们具体分析下生成的辅助类。辅助类可以通过 DaggerXXXComponent 来快速定位。上面两个例子对应生成辅助类如下：</p><p><img src="/uploads/wangwenming/dagger-2.png" alt=""></p><p>简单来看辅助类和注解对应关系很明显，拿手机的例子来说对应关系如下：</p><table><thead><tr><th style="text-align:left">辅助类</th><th style="text-align:left">注解</th></tr></thead><tbody><tr><td style="text-align:left">BackCamera_Factory</td><td style="text-align:left">BackCamera 构造方法的 @Inject</td></tr><tr><td style="text-align:left">CameraModule_ProvideBackCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">CameraModule_ProvideFrontCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">DaggerPhoneComponent</td><td style="text-align:left">PhoneComponent 的 @Component</td></tr><tr><td style="text-align:left">Phone_MembersInjector</td><td style="text-align:left">Phone 对应的 @Inject</td></tr></tbody></table><p>原始类以及辅助类类图如下：</p><p><img src="/uploads/wangwenming/dagger-3.png" alt=""></p><p>接下来我们分析下具体的注入过程，首先 Phone 中会调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，我们来看下 DaggerPhoneComponent 的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Generated(</span><br><span class="line">  value = &quot;dagger.internal.codegen.ComponentProcessor&quot;,</span><br><span class="line">  comments = &quot;https://google.github.io/dagger&quot;</span><br><span class="line">)</span><br><span class="line">public final class DaggerPhoneComponent implements PhoneComponent &#123;</span><br><span class="line">  private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">  private DaggerPhoneComponent(Builder builder) &#123;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static PhoneComponent create() &#123;</span><br><span class="line">    return new Builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private void initialize(final Builder builder) &#123;</span><br><span class="line">    this.cameraModule = builder.cameraModule;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void inject(Phone phone) &#123;</span><br><span class="line">    injectPhone(phone);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Phone injectPhone(Phone instance) &#123;</span><br><span class="line">    Phone_MembersInjector.injectMFrontCamera(</span><br><span class="line">        instance, CameraModule_ProvideFrontCameraFactory.proxyProvideFrontCamera(cameraModule));</span><br><span class="line">    Phone_MembersInjector.injectMBackCamera(</span><br><span class="line">        instance, CameraModule_ProvideBackCameraFactory.proxyProvideBackCamera(cameraModule));</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">    private Builder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public PhoneComponent build() &#123;</span><br><span class="line">      if (cameraModule == null) &#123;</span><br><span class="line">        this.cameraModule = new CameraModule();</span><br><span class="line">      &#125;</span><br><span class="line">      return new DaggerPhoneComponent(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder cameraModule(CameraModule cameraModule) &#123;</span><br><span class="line">      this.cameraModule = Preconditions.checkNotNull(cameraModule);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DaggerPhoneComponent 在创建时首先会创建一个 CameraModule，在进行注入时首先会调用工厂的代理方法最终调用 Module 中对应 @Provides 的方法创建对象，然后通过 Phone_MembersInjector 将上面创建的对象进行注入，工厂与 Injector 核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 工厂类核心</span><br><span class="line"> public static Camera proxyProvideFrontCamera(CameraModule instance) &#123;</span><br><span class="line">    return Preconditions.checkNotNull(</span><br><span class="line">        instance.provideFrontCamera(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Injector 核心</span><br><span class="line"> public static void injectMBackCamera(Phone instance, Camera mBackCamera) &#123;</span><br><span class="line">    instance.mBackCamera = mBackCamera;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Dagger2 的基本使用并从辅助代码的源码层面进行了原理分析。关于从注解到辅助代码的生成并没有介绍，感兴趣的同学可以自行查阅注解处理器相关知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="wangwenming" scheme="http://xgfe.github.io/categories/wangwenming/"/>
    
    
      <category term="dagger2" scheme="http://xgfe.github.io/tags/dagger2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈当Swift中defer和inout同时起作用</title>
    <link href="http://xgfe.github.io/2019/02/20/wangqing28/%E6%B5%85%E8%B0%88%E5%BD%93Swift%E4%B8%ADdefer%E5%92%8Cinout%E5%90%8C%E6%97%B6%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>http://xgfe.github.io/2019/02/20/wangqing28/浅谈当Swift中defer和inout同时起作用/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.661Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对 <code>Swift</code> 中 <code>defer</code>、<code>inout</code> 以及 <code>return</code> 时相互影响的时候的情况进行简单的分析，目的是更好的理解 <code>defer</code>、<code>inout</code> 原理以及使用场合，减少踩坑和提高<code>debug</code>效率。</p><blockquote><p>本文中的示例代码，均为 <code>Swift 4.2</code> 版本</p></blockquote><a id="more"></a><h2 id="inout和defer"><a href="#inout和defer" class="headerlink" title="inout和defer"></a>inout和defer</h2><h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><p>有关 <code>inout</code> 关键字苹果官方描述</p><blockquote><p>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.</p></blockquote><p>我们可以了解到，<code>inout</code> 关键字，有点类似于 <code>C</code> 语言中的引用传递或指针传递，目的是为了对入参进行修改。 但实际上 <code>inout</code> 的机制并不是引用传递，或者是指针传递。</p><p>以下是两段比较详细的苹果官方描述，摘出来看比较清晰：</p><blockquote><p>You write an in-out parameter by placing the inout keyword right before a parameter’s type. An in-out parameter has a value that is passed in to the function, is modified by the function, and is passed back out of the function to replace the original value. </p></blockquote><blockquote><p>in-out parameters are passed as follows:<br>When the function is called, the value of the argument is copied.<br>In the body of the function, the copy is modified.<br>When the function returns, the copy’s value is assigned to the original argument.<br>This behavior is known as copy-in copy-out or call by value result. </p></blockquote><p>从这两段我们可以看出，<code>inout</code> 的实现原理是：</p><ol><li>参数传入，拷贝一份 <strong>临时变量</strong></li><li>函数体中，修改的是这一份 <strong>临时变量</strong></li><li>函数返回时，这份 <strong>临时变量</strong> 被赋予给 <strong>原始参数</strong></li></ol><p>所以，是先拷贝，再修改，再拷贝回去的逻辑。这一点至关重要。</p><p>使用示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">f(x: &amp;a)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">// 结果为 11</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于对象，即非 <code>Swift</code> 类型的，因为本身即为指针，所以本身就是指针传递，函数内部调用对象方法进行操作进而导致对象内部值的变化时，并不需要 <code>inout</code> 关键字。但是如果你想对这个对象变量整体进行的赋值替换操作，并且能反应到外部时，就需要 <code>inout</code>。<br>本文为了方便讨论，此处以及后续将仅仅以 <code>Swift</code> 原生类型作为例子。</p></blockquote><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>有关 <code>defer</code> 关键字苹果官方的描述</p><blockquote><p>A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.</p></blockquote><blockquote><p>This means that a defer statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</p></blockquote><p>简单说来， <code>defer</code> 是用来定义一段代码，用来在 <strong>离开</strong> 所在 <code>scope</code> 的时候执行。 苹果官方对 <code>defer</code> 的建议，也是用来关闭描述符、处理一些错误等等。</p><p>使用示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"do defer"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"do func"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"func done"</span>)</span><br><span class="line">&#125;</span><br><span class="line">g()</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">do func</span></span><br><span class="line"><span class="comment">func done</span></span><br><span class="line"><span class="comment">do defer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>这里注意一下， <code>defer</code> 的生效时机是 <code>scope</code> 离开的时候，而 <strong>不是函数执行完毕</strong> 的时候。 所以如果 <code>defer</code> 写在 <code>if</code> 或者 <code>for</code> 的内部， 会在 <code>if</code> 结束的时候立刻执行。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>因为很多写 <code>Swift</code> 的同学都是从 <code>Objective-C</code> 过来的，从使用习惯上来说，用 <code>inout</code> 会多一些， <code>defer</code> 并不太多。 但是当 <code>inout</code> 和 <code>defer</code> 以及 <code>return</code> 共同起作用的时候往往会有一些微妙的问题。</p><ol><li><code>defer</code> 本身是个 <code>block</code>，他内部也是可以修改变量。比如：<br><code>defer { x += 1 }</code></li><li><code>return</code> 的时候，也是可以执行一个 <code>block</code> 的。 比如 <code>return { x + 1 }()</code>，同时自身也会往栈上压入值</li><li><code>inout</code> 也是会改变入参的值。（再强调下，是复制-&gt;修改-&gt;写回，而不是原地修改）</li></ol><p>假如一个 <code>inout</code> 入参，在 <code>defer</code> 中被修改，在 <code>return</code> 的 <code>block</code> 中被修改。 那么问题来了：</p><ol><li>这几处修改的生效顺序是什么</li><li>对于 <code>inout</code> 和 <code>return</code> 而言，外界拿到的是什么时候的什么值</li></ol><p>用代码来举例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fdo</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> outX: <span class="type">Int</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ret: \( fdo(x: &amp;outX) )"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after-ret: \( outX )"</span>)</span><br></pre></td></tr></table></figure></p><p>问题：</p><ol><li>几处修改何时生效</li><li><code>fdo</code> 返回的值是多少</li><li>最后的 <code>outX</code> 值又是多少</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为了能知道结果，对上述代码进行扩充<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(tag: String,  v:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(tag):\t\(v)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fdo</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"st-def"</span>, v: x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"ed-def"</span>, v: x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(tag: <span class="string">"st-fdo"</span>, v: x)</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(tag: <span class="string">"ed-fdo"</span>, v: x)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"st-ret"</span>, v: x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"ed-ret"</span>, v: x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outX: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"x-before"</span>, v: outX)</span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"v-return"</span>, v: fdo(x: &amp;outX)) <span class="comment">// 如果代码改成 outX = fdo(x: &amp;outX)，下一行会如何？ 和现在会一样吗</span></span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"x-after"</span>, v: outX)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x-before:10</span><br><span class="line">st-fdo:10</span><br><span class="line">ed-fdo:11</span><br><span class="line">st-ret:11</span><br><span class="line">ed-ret:12</span><br><span class="line">st-def:12</span><br><span class="line">ed-def:13</span><br><span class="line">v-return:12</span><br><span class="line">x-after:13</span><br><span class="line">// 如果代码改动 outX = fdo(x: &amp;outX)</span><br><span class="line">// 结果将是  x-after:12</span><br></pre></td></tr></table></figure></p><p>几个关注点</p><ol><li>打印顺序</li><li>各个节点的值</li><li><code>Swift</code> 执行的是写时拷贝</li></ol><blockquote><p>除了打日志分析之外，也可以检查汇编代码。</p></blockquote><p>简单分析一下可知如下执行顺序：</p><ol><li>正常调用<ol><li>此时内部生成临时变量 <code>x&#39;</code>，后续均操作此 <code>x&#39;</code></li></ol></li><li><code>return</code> 中 <code>block</code> 执行</li><li><code>defer</code> 执行 （如果多个，按倒序）</li><li><code>return</code> 返回<ol><li>此时返回出来的是 <strong>临时变量</strong></li><li>只是返回，<strong>函数调用</strong> 所在的整个语句并未执行</li></ol></li><li><code>inout</code> 生效<ol><li>用内部生成 <code>x&#39;</code> 回填栈顶，即将入参的 <code>x</code> 替换成 <code>x&#39;</code>，调用方取回</li></ol></li><li><strong>函数调用</strong> 所在的代码行生效，使用 <code>return</code> 返回的值对外操作，如外赋值、打印等等</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从实际的实现角度来说，执行顺序是:<br><strong>return中代码</strong> -&gt; <code>defer</code> -&gt; <code>return</code> -&gt; <code>inout</code> -&gt; <strong>调用处代码</strong></p><p>从变量和内存的角度考虑</p><ol><li><code>Swift</code> 是写时拷贝</li><li><code>inout</code> 是创建临时变量 -&gt; 返回时用临时变量覆盖传入变量，而不是原地修改</li></ol><p>从实际使用来说</p><ol><li>对于 <code>defer</code> 使用，应遵循苹果的官方建议，主要用于关闭描述符、处理一些错误。虽然可以做一些额外的副作用，甚至可以根据执行的特性，来在 <code>return</code> 之后再影响外部的一些东东，但是不建议做这些操作。</li><li>对于 <code>inout</code> ，需要了解执行的机制，不能根据现象对机制有所误判。</li><li>建议尽量少用 <strong>副作用</strong> 来达成一些预期，如在函数中过多的对外部变量进行修改，尤其是值类型的变量。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://onevcat.com/2018/11/defer/" target="_blank" rel="noopener">关于 Swift defer 的正确使用</a></li><li><a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html" target="_blank" rel="noopener">Swift Language Guide</a></li><li><a href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_defer-statement" target="_blank" rel="noopener">Swift Language Reference - Statements - defer</a></li><li><a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" target="_blank" rel="noopener">Swift Language Reference - Declarations - In-Out Parameters</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文针对 &lt;code&gt;Swift&lt;/code&gt; 中 &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;inout&lt;/code&gt; 以及 &lt;code&gt;return&lt;/code&gt; 时相互影响的时候的情况进行简单的分析，目的是更好的理解 &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;inout&lt;/code&gt; 原理以及使用场合，减少踩坑和提高&lt;code&gt;debug&lt;/code&gt;效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文中的示例代码，均为 &lt;code&gt;Swift 4.2&lt;/code&gt; 版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="wangqing28" scheme="http://xgfe.github.io/categories/wangqing28/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://xgfe.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Angular CDK 部分功能介绍</title>
    <link href="http://xgfe.github.io/2019/01/17/luanmingyang/Angular%20CDK%20%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xgfe.github.io/2019/01/17/luanmingyang/Angular CDK 部分功能介绍/</id>
    <published>2019-01-17T11:31:00.000Z</published>
    <updated>2020-02-19T11:04:25.653Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Angular CDK 的部分功能，主要包括了三部分：Portal、Overlay、a11y/FocusTrap。</p><a id="more"></a><h1 id="Angular-CDK-部分功能介绍"><a href="#Angular-CDK-部分功能介绍" class="headerlink" title="Angular CDK 部分功能介绍"></a>Angular CDK 部分功能介绍</h1><p>Angular CDK(Component Dev Kit) 是一个组件开发工具包，实现了一些公共的交互，同时不关注组件的具体呈现，可以在组件的开发中使用。</p><p>Angular CDK主要分为两大类：</p><ul><li><p>Common Behaviors</p><p>一组包括了常见功能需求的工具，只与组件行为相关，不影响组件的呈现。</p><p>目前主要包括：</p><ul><li><a href="https://material.angular.io/cdk/a11y" target="_blank" rel="noopener">Accessibility</a> 提供了许多改进可访问性的工具</li><li><a href="https://material.angular.io/cdk/bidi" target="_blank" rel="noopener">Bidirectionality</a> 用于获取和响应LTR / RTL布局方向的变化</li><li><a href="https://material.angular.io/cdk/drag-drop" target="_blank" rel="noopener">Drag and Drop</a> 提供了声明式创建拖拽的接口，支持自由拖拽、列表排序等</li><li><a href="https://material.angular.io/cdk/layout" target="_blank" rel="noopener">Layout</a> 用于构建响应屏幕大小改变的响应式UI</li><li><a href="https://material.angular.io/cdk/observers" target="_blank" rel="noopener">Observers</a> 提供了一组 observers 指令</li><li><a href="https://material.angular.io/cdk/overlay" target="_blank" rel="noopener">Overlay</a> 提供了一种在屏幕上打开浮动面板的方法</li><li><a href="https://material.angular.io/cdk/platform" target="_blank" rel="noopener">Platform</a> 用于收集当前平台及其支持的不同功能的信息</li><li><a href="https://material.angular.io/cdk/portal" target="_blank" rel="noopener">Portal</a> 用于将动态内容呈现到应用程序</li><li><a href="https://material.angular.io/cdk/scrolling" target="_blank" rel="noopener">Scrolling</a> 提供了对滚动的处理</li><li><a href="https://material.angular.io/cdk/text-field" target="_blank" rel="noopener">Text field</a> 用于处理文本输入</li></ul></li><li><p>Components</p><p>一组具有实用功能的无样式组件。</p><p>目前主要包括：</p><ul><li><a href="https://material.angular.io/cdk/stepper" target="_blank" rel="noopener">Stepper</a> 步进器</li><li><a href="https://material.angular.io/cdk/table" target="_blank" rel="noopener">Table</a> 可自定义的 data-table</li><li><a href="https://material.angular.io/cdk/tree" target="_blank" rel="noopener">Tree</a> 方便为结构化数据构建树型结构</li></ul></li></ul><p>本文主要包括了三部分的介绍：Portal、Overlay、a11y/FocusTrap</p><h2 id="1-Angular-CDK-之-Portal"><a href="#1-Angular-CDK-之-Portal" class="headerlink" title="1. Angular CDK 之 Portal"></a>1. Angular CDK 之 Portal</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>Portal 用于将动态内容呈现到应用程序。</p><p>Portal：动态内容，可以是 <code>Component</code> 或 <code>TemplateRef</code></p><p>PortalOutlet：放置动态内容的地方</p><p><a href="https://material.angular.io/cdk/portal/api#DomPortalOutlet" target="_blank" rel="noopener">Portal API</a></p><h3 id="1-2-指令"><a href="#1-2-指令" class="headerlink" title="1.2 指令"></a>1.2 指令</h3><h4 id="CdkPortal"><a href="#CdkPortal" class="headerlink" title="CdkPortal"></a>CdkPortal</h4><p>指令版本 <code>TemplatePortal</code>，用于从 <code>&lt;ng-template&gt;</code> 获取一个Portal。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Portal1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">cdkPortal</span>&gt;</span>Portal2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件内部可以使用 <code>@ViewChild</code> 或 <code>@ViewChildren</code> 获取引用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChildren</span>(CdkPortal) templatPortals: QueryList&lt;CdkPortal&gt;;</span><br></pre></td></tr></table></figure><p><img src="/Users/luanmingyang/Desktop/luan/img/portal-cdkportal.png" width="540"></p><h4 id="CdkPortalOutlet"><a href="#CdkPortalOutlet" class="headerlink" title="CdkPortalOutlet"></a>CdkPortalOutlet</h4><p>用于添加 <code>PortalOutlet</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">"curPortal"</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="🌰-动态切换内容"><a href="#🌰-动态切换内容" class="headerlink" title="🌰 动态切换内容"></a>🌰 动态切换内容</h4><p><a href="https://stackblitz.com/edit/angular-hua49e?file=src%2Fapp%2Fportal%2Fportal-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><p>使用时需要先引入对应模块：</p><p><code>import {PortalModule} from &#39;@angular/cdk/portal&#39;;</code></p><p>首先设置一个插槽，用于放置动态内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">"curPortal"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要动态显示的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span>Portal1<span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">cdkPortal</span>&gt;</span>Portal2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">template</span>&gt;</span>Portal3<span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过改变 <code>curPortal</code> 切换显示内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PortalDemoComponent</span> </span>&#123;</span><br><span class="line">  curPortal: Portal&lt;any&gt;;</span><br><span class="line">  <span class="comment">// 获取动态内容引用</span></span><br><span class="line">  @ViewChildren(CdkPortal) templatPortals: QueryList&lt;CdkPortal&gt;;</span><br><span class="line">  @ViewChild(<span class="string">'template'</span>) template: TemplateRef&lt;any&gt;;</span><br><span class="line">  <span class="comment">// 切换</span></span><br><span class="line">  changePortal() &#123;</span><br><span class="line">    <span class="comment">// this.curPortal = xxx;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-常用class"><a href="#1-3-常用class" class="headerlink" title="1.3 常用class"></a>1.3 常用class</h3><h4 id="Portal"><a href="#Portal" class="headerlink" title="Portal"></a>Portal</h4><p>想要渲染在其它位置的内容，可以附加到 <code>PortalOutlet</code>，或从 <code>PortalOutlet</code> 分离。</p><p>可以通过 <code>isAttached</code> 属性判断是否已经被附加到某个 <code>PortalOutlet</code>。</p><h4 id="ComponentPortal"><a href="#ComponentPortal" class="headerlink" title="ComponentPortal"></a>ComponentPortal</h4><p>可以在attach时实例化某些组件</p><p><code>new ComponentPortal&lt;{}&gt;(component: ComponentType&lt;{}&gt;, viewContainerRef?: ViewContainerRef, injector?: Injector, componentFactoryResolver?: ComponentFactoryResolver): ComponentPortal&lt;{}&gt;</code></p><h4 id="TemplatePortal"><a href="#TemplatePortal" class="headerlink" title="TemplatePortal"></a>TemplatePortal</h4><p>表示一些嵌入的模版</p><p><code>new TemplatePortal&lt;{}&gt;(template: TemplateRef&lt;{}&gt;, viewContainerRef: ViewContainerRef, context?: {}): TemplatePortal&lt;{}&gt;</code></p><h4 id="DomPortalOutlet"><a href="#DomPortalOutlet" class="headerlink" title="DomPortalOutlet"></a>DomPortalOutlet</h4><p>用于将 Portal 附加到Angular应用程序上下文之外的任意DOM元素，也就是附加到 <code>&lt;app-root&gt;</code> 之外</p><h5 id="🌰-简单使用示例"><a href="#🌰-简单使用示例" class="headerlink" title="🌰 简单使用示例"></a>🌰 简单使用示例</h5><p><a href="https://stackblitz.com/edit/angular-dxl7fg?file=src%2Fapp%2Fportal%2Fportal-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">domPortalOutlet: DomPortalOutlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(</span><br><span class="line">    private viewContainerRef: ViewContainerRef,</span><br><span class="line">    private injector: Injector,</span><br><span class="line">    private componentFactoryResolver: ComponentFactoryResolver,</span><br><span class="line">    private appRef: ApplicationRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">createOutletOutApp() &#123;</span><br><span class="line">  <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  elem.innerHTML = <span class="string">'&amp;ltapp-root&amp;gt;外的插槽'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  <span class="keyword">this</span>.domPortalOutlet = <span class="keyword">new</span> DomPortalOutlet(elem, <span class="keyword">this</span>.componentFactoryResolver, <span class="keyword">this</span>.appRef, <span class="keyword">this</span>.injector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attachTemplatePortal() &#123;</span><br><span class="line">  <span class="keyword">this</span>.domPortalOutlet.attachTemplatePortal(<span class="keyword">this</span>.templatPortals.first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>new DomPortalOutlet(elem, this.componentFactoryResolver, this.appRef, this.injector);</code> 把elem 变成Angular可管理的插槽。</p><p><img width="360" src="/Users/luanmingyang/Desktop/luan/img/portal-DomPortalOutlet.png"></p><h5 id="DomPortalOutlet-在-Angular-Material-中的使用"><a href="#DomPortalOutlet-在-Angular-Material-中的使用" class="headerlink" title="DomPortalOutlet 在 Angular Material 中的使用"></a>DomPortalOutlet 在 Angular Material 中的使用</h5><p>在 Angular Material CDK Overlay 中，通过使用 DomPortalOutlet 在 <code>&lt;app-root&gt;</code> 之外创建 Overlay container</p><p><a href="https://github.com/angular/material2/blob/master/src/cdk/overlay/overlay.ts#L117" target="_blank" rel="noopener">源码</a> 部分代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pane = <span class="keyword">this</span>._createPaneElement(host);</span><br><span class="line"><span class="keyword">const</span> portalOutlet = <span class="keyword">this</span>._createPortalOutlet(pane);</span><br><span class="line"></span><br><span class="line">private _createPaneElement(host: HTMLElement): HTMLElement &#123;</span><br><span class="line">    <span class="keyword">const</span> pane = <span class="keyword">this</span>._document.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">    pane.id = <span class="string">`cdk-overlay-<span class="subst">$&#123;nextUniqueId++&#125;</span>`</span>;</span><br><span class="line">    pane.classList.add(<span class="string">'cdk-overlay-pane'</span>);</span><br><span class="line">    host.appendChild(pane);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pane;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private _createPortalOutlet(pane: HTMLElement): DomPortalOutlet &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._appRef) &#123;</span><br><span class="line">      <span class="keyword">this</span>._appRef = <span class="keyword">this</span>._injector.get&lt;ApplicationRef&gt;(ApplicationRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DomPortalOutlet(pane, <span class="keyword">this</span>._componentFactoryResolver, <span class="keyword">this</span>._appRef, <span class="keyword">this</span>._injector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Angular-CDK-之-Overlay"><a href="#2-Angular-CDK-之-Overlay" class="headerlink" title="2. Angular CDK 之 Overlay"></a>2. Angular CDK 之 Overlay</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Overlay 提供了一种在屏幕上打开浮动面板的方法，即在 <code>&lt;app-root&gt;</code> 之外创建叠加层，并且该叠加层仍在 Angular 控制范围内。</p><p>主要用于构建公共组件，Modal、Tooltip、Menu、Select等组件的构建过程中都可以选择使用 Overlay。</p><p>使用时需要先引入对应模块：</p><p><code>import {OverlayModule} from &#39;@angular/cdk/overlay&#39;;</code></p><p>通过调用 <code>overlay.create()</code> 创建一个 <code>OverlayRef</code> 实例，<code>OverlayRef</code> 是一个 <code>PortalOutlet</code>，一旦被创建，可以通过附加 <code>Portal</code> 为其添加内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> overlayRef = overlay.create();</span><br><span class="line"><span class="keyword">const</span> userProfilePortal = <span class="keyword">new</span> ComponentPortal(UserProfile);</span><br><span class="line">overlayRef.attach(userProfilePortal);</span><br></pre></td></tr></table></figure><p>创建时 <code>OverlayRef</code> 时可以提供可选的配置对象 <code>OverlayConfig</code>。</p><p><a href="https://material.angular.io/cdk/overlay/api#Overlay" target="_blank" rel="noopener">Overlay API</a></p><h3 id="2-2-OverlayRef"><a href="#2-2-OverlayRef" class="headerlink" title="2.2 OverlayRef"></a>2.2 OverlayRef</h3><p>使用服务创建的Overlay引用，用于对其操纵或处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverlayDemoComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  overlayRef: OverlayRef;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(private overlay: Overlay) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img width="400" src="/Users/luanmingyang/Desktop/luan/img/overlay-create.png"></p><h3 id="2-3-OverlayConfig"><a href="#2-3-OverlayConfig" class="headerlink" title="2.3 OverlayConfig"></a>2.3 OverlayConfig</h3><p>创建Overlay时使用的配置对象。</p><p>属性：</p><ul><li>hasBackdrop：是否使用遮罩</li><li>backdropClass：遮罩的classname，使得我们可以自定义遮罩的样式</li><li>positionStrategy：PositionStrategy 指定位置策略</li><li>scrollStrategy：ScrollStrategy 指定在打开时处理滚动事件的策略</li><li>direction：文本的方向</li><li>panelClass：指定 Overlay 类名</li><li>disposeOnNavigation：当用户在前进/后退时是否应该丢弃。注意，通常不包括单击链接（除非在使用<code>HashLocationStrategy</code>）。</li><li>width/minWidth/maxWidth：定义宽度。类型为number时，则默认单位为px</li><li>height/minHeight/maxHeight：定义高度。类型为number时，则默认单位为px</li></ul><p>可以通过 OverlayRef 指定 backdrop 的点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.overlayRef.backdropClick().subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.detach();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-4-两种位置策略"><a href="#2-4-两种位置策略" class="headerlink" title="2.4 两种位置策略"></a>2.4 两种位置策略</h3><ul><li><p>GlobalPositionStrategy</p><p>使用此策略，叠加层被赋予相对于浏览器视口的显式位置，与其他元素无关。</p></li><li><p>ConnectedPositionStrategy（弃用）</p><p>使用此策略，叠加层被赋予相对于某个元素的隐式位置。相对位置是根据Overlay上的点相对原点定义的。例如，下拉列表将原点的左下角连接到叠加层的左上角。</p></li><li><p>FlexibleConnectedPositionStrategy</p><p>使用此策略，叠加层被赋予相对于某个元素的隐式位置。相对位置是根据Overlay上的点相对原点定义的。例如，下拉列表将原点的左下角连接到叠加层的左上角。</p></li></ul><h3 id="2-5-四种滚动策略"><a href="#2-5-四种滚动策略" class="headerlink" title="2.5 四种滚动策略"></a>2.5 四种滚动策略</h3><ul><li><p>NoopScrollStrategy</p><p>默认，什么都不做。</p></li><li><p>CloseScrollStrategy</p><p>滚动时会自动关闭叠加层。</p></li><li><p>BlockScrollStrategy</p><p>将在打开时阻止页面滚动。</p></li><li><p>RepositionScrollStrategy</p><p>滚动时会重新定位覆盖元素，会对滚动产生一些性能影响。</p></li></ul><h3 id="🌰-示例"><a href="#🌰-示例" class="headerlink" title="🌰 示例"></a>🌰 示例</h3><p><a href="https://stackblitz.com/edit/angular-zmcuh9?file=src%2Fapp%2Foverlay%2Foverlay-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><p>使用 Overlay 需要先引入必要的样式</p><p><code>@import &#39;~@angular/cdk/overlay-prebuilt.css&#39;;</code></p><h4 id="1-创建菜单"><a href="#1-创建菜单" class="headerlink" title="1. 创建菜单"></a>1. 创建菜单</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createMenu() &#123;</span><br><span class="line">  <span class="keyword">const</span> strategy = <span class="keyword">this</span>.overlay.position()</span><br><span class="line">    .flexibleConnectedTo(<span class="keyword">this</span>.createMenuBtn).withPositions([&#123;</span><br><span class="line">      originX: <span class="string">'center'</span>,</span><br><span class="line">      originY: <span class="string">'bottom'</span>,</span><br><span class="line">      overlayX: <span class="string">'center'</span>,</span><br><span class="line">      overlayY: <span class="string">'top'</span></span><br><span class="line">    &#125;]);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create(&#123;</span><br><span class="line">    positionStrategy: strategy</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.attach(<span class="keyword">new</span> TemplatePortal(<span class="keyword">this</span>.menuTpl, <span class="keyword">this</span>.viewContainerRef));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>overlay.position()</code> 方法获取一个 <code>OverlayPositionBuilder</code> ，通过它来配置位置策略。</p><p>通过调用 <code>flexibleConnectedTo(elementRef)</code> 方法创建位置策略 <code>FlexibleConnectedPositionStrategy</code></p><p><img width="100" src="/Users/luanmingyang/Desktop/luan/img/overlay-menu.png"></p><h4 id="2-创建弹出框"><a href="#2-创建弹出框" class="headerlink" title="2. 创建弹出框"></a>2. 创建弹出框</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createDialog() &#123;</span><br><span class="line">  <span class="keyword">const</span> strategy = <span class="keyword">this</span>.overlay.position().global().centerHorizontally().centerVertically();</span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">new</span> OverlayConfig(&#123;</span><br><span class="line">    hasBackdrop: <span class="literal">true</span>, <span class="comment">// 使用backdrop</span></span><br><span class="line">    positionStrategy: strategy</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create(config);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.attach(<span class="keyword">new</span> TemplatePortal(<span class="keyword">this</span>.dialogTpl, <span class="keyword">this</span>.viewContainerRef));</span><br><span class="line">  <span class="comment">// 绑定backdrop点击事件</span></span><br><span class="line">  <span class="keyword">this</span>.overlayRef.backdropClick().subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.overlayRef.detach();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>global()</code> 方法创建位置策略 <code>GlobalPositionStrategy</code></p><p><img width="400" src="/Users/luanmingyang/Desktop/luan/img/overlay-dialog.png"></p><h2 id="3-Angular-CDK-之-a11y"><a href="#3-Angular-CDK-之-a11y" class="headerlink" title="3. Angular CDK 之 a11y"></a>3. Angular CDK 之 a11y</h2><h3 id="3-1-a11y-概述"><a href="#3-1-a11y-概述" class="headerlink" title="3.1 a11y 概述"></a>3.1 a11y 概述</h3><p>a11y 提供了许多改进可访问性的工具。</p><p>使用时需要先引入对应模块：</p><p><code>import {A11yModule} from &#39;@angular/cdk/a11y&#39;;</code></p><h3 id="3-2-FocusTrap"><a href="#3-2-FocusTrap" class="headerlink" title="3.2 FocusTrap"></a>3.2 FocusTrap</h3><p>旨在用于为对话框等<strong>焦点必须受到约束</strong>的组件创建可访问的体验。</p><h4 id="3-2-1-指令"><a href="#3-2-1-指令" class="headerlink" title="3.2.1 指令"></a>3.2.1 指令</h4><p><code>cdkTrapFocus</code> 在区域内捕获焦点的指令。</p><p>可以显式地声明聚焦的区域：</p><p><code>cdkFocusInitial</code> 指定在初始化区域时将获得焦点的元素。</p><p><code>cdkFocusRegionStart</code> 与 <code>cdkFocusRegionEnd</code> 定义焦点将被捕获的区域。使用Tab键时，焦点将在此区域中移动并在两端环绕。</p><h4 id="3-2-2-FocusTrapFactory"><a href="#3-2-2-FocusTrapFactory" class="headerlink" title="3.2.2 FocusTrapFactory"></a>3.2.2 FocusTrapFactory</h4><p>用于根据给定的元素创建一个焦点捕获区域。</p><p><code>focusTrap = focusTrapFactory.create(element);</code></p><h4 id="3-2-3-FocusTrap"><a href="#3-2-3-FocusTrap" class="headerlink" title="3.2.3 FocusTrap"></a>3.2.3 FocusTrap</h4><p>允许在DOM元素中捕获焦点的类。</p><p>它假定Tab键顺序与DOM顺序相同，但实际上这是不一定的，如 tabIndex &gt; 0 或 指定了 flex order 等情况。</p><ul><li>focusFirstTabbableElement()   聚焦区域内的第一个可捕捉元素</li><li>focusFirstTabbableElementWhenReady()</li><li>focusInitialElement()  </li><li>focusInitialElementWhenReady()</li><li>focusLastTabbableElement()</li><li>focusLastTabbableElementWhenReady()</li></ul><h4 id="3-2-4-实际中的使用"><a href="#3-2-4-实际中的使用" class="headerlink" title="3.2.4 实际中的使用"></a>3.2.4 实际中的使用</h4><p>以公共组件 Dialog 为例，需要在 Dialog 打开时，将焦点约束在 Dialog 区域内部。</p><p>主要分为三步：</p><ol><li>打开 Dialog 时，保存当前获得焦点的元素</li><li>使 Dialog 获得焦点，并将焦点约束在 Dialog 内</li><li>Dialog 关闭时，将焦点恢复到之前聚焦的元素上</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Inject &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FocusTrap, FocusTrapFactory &#125; <span class="keyword">from</span> <span class="string">'@angular/cdk/a11y'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DOCUMENT &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">    focusTrap: FocusTrap;</span><br><span class="line">    prevFocusedElem: HTMLElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        private elementRef: ElementRef,</span><br><span class="line">        private focusTrapFactory: FocusTrapFactory,</span><br><span class="line">        @Inject(DOCUMENT) private document: any) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 Dialog open 之前聚焦的元素</span></span><br><span class="line">    savePrevFocusedElement() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.document) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevFocusedElem = <span class="keyword">this</span>.document.activeElement <span class="keyword">as</span> HTMLElement;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.elementRef.nativeElement.focus) &#123;</span><br><span class="line">                <span class="comment">// 元素可能无法立即聚焦</span></span><br><span class="line">                <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.elementRef.nativeElement.focus();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将焦点限制在 Dialog 内部</span></span><br><span class="line">    trapFocus() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.focusTrap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.focusTrap = <span class="keyword">this</span>.focusTrapFactory.create(<span class="keyword">this</span>.elementRef.nativeElement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.focusTrap.focusInitialElementWhenReady();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dialog close 时恢复原来聚焦的元素</span></span><br><span class="line">    restoreFocus() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prevFocusedElem &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">this</span>.prevFocusedElem.focus === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevFocusedElem.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.focusTrap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.focusTrap.destroy();</span><br><span class="line">            <span class="keyword">this</span>.focusTrap = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Angular CDK 的部分功能，主要包括了三部分：Portal、Overlay、a11y/FocusTrap。&lt;/p&gt;
    
    </summary>
    
      <category term="luanmingyang" scheme="http://xgfe.github.io/categories/luanmingyang/"/>
    
    
      <category term="angularjs" scheme="http://xgfe.github.io/tags/angularjs/"/>
    
      <category term="Angular CDK" scheme="http://xgfe.github.io/tags/Angular-CDK/"/>
    
  </entry>
  
  <entry>
    <title>mysql通信协议浅解</title>
    <link href="http://xgfe.github.io/2018/12/21/rongweiwei/mysql-protocol/"/>
    <id>http://xgfe.github.io/2018/12/21/rongweiwei/mysql-protocol/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>计划通过本地代理远程mysql，尝试实现透明缓存中间件功能这个需求，在实现过程中，需要对mysql协议的请求和下发包进行解析以便进一步处理，网络上有大量关于mysql协议的文章，但过于分散，而且mysql协议在4.1版本做了大升级，本文将涉及到的一部分整理汇总，资料来自mysql官网，网络blog，和npm上的mysql模块源码。</p><p>代码部分经过nodejs的mysql模块和php的mysqli模块验证。</p><p>此次只作为对mysql协议熟悉的练习，对数据变动自动清理相应缓存建议还是使用基于binlog的解析,然后通过消息机制更新。</p><a id="more"></a><hr><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>mysql链接分为TCP握手链接，服务端对客户端认证，数据交互，断开链接几个阶段。<br>服务器启动后，会使用 TCP 监听一个本地端口，当客户端的连接请求到达时，就会执行三段握手以及 MySQL 的权限验证；验证成功后，客户端开始发送请求，服务器会以响应的报文格式返回数据；当客户端发送完成后，会发送一个特殊的报文，告知服务器已结束会话。</p><p>MySQL 定义了几种包类型，A) 客户端-&gt;服务器，登录时的 auth 包、执行 SQL 时的 CMD 包；B) 服务器-&gt;客户端，登录时的握手包、数据包、数据流结束包、成功包(OK Packet)、错误信息包。</p><p>协议定义了基本的数据类型，如 int、string 等；数据的传送格式等。</p><h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h3><p>当server端和client端数据交互时，如果数据包size大于2^24时，要将包拆成多个；<br>每个包由header和payload两部分组成；</p><h3 id="认证阶段"><a href="#认证阶段" class="headerlink" title="认证阶段"></a>认证阶段</h3><pre><code>服务端 -&gt; 客户端：发送握手初始化包 (Handshake Initialization Packet)。客户端 -&gt; 服务端：发送验证包 (Client Authentication Packet)。服务端 -&gt; 客户端：认证结果消息</code></pre><p>mysql的认证过程相对复杂，这里简单介绍4.1版本之后的认证过程（计划功能中对这部分请求可以透明透给远程mysql，没有必要进行处理，以下内容摘自网络）。</p><ol><li><p>服务器发送随机字符串 (scramble) 给客户端。</p></li><li><p>客户端作如下计算，然后客户端将 token 发送给服务端。</p><blockquote><p>stage1_hash = SHA1(明文密码)</p></blockquote><blockquote><p>token = SHA1(scramble + SHA1(stage1_hash)) XOR stage1_hash</p></blockquote></li><li><p>服务端作如下计算，比对 SHA1(stage1_hash) 和 mysql.user.password 是否相同</p><blockquote><p>stage1_hash = token XOR SHA1(scramble + mysql.user.password)<br>server -&gt; client， client-&gt; server 包类型</p></blockquote><p> 校验时，只需要 SHA1(stage1_hash) 与 mysql.user.password 比较一下即可</p></li></ol><p>handshake包(protocol41)</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>protocol_version</td></tr><tr><td>n</td><td>(Null-Terminated String)   server_version</td></tr><tr><td>4</td><td>thread_id</td></tr><tr><td>8</td><td>scramble_buff</td></tr><tr><td>1</td><td>(filler) always 0x00</td></tr><tr><td>2</td><td>server_capabilities</td></tr><tr><td>1</td><td>server_language</td></tr><tr><td>2</td><td>server_status</td></tr><tr><td>13</td><td>(filler) always 0x00 …</td></tr><tr><td>13</td><td>rest of scramble_buff (4.1)</td></tr></tbody></table><h3 id="获得use-db"><a href="#获得use-db" class="headerlink" title="获得use db"></a>获得use db</h3><p> 对本次需求只需要取出初始化mysql链接的时候会初始化使用哪个库(use database;),需要从包里解出，其它部分忽略。</p><pre><code>function parseHandShake(buff){    let _check_pos = buff.indexOf(Buffer.alloc(23,0x00));    if (_check_pos &gt; 0){        //protocol41        buff =  buff.slice(_check_pos + 23);        protocol41 = true;    }    //find user field end    _check_pos = buff.indexOf(0x00);    buff =  buff.slice(_check_pos + 1);    if (protocol41) {        buff =  buff.slice(21);         } else {        buff =  buff.slice(10);         }    _check_pos = buff.indexOf(0x00);    let default_db = buff.slice(0, _check_pos).toString(); }</code></pre><hr><h2 id="query请求-封包"><a href="#query请求-封包" class="headerlink" title="query请求 封包"></a>query请求 封包</h2><p>client到server的包（Command Packet ），由两部分构成：header 和 payload。header包括3位整数表示payload长度，1位整数表示顺序号；payload包括1位COM标识符和请求sql语句</p><table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>int<3></3></td><td>payload_length</td><td>payload的长度</td></tr><tr><td>int<1></1></td><td>sequence_id</td><td>顺序号，每次从0开始</td></tr><tr><td>string<var></var></td><td>payload</td><td>COM + sql ，COM_QUERY 标识符为0x03</td></tr></tbody></table><p>Example:</p><table><thead><tr><th>header</th><th>sequence</th><th>Description</th></tr></thead><tbody><tr><td>01 00 00</td><td>00</td><td>03 xx xx…</td></tr><tr><td>length 1</td><td>sequence_id 0</td><td>payload [0x03,Buffer from sql string …]</td></tr></tbody></table><p>部分代码</p><pre><code> var MAX_PACKET_LENGTH = Math.pow(2, 24) - 1; var buffer = Buffer.from(sql); for (var packet = 0; packet &lt; packets; packet++) {        var isLast = (packet + 1 === packets);    var packetLength = (isLast)           ? length % MAX_PACKET_LENGTH           : MAX_PACKET_LENGTH;       var packetNumber = incrementPacketNumber();       this.writeUnsignedNumber(3, packetLength);       this.writeUnsignedNumber(1, packetNumber);       var start = packet * MAX_PACKET_LENGTH;       var end   = start + packetLength;       this.writeBuffer(buffer.slice(start, end));}</code></pre><p>writeUnsignedNumber用来把包长度和序号写入packet header</p><pre><code>function writeUnsignedNumber(bytes, value) {       for (var i = 0; i &lt; bytes; i++) {       this._buffer[this._offset++] = (value &gt;&gt; (i * 8)) &amp; 0xff       }}</code></pre><p>当header的长度小于MAX_PACKET_LENGTH时表示包传输完成，极端情况下会多传个空包过去（正好整分）。</p><p>通常sql不长的情况下，只需要一个包就可以。</p><pre><code>ComQueryPacket.prototype.write = function write(){    let _sql_buff = Buffer.from(this.sql),        _cmd_len = Buffer.byteLength(this.sql),        _buff = Buffer.alloc(_cmd_len + 1 + 3 + 1);        _sql_buff.copy(_buff , 5);    this._buffer = _buff;    this.writeUnsignedNumber(4, _cmd_len+1);    this.writeUnsignedNumber(1, this.command);    return this._buffer; }</code></pre><hr><h2 id="query返回-解包"><a href="#query返回-解包" class="headerlink" title="query返回 解包"></a>query返回 解包</h2><p>从服务器发往客户端的数据包有四种：成功报告包以及错误消息包，数据结束包、数据包。</p><ul><li>0x00: Packets.OkPacket</li><li>0xff: Packets.ErrorPacket</li><li>0xfe: Packets.EofPacket</li><li>其它</li></ul><h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><pre><code>let first = data.readUInt8(4)，    //探测包类型    last = data.readUInt8(Buffer.byteLength(data) -1); //用来检测字符串类型数据是否传输完成if (first === 0xff) {    //查询错误} else if (first === 0x00) {    //查询OK，这里可以解析握手包等} else {    //数据包    //NullTerminatedString（Null结尾方式）: 字符串以遇到Null作为结束标志，相应的字节为00    if (last === 0x00 ){         //检查数据包中列信息和数据信息是否都接收完成    }}</code></pre><h3 id="OK-Packet"><a href="#OK-Packet" class="headerlink" title="OK Packet"></a>OK Packet</h3><p>Payload</p><table><thead><tr><th>相对包内容的位置</th><th>长度（字节）</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>包头标识</td><td>0x00 代表这是一个OK 包</td></tr><tr><td>1</td><td>rows_len</td><td>影响行数</td><td>相应操作影响的行数，比如一个Update操作的记录是5条，那么这个值就为5</td></tr><tr><td>1 + rows_len</td><td>id_len</td><td>自增id</td><td>插入一条记录时，如果是自增id的话，返回的id值</td></tr><tr><td>1 + rows_len + id_len</td><td>2</td><td>服务器状态</td><td>用于表示服务器状态，比如是否是事务模式或者自动提交模式</td></tr><tr><td>3 + rows_len + id_len</td><td>2</td><td>警告数</td><td>上次命令引起的警告数</td></tr><tr><td>5 + rows_len + id_len</td><td>msg_len</td><td>额外信息</td><td>此次操作的一些额外信息</td></tr></tbody></table><h3 id="Error-Packet"><a href="#Error-Packet" class="headerlink" title="Error Packet"></a>Error Packet</h3><p>Payload</p><table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>int<1> [ff]</1></td><td>header</td><td>header of the ERR packet</td></tr><tr><td>int<2></2></td><td>error_code</td><td>错误码</td></tr><tr><td>if capabilities &amp; CLIENT_PROTOCOL_41 {</td></tr><tr><td>string[1]</td><td>sql_state_marker</td><td># marker of the SQL State</td></tr><tr><td>string[5]</td><td>sql_state</td><td>SQL State</td></tr><tr><td>} </td></tr><tr><td>string<eof></eof></td><td>error_message</td><td>报错信息</td></tr></tbody></table><h3 id="Result-Set-Packet"><a href="#Result-Set-Packet" class="headerlink" title="Result Set Packet"></a>Result Set Packet</h3><p>Result Set包产生于我们每次数据库执行需要返回结果集的时候，Server端发送给我们的包，比如平常的SELECT,SHOW等命令，Result Set包相对比较复杂，查询结果的完整内容由：<br>列数量信息 + 列包 + EOF包 + 行包 + EOF包，这五部分组成。</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>Result Set Header</td><td>返回数据的字段(列)数量</td></tr><tr><td>Field</td><td>返回数据的列信息（多个）</td></tr><tr><td>EOF</td><td>列结束</td></tr><tr><td>Row Data</td><td>行数据（多个）</td></tr><tr><td>EOF</td><td>数据结束</td></tr></tbody></table><p>例子 SELECT @@version_comment查询的返回结果：</p><pre><code>01 00 00 01 01|27 00 00    02 03 64 65 66 00 00 00    .....&apos;....def...11 40 40 76 65 72 73 69    6f 6e 5f 63 6f 6d 6d 65    .@@version_comme6e 74 00 0c 08 00 1c 00    00 00 fd 00 00 1f 00 00|   nt..............05 00 00 03 fe 00 00 02    00|1d 00 00 04 1c 4d 79    ..............My53 51 4c 20 43 6f 6d 6d    75 6e 69 74 79 20 53 65    SQL Community Se72 76 65 72 20 28 47 50    4c 29|05 00 00 05 fe 00    rver (GPL)......00 02 00                                              ...</code></pre><p>VERSION 4.0</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>n (Length Coded String)</td><td>table</td></tr><tr><td>n (Length Coded String)</td><td>name</td></tr><tr><td>4 (Length Coded Binary)</td><td>length</td></tr><tr><td>2 (Length Coded Binary)</td><td>type</td></tr><tr><td>2 (Length Coded Binary)</td><td>flags</td></tr><tr><td>1</td><td>decimals</td></tr><tr><td>n (Length Coded Binary)</td><td>default</td></tr></tbody></table><p>VERSION 4.1</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>n (Length Coded String)</td><td>catalog</td></tr><tr><td>n (Length Coded String)</td><td>db</td></tr><tr><td>n (Length Coded String)</td><td>table</td></tr><tr><td>n (Length Coded String)</td><td>org_table 原表名</td></tr><tr><td>n (Length Coded String)</td><td>name</td></tr><tr><td>n (Length Coded String)</td><td>org_name 原字段名</td></tr><tr><td>(filler)            0c</td><td></td></tr><tr><td>charsetnr           08 00</td><td></td></tr><tr><td>n (Length Coded String)</td><td>length</td></tr><tr><td>n (Length Coded String)</td><td>type</td></tr><tr><td>n (Length Coded String)</td><td>flags</td></tr><tr><td>n (Length Coded String)</td><td>decimals</td></tr><tr><td>(filler) 00 00</td></tr></tbody></table><p> 处理代码：</p><pre><code>/** 解析字段信息* @param Buffer * @result Object */function parseColDef(buff){    let _stack = _parseLine(buff);    if (_stack.length &lt; 2) return false;    if (!_stack) return false;    if (_stack[0] === &apos;def&apos;){        //protocol41        return {            &apos;db&apos; : _stack[1],            &apos;table&apos; : _stack[2],            &apos;table_full&apos; : _stack[3],            &apos;field&apos; : _stack[4],            &apos;field_full&apos; : _stack[5]        };        }else{        return {            &apos;table&apos; : _stack[0],            &apos;field&apos; : _stack[1],        };    }}/** 解析行数据* @param Buffer * @result Array */function parseColVal(buff){    let _stack = _parseLine(buff);    return _stack;}function _parseLine(buff){    let _stack = [];    for(let i=0,j=buff.length ; i &lt; j ; i++){        let _len = buff[i].toString() * 1;        let _content = buff.slice(i+1, i+ 1 + _len  );        _stack.push(_content.toString());        i += _len;      }    return _stack;}function Parser(options) {    options = options || {};    this.reset(options);}Parser.prototype.reset = function(options){    this._header = [];    this._body = [];    this._parsed_columns = [];    this._parsed_col_vals = [];    this.header_len = 4;    this._head_set = false;    this._body_set = false;    this._reset();}Parser.prototype._reset = function(){    this._buffer = Buffer.alloc(0);    this._offset = 0;}//将字段部分和数据部分分开存放Parser.prototype._put = function(chunk){    if (0 === chunk.length) return;    if (this._head_set){        this._body.push(chunk);    }else{        this._header.push(chunk);    }}//获得result packetParser.prototype.write = function(chunk ,to_parse){    if (this._body_set) return false;    this._buffer = Buffer.concat([this._buffer,chunk]);    this._offset = 0;    this._process(to_parse);}Parser.prototype._process = function(to_parse){    let _header_len = this.header_len;    while(true){        if (this._buffer.length === 0 ){            break;        }        let _len = this.parseUnsignedNumber(3),            _number = this.parseUnsignedNumber(1);        if ((_len + _header_len) &gt; this._buffer.length){            break;        }        let _piece = this._buffer.slice(0,_len + _header_len),             _first = _piece.readUInt8(4);        this._put(_piece);        if (0xfe === _first){            if (!this._head_set){                this._head_set = true;                    this._parsed_col_vals = [];                for (let _m = 0,_n = this._parsed_columns.length; _m &lt; _n ; _m++){                    this._parsed_col_vals.push([]);                }            }else{                this._body_set = true;            }        } else if(to_parse){            if (!this._head_set){                let _column = parseColDef(_piece.slice(_header_len));                if (_column){                    this._parsed_columns.push(_column.field);                }            }else{                let _col_val = parseColVal(_piece.slice(_header_len));                for(let _m=0,_n=_col_val.length; _m &lt; _n;_m++){                    this._parsed_col_vals[_m].push(_col_val[_m]);                    }             }        }        this._buffer = this._buffer.slice(_piece.length );        this._offset = 0;    }}//读取解析后数据Parser.prototype.read = function(){    return {        head : this._header,        body : this._body,        headed : this._head_set,        bodyed : this._body_set,        columns : this._parsed_columns,        columns_vals : this._parsed_col_vals    }}//写入数字类型信息Parser.prototype.parseUnsignedNumber = function parseUnsignedNumber(bytes) {    if (bytes === 1) {        return this._buffer[this._offset++];    }    var buffer = this._buffer;    var offset = this._offset + bytes - 1;    var value  = 0;    if (bytes &gt; 4) {        var err    = new Error(&apos;parseUnsignedNumber: Supports only up to 4 bytes&apos;);        err.offset = (this._offset - this._packetOffset - 1);        err.code   = &apos;PARSER_UNSIGNED_TOO_LONG&apos;;        throw err;    }    while (offset &gt;= this._offset) {        value = ((value &lt;&lt; 8) | buffer[offset]) &gt;&gt;&gt; 0;        offset--;    }    this._offset += bytes;    return value;}; </code></pre><hr><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://dev.mysql.com/doc/internals/en/text-protocol.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/text-protocol.html</a><br><a href="https://blog.csdn.net/caisini_vc/article/details/5356136" target="_blank" rel="noopener">https://blog.csdn.net/caisini_vc/article/details/5356136</a><br><a href="https://jin-yang.github.io/post/mysql-protocol.html" target="_blank" rel="noopener">https://jin-yang.github.io/post/mysql-protocol.html</a></p><p>HandShake:<br><a href="https://my.oschina.net/alchemystar/blog/833598" target="_blank" rel="noopener">https://my.oschina.net/alchemystar/blog/833598</a> ,  <a href="https://my.oschina.net/alchemystar/blog/833598" target="_blank" rel="noopener">https://my.oschina.net/alchemystar/blog/833598</a></p><p>com标识:<br><a href="https://dev.mysql.com/doc/internals/en/text-protocol.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/text-protocol.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;计划通过本地代理远程mysql，尝试实现透明缓存中间件功能这个需求，在实现过程中，需要对mysql协议的请求和下发包进行解析以便进一步处理，网络上有大量关于mysql协议的文章，但过于分散，而且mysql协议在4.1版本做了大升级，本文将涉及到的一部分整理汇总，资料来自mysql官网，网络blog，和npm上的mysql模块源码。&lt;/p&gt;
&lt;p&gt;代码部分经过nodejs的mysql模块和php的mysqli模块验证。&lt;/p&gt;
&lt;p&gt;此次只作为对mysql协议熟悉的练习，对数据变动自动清理相应缓存建议还是使用基于binlog的解析,然后通过消息机制更新。&lt;/p&gt;
    
    </summary>
    
      <category term="rongweiwei" scheme="http://xgfe.github.io/categories/rongweiwei/"/>
    
    
      <category term="nodejs" scheme="http://xgfe.github.io/tags/nodejs/"/>
    
      <category term="mysql" scheme="http://xgfe.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 React-Native 与 Redux 数据流</title>
    <link href="http://xgfe.github.io/2018/11/25/juga/%E6%B5%85%E8%B0%88React-Native%E4%B8%8ERedux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://xgfe.github.io/2018/11/25/juga/浅谈React-Native与Redux数据流/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.647Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。</p><a id="more"></a><h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React-Native 介绍"></a>React-Native 介绍</h4><ul><li><p>React-Native 在官网上给的定义是：使用 JavaScript 和 React 编写原生移动应用。在设计原理上是和 React 一致的，可以通过生命是的组件机制来搭建丰富多彩的用户界面。RN 产出的不是“网页应用”或者“HTML5应用”，RN 所产出的其实是一个真正的移动应用。从感受上来说和 Objective-C 或 Java 编写的应用基本是一样的。</p></li><li><p><a href="https://reactnative.cn/" target="_blank" rel="noopener">RN官网</a></p></li></ul><h4 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h4><ul><li><p>官网上有教大家如何构建一个新的 React-Native 应用，这里就不多说了，这里直接切入组件的开发。可以在项目里面新建一个 Component 组件文件夹，专门用来存放组件。在该文件家里面建一个 TestComponen 子文件夹，然后在此子文件下面再建 TestComponent.js 和TestComponentStyle.js 两个文件夹，组件的逻辑写在TestComponent.js 文件下，样式写在 TestComponentStyle.js 文件下。<br><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc82f8j20hk03uaaa.jpg" alt="文件结构"></p></li><li><p>JS文件分析</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">//引入Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  Button</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>; <span class="comment">//引入RN原生组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;Style&#125; <span class="keyword">from</span> <span class="string">'./TestComponentStyle'</span>; <span class="comment">//引入样式</span></span><br></pre></td></tr></table></figure><ul><li>简单的计数器实现</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc2m1qj207g010dfq.jpg" alt="计数器"></p><p>点击加号数字动态变化 +1，点击减号数字动态 -1。首先这个组件由一个 Text 和两个  Button 组件组成，其中 Text 组件中有两个变量，children 作为对外暴露的属性，写在 this.props 里面，state 是组件内部的可变化的状态，写在 this.state 里面。<br>官网上是这样描述 props 和 state：我们使用两种数据来控制一个组件：props 和 state.props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用 state 。<br>这里先介绍一下 render 函数部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; <span class="comment">//渲染函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">      children</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props; <span class="comment">//组件对外暴露的属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state; <span class="comment">//组件内部的状态</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="comment">//返回要渲染的组件</span></span><br><span class="line">      &lt;View style=&#123;Style.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;Style.txt&#125;&gt;&#123;<span class="string">`<span class="subst">$&#123;children&#125;</span> <span class="subst">$&#123;num&#125;</span>`</span>&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button title=&#123;'-'&#125; color=&#123;'red'&#125; onPress=&#123;this.clickBtnSub&#125;/</span>&gt;</span><br><span class="line">        &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;<span class="keyword">this</span>.clickBtnAdd&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件的结构由一个 View 组件包裹一个 Text ，两个 Button 组件。Text 组件为展示的数字名和数字大小，Button 则是两个加减按钮。</p><p>然后可以看到 Style.container 和 Style.txt 都是引自  TestComponentStyle.js 文件。接下来我们看一下该文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;StyleSheet&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Style = StyleSheet.create(&#123;</span><br><span class="line"><span class="comment">// styles</span></span><br><span class="line">  container: &#123;</span><br><span class="line">    flexDirection: <span class="string">'row'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'space-around'</span>,</span><br><span class="line">    width: <span class="number">200</span>,</span><br><span class="line">    height: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  txt: &#123;</span><br><span class="line">    fontSize: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个是 RN 样式的基本写法，这个文件专门放 css 层的东西。这里要注意的是 css 的属性值接受的是字符串形式，在 RN 里面的 css 很多样式的值都被阉割了，所以这点要特别注意，这里有个推荐的网站可以看常用的RN样式：<br><a href="https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html" target="_blank" rel="noopener">RN css 样式</a></p><p>然后可以看到 Button 组件里面分别有一个点击事件。clickBtnSub 事件处理减 1，clickBtnAdd 处理加 1。<br>这里我推荐是使用箭头函数来定义函数，就可以在该组件的作用域里面直接调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickBtnSub = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num - <span class="number">1</span>&#125;);<span class="comment">//调用setState()函数，改变组件内部的状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> clickBtnAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num + <span class="number">1</span>&#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h4><p>组件写好之后可以引入到某个功能模块中使用。这里我们可以建一个 TestModule 文件夹来存放模块文件，里面可以建这么几个文件。如下图<br><img src="https://wx2.sinaimg.cn/mw690/ba56005dgy1fxkcvcd0coj20ia08o755.jpg" alt="文件结构"><br>接下来我们一个一个来介绍这几个文件的用处。<br>其实上面的组件计数器，除了使用 setState 来改变数字还可以使用 Redux 来完成这件事。<br>接下来就让我们来看看如何使用 Redux 完成</p><ul><li>TestModule.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import部分省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _renderTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text&gt;计数器&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;num&#125; = this.props.data /</span><span class="regexp">/从store取得的数据，在reducer里面初始化</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*引入计数器组件*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View style=&#123;Style.container&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;TestComponent children=&#123;'数字: '&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*使用Redux完成的计数器*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;Text&gt;&#123;num&#125;&lt;/</span>Text&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'-'</span>&#125; color=&#123;<span class="string">'red'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.sub(num)&#125; /&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.add(num)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  (state) =&gt; (&#123; <span class="comment">//state其实就是store.getState()，得到数据</span></span><br><span class="line">    data: state.modules[CONSTANTS.NAME]</span><br><span class="line">  &#125;),</span><br><span class="line">  (dispatch) =&gt; (&#123; <span class="comment">//dispatch是一个发布器他需要接受一个对象用于触发reducer</span></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    add: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.add(num)),</span><br><span class="line">    sub: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.sub(num))</span><br><span class="line">  &#125;)</span><br><span class="line">)(TestModule);</span><br></pre></td></tr></table></figure></li></ul><p>模块的主要页面内容都是写在这个文件里面，这里我们直接从 components 引入了 TestComponent 组件进行使用。直接将组件当成标签名使用 <testcomponent>。这就是自定义组件方便的地方。中间可以看到组件渲染不一定要都放在 render() 里面，可以利用一个渲染函数，单独抽出来，这样可以让程序的结构上看起来更加明了，不要让所有的子组件都堆积在 render() 函数中。当然如果抽出来的组件内容太少，就没必要抽了。<br>这个文件的最下面 connect 函数是 Provider 提供的一种 store 注入方式，其中封装了两个函数，第一个函数其实是 store.getState() ，是从 store 得到数据的。<br>第二个函数 dispatch 是一个触发器，在里面写 action 函数来触发 reducer 来对数据进行所需要的操作。dispatch 触发 TestModuleActions.js 里面的函数。下面就介绍一下 TestModuleActions.js 文件<br>这里我们写了一个加一个减函数，接着在 actions.js 文件里定义这两个 action 函数。</testcomponent></p><ul><li>TestModuleActios.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ADD,</span><br><span class="line">  SUB</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ADD, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sub = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: SUB, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件主要是写 actions 的文件，定义 action，dispatch中根据 type 类型去 TestModuleReducers.js 那处理数据。通过 payload 把数据传到 reducer 里面。</p><ul><li>TestModuleConstants.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAME = <span class="string">'testmodule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action types</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/ADD`</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUB = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/SUB`</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件用来放全局常量。这里定义了 ADD 和 SUB 。</p><ul><li>TestModuleReducer.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ADD, SUB&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="comment">//初始化数据的地方</span></span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> handleActions(&#123; <span class="comment">//处理数据的地方</span></span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  [ADD]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SUB]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, initialState);</span><br></pre></td></tr></table></figure></li></ul><p>reducer 利用 action.payload 拿到从 action 传来的数据，处理数据，处理完返回。<br>这里就要说一下Redux的数据流了，请先看一下下图：<br><img src="https://wx3.sinaimg.cn/mw690/ba56005dgy1fxkcvc6dthj20xm0mk77l.jpg" alt="Redux Flow"></p><p>(图片来自网上)<br>这里我们在TestModule.js 文件中的 connect 中 dispatch( action ) ，把原先的计数器中数字 num (图中 previousState )，和 action ( ADD 或 SUB )传到了 reducer 里面，根据 actions 文件里面的 action 的 TYPE 来执行各自的数据处理。处理完之后就有新的 newState 传到 Store ，再传到组件中，驱动组件改变状态重新渲染。</p><ul><li>index.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./TestModule'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./TestModuleReducer'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./TestModuleActions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NAME&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  NAME,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  reducer,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件将 NAME，module，reducer，actions 暴露出去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 RN + Redux 为基础框架开发已有三个多月，很多东西都还需要多加学习研究，这只是最基础的组件和模块开发。</p><p>组件开发总的时间为十的话，一定要思考占七，动手写占三，认真的多思考组件的构造，这样在动手写的时候才能尽量的避免结构的冗余，或者是样式的冗余，而且要想为什么做这个组件，必需能在某个项目中能多次的使用该组件，这样组件的开发才会变得有意义，不然一个组件只用一次的话，就没有必要单独拿出来封装成一个组件。另外就是组件写的过程尽量的思考拓展性，很多结构不要写死了，这次组件可能只需要展示 2 个 tab，但是下一次就不一定了，所以写的时候要多想。</p><p>模块开发的时候，尽量保持结构层次的清晰，这样的话代码的维护就会得比较轻松，模块里有很多独立的功能部分可以单抽出来做成一个渲染函数，这样就能让 render 函数看起来没那么的冗余，且结构不会过于复杂。一些点击事件和逻辑功能也是能单独抽出来写成事件函数，这样的话，调试出问题的时候就可以快速定位到问题代码块。还有就是尽量避免写一些重复的组件，能简化的就简化，可以考虑使用 map 函数来渲染重复的组件。</p><p>虽然这里用 Redux 也实现了计数器，但是其实是杀鸡用牛刀了，这样的简单的数据重新渲染其实大可不必，用 setState 就可以了，当然 Redux 也有其优点，他让数据和我们的组件模块解耦，数据单独处理了，不需要在每一个组件中来对 state 进行管理，需要的数据从上游作为 props 传进来了。不过经常可以看到这么一句话，如果你不知道你为什么需要 Redux，那你就是不需要 Redux..   (=. = redux 对于新手真的有点不友好)</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/Helloyongwei/article/details/82937808" target="_blank" rel="noopener">Redux 的数据流</a></li><li><a href="https://www.jianshu.com/p/2a20c8485a90" target="_blank" rel="noopener">看了我这篇 RN 你就入门了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="juga" scheme="http://xgfe.github.io/categories/juga/"/>
    
    
      <category term="React Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="http://xgfe.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>koa-router 源码解读</title>
    <link href="http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/"/>
    <id>http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/</id>
    <published>2018-09-27T11:18:00.000Z</published>
    <updated>2020-02-19T11:04:25.668Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果实现一个简单的路由，可以解析<code>node</code>原生<code>request即IncomingMessage</code>对象的<code>url</code>属性，用 <code>if...else</code>判断路径从而返回不同的结果；当然也可以利用<code>koa</code>的<code>request</code>对象和<code>response</code>对象来处理。下面就是用<code>koa</code>实现的简单路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pageUrl = <span class="string">`./page/<span class="subst">$&#123;page&#125;</span>`</span>;</span><br><span class="line">        fs.readFile(pageUrl, <span class="string">"binary"</span>, (err,data) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">444</span>);</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> page = <span class="string">'404.html'</span>;</span><br><span class="line">    <span class="keyword">switch</span>(url)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/index'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/todo'</span>:</span><br><span class="line">            page = <span class="string">'todo.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/404'</span>:</span><br><span class="line">            page = <span class="string">'404.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> render(page);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url = ctx.request.url;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> route(url);</span><br><span class="line">    </span><br><span class="line">    ctx.body = html;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'starting at 3000'</span>);</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>路由越多消耗的性能也就越大</li><li>不能对特殊路由添加中间件</li><li>也没有处理响应头类型</li></ul><p>更好的方法是使用面向对象的方式，根据请求的<code>path</code>和<code>method</code>执行相应的中间件处理函数；而在实际开发中我们常用的是<code>koa</code>路由库<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>。本文通过解析<code>koa-router</code>的源码来达到深入学习其原理的目的。</p><h2 id="kao-router的简单使用demo"><a href="#kao-router的简单使用demo" class="headerlink" title="kao-router的简单使用demo"></a>kao-router的简单使用demo</h2><p>使用<code>koa-router</code>第一步就是新建一个<code>router</code>实例对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> pagePromptRouter <span class="built_in">require</span>(<span class="string">'./controllers/pagePrompt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 创建router实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套路由</span></span><br><span class="line">router.use(<span class="string">'/admin/prompt'</span>, pagePromptRouter.routes(), pagePrompt.allowedMethods());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.routes()); </span><br><span class="line"><span class="comment">// 对请求进行一些限制处理</span></span><br><span class="line">app.use(router.allowedMethods()); </span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>构建应用的时候，我们的首要目标就是创建多个<code>CGI</code>接口以适配不同的业务需求，那么接下来就需要注册对应的路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/queryPagePromptList'</span>, queryPagePromptList);</span><br><span class="line">router.post(<span class="string">'/deletePagePromptById'</span>, deletePagePromptById);</span><br><span class="line">router.post(<span class="string">'/savePagePrompt'</span>, savePagePrompt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryPagePromptList</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> getResult();</span><br><span class="line">ctx.body = &#123;</span><br><span class="line">    data: result.data,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为了让<code>koa</code>实例使用我们配置后的路由模块，需要使用<code>routes()</code>方法将路由(上面的例子中为了代码分层使用了嵌套路由)加入到应用全局的中间件函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes());  <span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.allowedMethods()); <span class="comment">// 对请求进行一些限制处理</span></span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/router.js" target="_blank" rel="noopener">router.js</a></p><p><img src="http://vfile.meituan.net/xgfe/88ed43b2f2951c77384f10d7ff4e1a6a172778.png" alt="router"></p><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/layer.js" target="_blank" rel="noopener">layer.js</a></p><p><img src="http://vfile.meituan.net/xgfe/190cd799e93c05d43fd05b1bda3574ad116451.png" alt="layer"></p><p>router和layer的关系</p><p><img src="http://p0.meituan.net/xgfe/b736ea9f7cc83ba0f0aeaf22782185ff20689.png" alt="router-layer"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Router-构造函数"><a href="#Router-构造函数" class="headerlink" title="Router 构造函数"></a>Router 构造函数</h3><p><code>Node</code>本身提供了数十个<code>HTTP</code>请求动词，<code>koa-router</code>只是实现了部分常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Router(opts) &#123;</span><br><span class="line">  if (!(this instanceof Router)) &#123;</span><br><span class="line">    return new Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  this.methods = this.opts.methods || [</span><br><span class="line">    &apos;HEAD&apos;,</span><br><span class="line">    &apos;OPTIONS&apos;,</span><br><span class="line">    &apos;GET&apos;,</span><br><span class="line">    &apos;PUT&apos;,</span><br><span class="line">    &apos;PATCH&apos;,</span><br><span class="line">    &apos;POST&apos;,</span><br><span class="line">    &apos;DELETE&apos;</span><br><span class="line">  ];</span><br><span class="line">  //省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="router-get-post-delete-all…"><a href="#router-get-post-delete-all…" class="headerlink" title="router.(get|post|delete|all…)()"></a>router.(get|post|delete|all…)()</h3><p>这些请求动词的实现是通过第三方模块<a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>支持的，然后<code>koa-router</code>内部进行了注册处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 这里的methods就是上面的methods模块提供的数组</span><br><span class="line">methods.forEach(function (method) &#123;</span><br><span class="line">  Router.prototype[method] = function (name, path, middleware) &#123;</span><br><span class="line">    var middleware;</span><br><span class="line"></span><br><span class="line">    // 这段代码做了两件事：</span><br><span class="line">    // 1.name 参数是可选的，所以要做一些参数置换的处理</span><br><span class="line">    // 2.将所有路由中间件（因为可以注册多个中间件）合并成一个数组</span><br><span class="line">    if (typeof path === &apos;string&apos; || path instanceof RegExp) &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">      path = name;</span><br><span class="line">      name = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用register方法</span><br><span class="line">    this.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面函数先判断<code>path</code>是否是字符串或者正则表达式，是因为注册路由的时候还可以为路由进行命名(命名空间方便管理)，然后准确地获取回调的函数数组(注册路由可以接收多个回调)， 这样如果匹配到某个路由，回调函数数组中的函数就会依次执行。留意到每个方法都会返回对象本身，也就是说注册路由的时候是可以支持链式调用的。</p><h3 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h3><p><code>this.register</code>接受请求路径、方法、中间件作为参数，返回已经注册的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.register = function (path, methods, middleware, opts) &#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  var router = this;</span><br><span class="line"></span><br><span class="line">  // 全部路由</span><br><span class="line">  var stack = this.stack;</span><br><span class="line"></span><br><span class="line">  // 说明路由的path是支持数组的</span><br><span class="line">  // 如果是数组的话，需要递归调用register来注册路由，因为一个path对应一个路由</span><br><span class="line">  if (Array.isArray(path)) &#123;</span><br><span class="line">    path.forEach(function (p) &#123;</span><br><span class="line">      router.register.call(router, p, methods, middleware, opts);</span><br><span class="line">    &#125;);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建路由，路由就是Layer的实例</span><br><span class="line">  // methods是路由处理的http方法</span><br><span class="line">  // 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的</span><br><span class="line">  var route = new Layer(path, methods, middleware, &#123;</span><br><span class="line">    end: opts.end === false ? opts.end : true,</span><br><span class="line">    name: opts.name,</span><br><span class="line">    sensitive: opts.sensitive || this.opts.sensitive || false,</span><br><span class="line">    strict: opts.strict || this.opts.strict || false,</span><br><span class="line">    prefix: opts.prefix || this.opts.prefix || &quot;&quot;,</span><br><span class="line">    ignoreCaptures: opts.ignoreCaptures</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 处理路径前缀</span><br><span class="line">  if (this.opts.prefix) &#123;</span><br><span class="line">    route.setPrefix(this.opts.prefix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将全局的路由参数添加到每个路由中</span><br><span class="line">  Object.keys(this.params).forEach(function (param) &#123;</span><br><span class="line">    route.param(param, this.params[param]);</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 往路由数组中添加新创建的路由</span><br><span class="line">  stack.push(route);</span><br><span class="line"></span><br><span class="line">  return route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的逻辑我们应该知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/test&apos;, async (ctx, next) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>其实它相当于下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(&apos;/test&apos;, [&apos;GET&apos;], [async (ctx, next) =&gt; &#123;&#125;], &#123; name: null &#125;);</span><br></pre></td></tr></table></figure><p><code>register</code>函数将路由作为第一个参数传入，然后方法名放入到方法数组中作为第二个参数， 第三个函数是路由的回调数组；其实每个路由注册的时候，后面都可以添加很多个函数，而这些函数都会被添加到一个数组里面，如果被匹配到，就会利用中间件机制来逐个执行这些函数。最后一个参数是将路由的命名空间传入。</p><p>对于<code>stack</code>数组，则是存储每一个路由，也就是<code>Layer</code>的实例对象，每一个路由都相当于一个<code>Layer</code>实例对象。</p><p>对于<code>Layer</code>类来说, 创建一个实例对象用于管理每个路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Layer(path, methods, middleware, opts) &#123;</span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  // 路由命名</span><br><span class="line">  this.name = this.opts.name || null;</span><br><span class="line">  // 路由对应的方法</span><br><span class="line">  this.methods = [];</span><br><span class="line">  // 路由参数名数组</span><br><span class="line">  this.paramNames = [];</span><br><span class="line">  // 路由处理中间件数组</span><br><span class="line">  this.stack = Array.isArray(middleware) ? middleware : [middleware];</span><br><span class="line">  // 存储路由方法</span><br><span class="line">  methods.forEach(function(method) &#123;</span><br><span class="line">    var l = this.methods.push(method.toUpperCase());</span><br><span class="line">    if (this.methods[l-1] === &apos;GET&apos;) &#123;</span><br><span class="line">      this.methods.unshift(&apos;HEAD&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 将添加的回调处理中间件函数添加到Layer实例对象的 stack 数组中</span><br><span class="line">  this.stack.forEach(function(fn) &#123;</span><br><span class="line">    var type = (typeof fn);</span><br><span class="line">    if (type !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        methods.toString() + &quot; `&quot; + (this.opts.name || path) +&quot;`: `middleware` &quot;</span><br><span class="line">        + &quot;must be a function, not `&quot; + type + &quot;`&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  this.path = path;</span><br><span class="line">  this.regexp = pathToRegExp(path, this.paramNames, this.opts);</span><br><span class="line"></span><br><span class="line">  debug(&apos;defined route %s %s&apos;, this.methods, this.opts.prefix + this.path);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到, 对于<code>Layer</code>的实例对象, 核心的逻辑还是在于将<code>path</code>转化为正则表达式用于匹配请求的路由,  然后将路由的处理中间件添加到<code>Layer</code>的<code>stack</code>数组中。 注意这里的<code>stack</code>和<code>Router</code>里面的<code>stack</code>是不一样的, <code>Router</code>的<code>stack</code>数组是存放每个路由对应的<code>Layer</code>实例对象的, 而 <code>Layer</code>实例对象里面的<code>stack</code>数组是存储每个路由的处理函数中间件的, 换言之, 一个路由可以添加多个处理函数。</p><p>下面的图详细描述了<code>Router</code>和<code>Layer</code>的关系：</p><p><img src="https://vfile.meituan.net/xgfe/baf7698bb56fa67e38d3c84ad2121a0725705.png" alt="Router和Layer的关系"></p><h3 id="router-routes"><a href="#router-routes" class="headerlink" title="router.routes()"></a>router.routes()</h3><p><code>app.use(router.routes())</code>就这样，<code>koa-router</code>就启动了，所以大家也一定会很好奇这个<code>routes</code>函数到底做了什么，但可以肯定的是<code>router.routes()</code>返回了一个中间件函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch.router = this;</span><br><span class="line">  return dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里形成了一个闭包，在<code>routes</code>函数内部返回了一个<code>dispatch</code>函数作为中间件。 </p><p>接下来看下<code>dispatch</code>函数的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">    var path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line"></span><br><span class="line">    // router.match函数内部遍历所有路由（this.stack),</span><br><span class="line">    // 根据路径和请求方法找到对应的路由</span><br><span class="line">    // 返回的matched对象为： </span><br><span class="line">    /* </span><br><span class="line">      var matched = &#123;</span><br><span class="line">        path: [], // 保存了path匹配的路由数组</span><br><span class="line">        pathAndMethod: [], // 保存了path和methods都匹配的路由数组</span><br><span class="line">        route: false // 是否有对应的路由</span><br><span class="line">      &#125;;</span><br><span class="line">    */</span><br><span class="line">    var matched = router.match(path, ctx.method);</span><br><span class="line">    var layerChain, layer, i;</span><br><span class="line">    if (ctx.matched) &#123;</span><br><span class="line">      ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ctx.matched = matched.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有对应的路由，则直接进入下一个中间件</span><br><span class="line">    if (!matched.route) return next();</span><br><span class="line"></span><br><span class="line">    // 找到正确的路由的path</span><br><span class="line">    var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path;</span><br><span class="line">    ctx._matchedRoute = mostSpecificPath;</span><br><span class="line"></span><br><span class="line">    // 使用reduce方法将路由的所有中间件形成一条链</span><br><span class="line">    // 构建路径对应路由的处理中间件函数数组</span><br><span class="line">    // 这里的目的是在每个匹配的路由对应的中间件处理函数数组前添加一个用于处理</span><br><span class="line">    // 对应路由的 captures, params, 以及路由命名的函数</span><br><span class="line">    layerChain = matched.pathAndMethod.reduce(function(memo, layer) &#123;</span><br><span class="line"></span><br><span class="line">      // 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params</span><br><span class="line">      // 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了</span><br><span class="line">      memo.push(function(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">       // captures是存储路由中参数的值的数组</span><br><span class="line">        ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line"></span><br><span class="line">        // params是一个对象, 键为参数名, 根据参数名可以获取路由中的参数值, 值从captures中拿</span><br><span class="line">        ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line"></span><br><span class="line">        // 执行下一个中间件</span><br><span class="line">        return next();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // 将上面另外加的中间件和已有的路由中间件合并到一起</span><br><span class="line">      // 所以最终 layerChain 将会是一个中间件的数组</span><br><span class="line">      return memo.concat(layer.stack);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    // 最后调用上面提到的compose模块提供的方法，返回将layerChain(中间件的数组) </span><br><span class="line">    // 顺序执行所有中间件的执行函数， 并立即执行。</span><br><span class="line">    return compose(layerChain)(ctx, next);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="router-allowedMethod"><a href="#router-allowedMethod" class="headerlink" title="router.allowedMethod()"></a>router.allowedMethod()</h3><p>对于<code>allowedMethod</code>方法来说, 它的作用就是用于处理请求的错误, 所以它作为路由模块的最后一个函数来执行。同样地, 它也是以一个<code>koa</code>的中间件插件函数的形式出现, 同样在函数内部形成了一个闭包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = function (options) &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  var implemented = this.methods;</span><br><span class="line"></span><br><span class="line">  return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码很简单, 就是保存<code>Router</code>配置中允许的<code>HTTP</code>方法数组在闭包内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    // 从这里可以看出, allowedMethods函数是用于在中间件机制中处理返回结果的函数</span><br><span class="line">    // 先执行next函数, next函数返回的是一个Promise对象</span><br><span class="line">    return next().then(function() &#123;</span><br><span class="line">      var allowed = &#123;&#125;;</span><br><span class="line">      // allowedMethods函数的逻辑建立在statusCode没有设置或者值为404的时候</span><br><span class="line">      if (!ctx.status || ctx.status === 404) &#123;</span><br><span class="line">        // 这里的matched就是在match函数执行之后返回结果集中的 path 数组</span><br><span class="line">        // 也就是说请求路径与路由正则匹配的 layer 实例对象数组</span><br><span class="line">        ctx.matched.forEach(function (route) &#123;</span><br><span class="line">          // 将这些layer路由的HTTP方法存储起来</span><br><span class="line">          route.methods.forEach(function (method) &#123;</span><br><span class="line">            allowed[method] = method;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 将上面的allowed整理为数组</span><br><span class="line">        var allowedArr = Object.keys(allowed);</span><br><span class="line">        // implemented就是Router配置中的methods数组, 也就是允许的方法</span><br><span class="line">        // 这里通过~运算判断当前的请求方法是否在配置允许的方法中</span><br><span class="line">        // 如果该方法不被允许</span><br><span class="line">        if (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          // 如果 Router 配置中配置 throw 为 true</span><br><span class="line">          if (options.throw) &#123;</span><br><span class="line">            var notImplementedThrowable;</span><br><span class="line">            // 如果配置中规定了throw抛出错误的函数, 那么就执行对应的函数</span><br><span class="line">            if (typeof options.notImplemented === &apos;function&apos;) &#123;</span><br><span class="line">              notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 如果没有则直接抛出HTTP Error</span><br><span class="line">              notImplementedThrowable = new HttpError.NotImplemented();</span><br><span class="line">            &#125;</span><br><span class="line">            // 抛出错误</span><br><span class="line">            throw notImplementedThrowable;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // Router配置throw为false</span><br><span class="line">            // 设置状态码为 501</span><br><span class="line">            ctx.status = 501;</span><br><span class="line">            // 并且设置Allow头部, 值为上面得到的允许的方法数组allowedArr</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (allowedArr.length) &#123;</span><br><span class="line">          // 来到这里说明该请求的方法是被允许的, 那么为什么会没有状态码statusCode或者 statusCode为404呢?</span><br><span class="line">          // 原因在于除却特殊情况, 我们一般在业务逻辑里面不会处理OPTIONS请求的</span><br><span class="line">          // 发出这个请求一般常见就是非简单请求, 则会发出预检请求OPTIONS</span><br><span class="line">          // 例如 application/json 格式的POST请求</span><br><span class="line">          </span><br><span class="line">          // 如果是 OPTIONS 请求, 状态码为 200, 然后设置 Allow 头部, 值为允许的方法数组 methods</span><br><span class="line">          if (ctx.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">            ctx.status = 200;</span><br><span class="line">            ctx.body = &apos;&apos;;</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125; else if (!allowed[ctx.method]) &#123;</span><br><span class="line">          // 方法被服务端允许, 但是在路径匹配的路由中没有找到对应本次请求的方法的处理函数</span><br><span class="line">            // 类似上面的逻辑</span><br><span class="line">            if (options.throw) &#123;</span><br><span class="line">              var notAllowedThrowable;</span><br><span class="line">              if (typeof options.methodNotAllowed === &apos;function&apos;) &#123;</span><br><span class="line">                notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                notAllowedThrowable = new HttpError.MethodNotAllowed();</span><br><span class="line">              &#125;</span><br><span class="line">              throw notAllowedThrowable;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              // 这里的状态码为 405</span><br><span class="line">              ctx.status = 405;</span><br><span class="line">              ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是, <code>Router.methods</code>数组里面的方法是服务端需要实现并支持的方法, 如果客户端发送过来的请求方法不被允许, 那么这是一个服务端错误<code>501</code>, 但是如果这个方法被允许, 但是找不到对应这个方法的路由处理函数(比如相同路由的<code>POST</code>路由但是用<code>GET</code>方法来获取数据), 这是一个客户端错误<code>405</code>。</p><h3 id="router-use"><a href="#router-use" class="headerlink" title="router.use()"></a>router.use()</h3><p><code>use</code>函数就是用于添加中间件的, 只不过不同于<code>koa</code>中的<code>use</code>函数, <code>router</code>的<code>use</code>函数添加的中间件函数会在所有路由执行之前执行。此外, 它还可以对某些特定路径的进行中间件函数的绑定执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">router.prototype.use = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  // 中间件函数数组</span><br><span class="line">  var middleware = Array.prototype.slice.call(arguments);</span><br><span class="line">  var path;</span><br><span class="line"></span><br><span class="line">  // 支持同时为多个路由绑定中间件函数: router.use([&apos;/use&apos;, &apos;/admin&apos;], auth());</span><br><span class="line">  if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &apos;string&apos;) &#123;</span><br><span class="line">    middleware[0].forEach(function (p) &#123;</span><br><span class="line">      // 递归调用</span><br><span class="line">      router.use.apply(router, [p].concat(middleware.slice(1)));</span><br><span class="line">    &#125;);</span><br><span class="line">    // 直接返回, 下面是非数组 path 的逻辑</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果第一个参数有传值为字符串, 说明有传路径</span><br><span class="line">  var hasPath = typeof middleware[0] === &apos;string&apos;;</span><br><span class="line">  if (hasPath) &#123;</span><br><span class="line">    path = middleware.shift();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  middleware.forEach(function (m) &#123;</span><br><span class="line">    // 如果有router属性, 说明这个中间件函数是由 Router.prototype.routes暴露出来的</span><br><span class="line">    // 属于嵌套路由</span><br><span class="line">    if (m.router) &#123;</span><br><span class="line">      // 这里的逻辑很有意思, 如果是嵌套路由, 相当于将需要嵌套路由重新注册到现在的 Router 对象上</span><br><span class="line">      m.router.stack.forEach(function (nestedLayer) &#123;</span><br><span class="line">        // 如果有path, 那么为需要嵌套的路由加上路径前缀</span><br><span class="line">        if (path) nestedLayer.setPrefix(path);</span><br><span class="line">        // 如果本身的router有前缀配置, 也添加上</span><br><span class="line">        if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix);</span><br><span class="line">        // 将需要嵌套的路由模块的 stack 中存储的 Layer 加入到本 router 对象上</span><br><span class="line">        router.stack.push(nestedLayer);</span><br><span class="line">      &#125;);</span><br><span class="line">      // 这里与register函数的逻辑类似, 注册的时候检查添加参数校验函数 params</span><br><span class="line">      if (router.params) &#123;</span><br><span class="line">        Object.keys(router.params).forEach(function (key) &#123;</span><br><span class="line">          m.router.param(key, router.params[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 没有router属性则是常规中间件函数, 如果有给定的 path 那么就生成一个 Layer 模块进行管理</span><br><span class="line">      // 如果没有path, 那么就生成通配的路径 (.*) 来生成 Layer 来管理</span><br><span class="line">      router.register(path || &apos;(.*)&apos;, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>眼尖的同学可能会看到一些 http code：404, 501, 204, 405 。那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：</p><ul><li>如果请求的方法<code>koa-router</code>不支持并且没有设置<code>throw</code>选项，则返回<code>501</code>(未实现)</li><li>如果是<code>options</code>请求，则返回 <code>204</code>(无内容)</li><li>如果请求的方法支持但没有设置<code>throw</code>选项，则返回 <code>405</code>(不允许此方法 )</li></ul><h3 id="Router-prototype-match"><a href="#Router-prototype-match" class="headerlink" title="Router.prototype.match"></a>Router.prototype.match</h3><p>我们已经注册好了路由, 但是, 如果请求过来了, 请求是怎么匹配然后进行到相对应的处理函数去的呢? 答案就是利用<code>match</code>函数.先看一下<code>match</code>函数的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.match = function (path, method) &#123;</span><br><span class="line">  // 取所有路由 Layer 实例</span><br><span class="line">  var layers = this.stack;</span><br><span class="line">  var layer;</span><br><span class="line">  // 匹配结果</span><br><span class="line">  var matched = &#123;</span><br><span class="line">    path: [],</span><br><span class="line">    pathAndMethod: [],</span><br><span class="line">    route: false</span><br><span class="line">  &#125;;</span><br><span class="line">  // 遍历路由 Router 的 stack 逐个判断</span><br><span class="line">  for (var len = layers.length, i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    layer = layers[i];</span><br><span class="line"></span><br><span class="line">    debug(&apos;test %s %s&apos;, layer.path, layer.regexp);</span><br><span class="line">    // 这里是使用由路由字符串生成的正则表达式判断当前路径是否符合该正则</span><br><span class="line">    if (layer.match(path)) &#123;</span><br><span class="line">      // 将对应的 Layer 实例加入到结果集的 path 数组中</span><br><span class="line">      matched.path.push(layer);</span><br><span class="line">      // 如果对应的 layer 实例中 methods 数组为空或者数组中有找到对应的方法</span><br><span class="line">      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123;</span><br><span class="line">        // 将 layer 放入到结果集的 pathAndMethod 中</span><br><span class="line">        matched.pathAndMethod.push(layer);</span><br><span class="line">        // 这里是用于判断是否有真正匹配到路由处理函数</span><br><span class="line">        // 因为像 router.use(session()); 这样的中间件也是通过 Layer 来管理的, 它们的 methods 数组为空</span><br><span class="line">        if (layer.methods.length) matched.route = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return matched;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面返回的结果集, 我们知道一个请求来临的时候, 我们可以使用正则来匹配路由是否符合, 然后在<code>path</code>数组或者<code>pathAndMethod</code>数组中找到对应的<code>Layer</code>实例对象.</p><h2 id="router处理请求的流程"><a href="#router处理请求的流程" class="headerlink" title="router处理请求的流程"></a>router处理请求的流程</h2><p><img src="https://vfile.meituan.net/xgfe/63d452eb5a23d3fe3e1bf2e0219bceea93599.png" alt="router处理请求的流程"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>koa-router</code>用到了第三方的<code>node</code>模块</p><ul><li><p><a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a>:<br> 提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数。</p></li><li><p><a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>：<br> <code>node</code>中支持的<code>http</code>动词，就是<code>http.METHODS</code>，可以在终端输出看看。 </p></li><li><p><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>：<br> 将路径字符串转换成强大的正则表达式，还可以输出路径参数。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过分析<code>koa-router</code>的源码，总结了：</p><ul><li><code>koa-router</code>涉及到的<code>router</code>和<code>layer</code>的关系；</li><li><code>koa-router</code>处理请求的整体流程；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。&lt;/p&gt;
    
    </summary>
    
      <category term="zuopengfei" scheme="http://xgfe.github.io/categories/zuopengfei/"/>
    
    
      <category term="node" scheme="http://xgfe.github.io/tags/node/"/>
    
      <category term="koa" scheme="http://xgfe.github.io/tags/koa/"/>
    
      <category term="koa-router" scheme="http://xgfe.github.io/tags/koa-router/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Observable</title>
    <link href="http://xgfe.github.io/2018/08/23/objectisundefined/observable/"/>
    <id>http://xgfe.github.io/2018/08/23/objectisundefined/observable/</id>
    <published>2018-08-23T04:00:00.000Z</published>
    <updated>2020-02-19T11:04:25.656Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是利用Rx.js介绍Observable相关的一些概念，以及通过实现Observable的创建、一些常用的操作符了解Observable的执行原理。</p><a id="more"></a><h2 id="Observable是什么"><a href="#Observable是什么" class="headerlink" title="Observable是什么"></a>Observable是什么</h2><p>数据处理过程中，存在数据的生产者 (Producer) 和数据的消费者 (Consumer) ，处理方式基本分为拉取 (Pull) 和 推送 (Push)两种。</p><table><thead><tr><th></th><th>生产者</th><th>消费者</th></tr></thead><tbody><tr><td><strong>拉取</strong></td><td><strong>被动的:</strong> 当被请求时产生数据。</td><td><strong>主动的:</strong> 决定何时请求数据。</td></tr><tr><td><strong>推送</strong></td><td><strong>主动的:</strong> 按自己的节奏产生数据。</td><td><strong>被动的:</strong> 对收到的数据做出反应。</td></tr></tbody></table><p>在拉取体系中，由消费者来决定何时从生产者那里接收数据。生产者本身不知道数据是何时交付到消费者手中的。每个 JavaScript 函数都是拉取体系。函数是数据的生产者，调用该函数的代码通过从函数调用中“取出”一个单个返回值来对该函数进行消费。ES2015 引入了一种新的的拉取体系, generator 和 iterator。由消费者调用 iterator.next() 从 iterator(生产者) 那“取出”值。</p><p>在推送体系中，由生产者来决定何时把数据发送给消费者。消费者本身不知道何时会接收到数据。在当今的 JavaScript 世界中，Promise 是最常见的推送类型。Promise(生产者) 将一个 resolve 过的值传递给已注册的回调函数(消费者)，但不同于函数的是，由 Promise 来决定何时把值“推送”给回调函数。</p><p><strong>Observable 是多个值的生产者，并将值“推送”给观察者(消费者)。</strong></p><pre><code>Function 是惰性的评估运算，调用时会同步地返回一个单一值。Generator 是惰性的评估运算，调用时会同步地返回零到(有可能的)无限多个值。Promise 是最终可能(或可能不)返回单个值的运算。Observable 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到(有可能的)无限多个值。</code></pre><p><strong>Observable 像是没有参数, 但可以泛化为多个值的函数。</strong></p><p>考虑如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> y = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure></p><p>我们期待看到的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br></pre></td></tr></table></figure></p><p>使用Rx.js，你可以使用 Observable 重写上面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>输出是一样的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></p><p>这是因为函数和 Observable 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observable 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observable 与之相反，不会共享副作用并且是延迟执行。</p><p>订阅 Observable 类似于调用函数。</p><p>如果你使用console.log包围一个函数调用，像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.call());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>你会看到这样的输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>使用 Observable 来做同样的事：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>这证明了 foo 的订阅完全是同步的，就像函数一样。Observable 传递值可以是同步的，也可以是异步的。<br>那么 Observable 和 函数的区别是什么呢？Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。你无法这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 死代码，永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数只能返回一个值。但 Observable 可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>); <span class="comment">// “返回”另外一个值</span></span><br><span class="line">  observer.next(<span class="number">200</span>); <span class="comment">// 还可以再“返回”值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>同步输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>但你也可以异步地“返回”值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>);</span><br><span class="line">  observer.next(<span class="number">200</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">300</span>); <span class="comment">// 异步执行</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br><span class="line">300</span><br></pre></td></tr></table></figure></p><p>结论:</p><pre><code>func.call() 意思是 &quot;同步地给我一个值&quot;observable.subscribe() 意思是 &quot;给我任意数量的值，无论是同步还是异步&quot;</code></pre><h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> once = <span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">    f(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// just return a subscribe function</span></span><br><span class="line">  <span class="comment">// error and complete can be invoked just once</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next, error, complete</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> finished = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> unsubscribe = f(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next(val)</span><br><span class="line">      &#125;,</span><br><span class="line">      error: once(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        error &amp;&amp; error(err)</span><br><span class="line">      &#125;),</span><br><span class="line">      complete: once(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        complete &amp;&amp; complete()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should return a dispose function</span></span><br><span class="line">    <span class="comment">// think case like timeout, interval, websocket connection...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      unsubscribe &amp;&amp; unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> number$ = create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>)</span><br><span class="line">  observer.next(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  observer.error(<span class="built_in">Error</span>(<span class="string">'crash'</span>))</span><br><span class="line"></span><br><span class="line">  observer.next(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe</span></span><br><span class="line">number$(</span><br><span class="line">  val =&gt; <span class="built_in">console</span>.log(<span class="string">'next:'</span>, val),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">'error:'</span>, err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next: 1</span></span><br><span class="line"><span class="comment">// next: 2</span></span><br><span class="line"><span class="comment">// error: Error: crash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval = <span class="function"><span class="params">delay</span> =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), delay)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.complete()</span><br><span class="line"></span><br><span class="line">    clearInterval(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unsubscribe = interval$(</span><br><span class="line">  val =&gt; <span class="built_in">console</span>.log(<span class="string">'next:'</span>, val),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">'error:'</span>, err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next: 0</span></span><br><span class="line"><span class="comment">// next: 1</span></span><br><span class="line"><span class="comment">// next: 2</span></span><br><span class="line"><span class="comment">// next: 3</span></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line"></span><br><span class="line">setTimeout(unsubscribe, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Observable 作为多个值的生产者这样的数据抽象，在使用时，我们还需要操作符。操作符是允许复杂的异步代码以声明式的方式进行轻松组合的基础代码单元。操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。</p><p><img src="https://cn.rx.js.org/img/map.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      observer.next(f(x))</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/filter.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      f(x) &amp;&amp; observer.next(x)</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/merge.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function"><span class="params">observable</span> =&gt;</span> &#123;</span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; observer.next(x),</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        i === l &amp;&amp; observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/combineLatest.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineLatest = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function">(<span class="params">observable, i</span>) =&gt;</span> &#123;</span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; &#123;</span><br><span class="line">        !(i <span class="keyword">in</span> arr) &amp;&amp; (k += <span class="number">1</span>)</span><br><span class="line">        arr[i] = x</span><br><span class="line"></span><br><span class="line">        k === l &amp;&amp; observer.next(arr)</span><br><span class="line">      &#125;,</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n === l &amp;&amp; observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/combineAll.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineAll = <span class="function">(<span class="params">...observables</span>) =&gt;</span> observer =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function">(<span class="params">observable, i</span>) =&gt;</span> &#123;</span><br><span class="line">    observable(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">      !(i <span class="keyword">in</span> arr) &amp;&amp; (n += <span class="number">1</span>)</span><br><span class="line">      arr[i] = x</span><br><span class="line"></span><br><span class="line">      n === l &amp;&amp; observer(arr)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/share.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> share = <span class="function"><span class="params">observable</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> finished = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> obs = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> observable(</span><br><span class="line">    x =&gt; obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.next(x)),</span><br><span class="line">    err =&gt; obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.error(err)),</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.complete())</span><br><span class="line">      obs = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (finished || obs.indexOf(observer) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obs.push(observer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazy subscribe until the first observer occurs</span></span><br><span class="line">    obs.length === <span class="number">1</span> &amp;&amp; start()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/take.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> take = <span class="function"><span class="params">n</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    observer.complete()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> unsubscribe = observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      observer.next(x)</span><br><span class="line"></span><br><span class="line">      n--</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        unsubscribe()</span><br><span class="line">        observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/concat.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concat = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= l) &#123;</span><br><span class="line">      <span class="keyword">return</span> observer.complete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observables[n](</span><br><span class="line">      x =&gt; observer.next(x),</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        f(n + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/concatMap.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concatMap = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> observables = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> c = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> g = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flushing || !observables.length) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> observable = observables.shift()</span><br><span class="line"></span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; &#123;</span><br><span class="line">        observer.next(x)</span><br><span class="line">      &#125;,</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        flushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">          observables = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">return</span> observer.complete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (c) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      observables.push(f(x))</span><br><span class="line">      g()</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      c = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/switchMap.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> switchMap = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="keyword">let</span> unsubscribe</span><br><span class="line"></span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (unsubscribe) &#123;</span><br><span class="line">        unsubscribe()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      current = f(x)</span><br><span class="line"></span><br><span class="line">      unsubscribe = current(</span><br><span class="line">        x =&gt; observer.next(x),</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          observer.error(err)</span><br><span class="line"></span><br><span class="line">          unsubscribe()</span><br><span class="line">          unsubscribe = <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          observer.complete()</span><br><span class="line"></span><br><span class="line">          unsubscribe()</span><br><span class="line">          unsubscribe = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从数据处理的拉取和推送的方式着手，了解了 Observable 是基于推送模型的多值生产者的抽象，像是没有参数, 但可以泛化为多个值的函数。通过代码实现了一个 Observable 的创建函数，还实现了很多操作符。这只是个开始，在工作和学习中，你要认真思考自己的场景，观察这个场景中是不是存在着类似多个管道产生值，这些管道也存在着组合变换的逻辑，这时候，Observable 就可以大显身手了。从编程范式上来讲，使用 Observable，其实是 反应式编程（Reactive Programming） 的思维，它可以帮助我们摆脱命令式的状态处理，状态和逻辑杂合在一起，用声明式的方式去组合我们的逻辑，希望你能去探索下 Reactive Programming 和 Functional Reactive Programming的世界。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">The introduction to Reactive Programming you’ve been missing</a></li><li><a href="https://zhuanlan.zhihu.com/p/20213244" target="_blank" rel="noopener">谈谈FRP和Observable（一）</a></li><li><a href="http://jerryzou.com/posts/rxjs-practice-01/" target="_blank" rel="noopener">RxJS 实战篇（一）拖拽</a></li><li><a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">http://reactivex.io/rxjs/</a></li><li><a href="https://cn.rx.js.org/manual/overview.html" target="_blank" rel="noopener">cn.rx.js.org</a></li><li><a href="https://github.com/btroncone/learn-rxjs" target="_blank" rel="noopener">learn-rxjs</a></li><li><a href="https://github.com/ichpuchtli/awesome-rxjs" target="_blank" rel="noopener">awesome-rxjs</a></li><li><a href="https://github.com/staltz/xstream" target="_blank" rel="noopener">xstream</a></li><li><a href="https://github.com/paldepind/flyd" target="_blank" rel="noopener">flyd</a></li><li><a href="https://github.com/staltz/callbag-basics/" target="_blank" rel="noopener">callbag-basics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是利用Rx.js介绍Observable相关的一些概念，以及通过实现Observable的创建、一些常用的操作符了解Observable的执行原理。&lt;/p&gt;
    
    </summary>
    
      <category term="tianzhen" scheme="http://xgfe.github.io/categories/tianzhen/"/>
    
      <category term="Observable" scheme="http://xgfe.github.io/categories/tianzhen/Observable/"/>
    
    
      <category term="Observable" scheme="http://xgfe.github.io/tags/Observable/"/>
    
      <category term="RxJS" scheme="http://xgfe.github.io/tags/RxJS/"/>
    
      <category term="Functional Reactive Programming" scheme="http://xgfe.github.io/tags/Functional-Reactive-Programming/"/>
    
  </entry>
  
  <entry>
    <title>angularjs的双向数据绑定</title>
    <link href="http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs双向绑定/</id>
    <published>2018-08-15T13:00:00.000Z</published>
    <updated>2018-12-10T07:42:54.159Z</updated>
    
    <content type="html"><![CDATA[<p>angularjs的双向数据绑定原理及简单的实现。</p><a id="more"></a><p>之前对vue.js的双向绑定比较感兴趣，自己动手实现了一个类似于vue.js的mvvm框架。vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。其核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">this.watch = function(obj, callback) &#123;</span><br><span class="line">this.$observeObj = function() &#123;</span><br><span class="line">var that = this;</span><br><span class="line">this.callback = callback;</span><br><span class="line">//console.log(Object.keys(obj));</span><br><span class="line">Object.keys(obj).forEach(function(prop) &#123;</span><br><span class="line">var val = obj[prop];</span><br><span class="line">Object.defineProperty(obj, prop, &#123;</span><br><span class="line">get: function() &#123;</span><br><span class="line">return val;</span><br><span class="line">&#125;,</span><br><span class="line">set: function(newVal) &#123;</span><br><span class="line">var temp = val;</span><br><span class="line">//console.log(newVal);</span><br><span class="line">val = newVal;</span><br><span class="line">//通知所有订阅者改变</span><br><span class="line"></span><br><span class="line">that.cache.forEach(function(item) &#123;</span><br><span class="line">if (item[prop]) &#123;</span><br><span class="line">item[prop] = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">that.callback();</span><br><span class="line">&#125;,    </span><br><span class="line">enumerable: true,</span><br><span class="line">   configurable: true</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$observeObj();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>set</code>属性在改变数据的同时触发视图的更新。</p><p>angularjs实现数据双向绑定与vue.js有所不同，它依赖于脏值检测，这里我写了一个简易的版本，其主要代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">initWatch() &#123;  </span><br><span class="line">    for (let i = 0, len = this.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">        //用来保证初值的正常加载，以及当我改变input框中的值为空时能正常显示</span><br><span class="line">        this.flags.push(false);</span><br><span class="line">        this.watch(() =&gt; &#123;</span><br><span class="line">            let value = this.elements[i].value;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">            let key = this.elements[i].getAttribute(&apos;ng-model&apos;);</span><br><span class="line">            const elementType = this.elements[i].tagName.toLowerCase();</span><br><span class="line"></span><br><span class="line">            this.data[key] = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            //设置属性值</span><br><span class="line">            if (elementType === &apos;input&apos; || elementType === &apos;textarea&apos; || elementType === &apos;select&apos;) &#123;</span><br><span class="line">                this.elements[i].value = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.elements[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let j = 0, len = this.bind.length; j &lt; len; j++) &#123;</span><br><span class="line">                let item = this.bind[i].getAttribute(&apos;ng-bind&apos;);</span><br><span class="line">                if (item === key) &#123;</span><br><span class="line">                    this.bind[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&apos;keyup&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">    document.addEventListener(&apos;change&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听函数</span><br><span class="line">watch(watchFn, callback) &#123;</span><br><span class="line">    this.watchers.push(&#123;</span><br><span class="line">        watchFn: watchFn,</span><br><span class="line">        callback: callback || function() &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新数据</span><br><span class="line">digest() &#123;</span><br><span class="line">    let dirty;</span><br><span class="line">    do &#123;</span><br><span class="line">        dirty = false;</span><br><span class="line"></span><br><span class="line">    for (let i = 0, len = this.watchers.length; i &lt; len; i++) &#123;</span><br><span class="line">        let newVal = this.watchers[i].watchFn();</span><br><span class="line">        let oldVal = this.watchers[i].last;</span><br><span class="line"></span><br><span class="line">        if (newVal !== oldVal) &#123;</span><br><span class="line">            this.watchers[i].callback(newVal, oldVal);</span><br><span class="line">            dirty = true;</span><br><span class="line">            this.watchers[i].last = newVal;</span><br><span class="line">            this.flags[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; while(dirty);</span><br></pre></td></tr></table></figure><p><code>watch</code>接受两个参数（这里只考虑了单值的情况，用<code>ng-bind</code>来绑定值），监听的数据与监听的回调函数。digest函数只会在指定事件触发后，才执行，比如这里input框    ,改变输入的值会触发keyup事件，调用<code>digest</code>函数，这个函数会遍历所有的<code>watchers</code>，对比以前的值和新值是否一样，如果不一样就执行回调函数更新数据和视图。<br>我自己实现的版本很基础也很片面，我们可以看看angularjs源码对这部分的描述（这里看angularjs 1.3.20版本）：</p><h3 id="parse"><a href="#parse" class="headerlink" title="$parse"></a>$parse</h3><p><code>parse</code>是一个解析函数，angularjs中单独在一个名叫parse.js的文件中。我们从<code>$get</code>方法出发，它最后会返回一个<code>$parse</code>函数，这个函数的核心部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var lexer = new Lexer(parseOptions);</span><br><span class="line">var parser = new Parser(lexer, $filter, parseOptions);</span><br><span class="line">parsedExpression = parser.parse(exp);</span><br></pre></td></tr></table></figure><p>其中，<code>Lexer</code>这个构造函数中的<code>lex</code>方法用于解析传入数据的所有特殊情况，比如当我检测到这个监控数据为带有引号的字符串时（检查到第一个字符为单引号或者双引号），readString方法就会继续解析后面的字符，最后将结果存到this.tokens中，同理，当检测到是number类型的便会执行readNumber方法，将结果存在this.tokens中。<code>parse</code>就是处理<code>lexer</code>实例返回的this.tokens值，生成执行表达式，其实就是返回一个执行函数。因为这个函数中对四则运算也做了处理，所以当输入1+2的表达式时，最终会返回结果3。  </p><h3 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$watch: function(watchExp, listener, objectEquality) &#123;</span><br><span class="line">    var get = $parse(watchExp);</span><br><span class="line"></span><br><span class="line">    if (get.$$watchDelegate) &#123;</span><br><span class="line">      return get.$$watchDelegate(this, listener, objectEquality, get);</span><br><span class="line">    &#125;</span><br><span class="line">    var scope = this,</span><br><span class="line">        array = scope.$$watchers,</span><br><span class="line">        watcher = &#123;</span><br><span class="line">          fn: listener,</span><br><span class="line">          last: initWatchVal,</span><br><span class="line">          get: get,</span><br><span class="line">          exp: watchExp,</span><br><span class="line">          eq: !!objectEquality</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">    if (!isFunction(listener)) &#123;</span><br><span class="line">      watcher.fn = noop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!array) &#123;</span><br><span class="line">      array = scope.$$watchers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // we use unshift since we use a while loop in $digest for speed.</span><br><span class="line">    // the while loop reads in reverse order.</span><br><span class="line">    array.unshift(watcher);</span><br><span class="line"></span><br><span class="line">    return function deregisterWatch() &#123;</span><br><span class="line">      arrayRemove(array, watcher);</span><br><span class="line">      lastDirtyWatch = null;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>$watch</code>主要接收三个参数:监听的数据，监听的回调函数，是否深度监听。  </p><ul><li>watch参数：  </li><li>fn：监听函数，当新旧值不想等的时候会执行  </li><li>last：存放旧值  </li><li>get：保存监控表达式对应的函数，主要用来获取表达式的值做新旧值的对比  </li><li>exp：原始监控表达式  </li><li>eq：是否深度比较，存储的是<code>$watch</code>的第三个参数  </li></ul><p>当需要监听数据的时候，<code>get.$$watchDelegate</code>是否存在取决于<code>parse</code>中的parsedExpression.constant的值，而它的值取决于<code>$watch</code>监听的数据是否为常量，如果是常量的话，这个监听函数只会执行一次，不会被push进<code>$$watchers</code>的队列中，如果监听的是变量，那么这个<code>watch</code>会被push到<code>$$watchers</code>队列的最前面。最后会返回一个函数，这个函数的功能就是删除当前的<code>watch</code>，所以如果我们想取消这个监听，可以用一个变量接收<code>$watch</code>的返回值，再执行这个函数就达到了效果。</p><h3 id="evalAsync"><a href="#evalAsync" class="headerlink" title="$evalAsync"></a>$evalAsync</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$evalAsync: function(expr, locals) &#123;</span><br><span class="line">// if we are outside of an $digest loop and this is the first time we are scheduling async</span><br><span class="line">// task also schedule async auto-flush</span><br><span class="line">if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) &#123;</span><br><span class="line">  $browser.defer(function() &#123;</span><br><span class="line">    if (asyncQueue.length) &#123;</span><br><span class="line">      $rootScope.$digest();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncQueue.push(&#123;scope: this, expression: expr, locals: locals&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>$evalAsync</code>函数的作用是延迟执行表达式，<code>$$asyncQueue</code>是一个异步的队列，保存着所有需要异步执行的表达式。<code>$bowser.defer</code>是用setTimeout来实现的。</p><h3 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">$digest: function() &#123;</span><br><span class="line">       var watch, value, last,</span><br><span class="line">           watchers,</span><br><span class="line">           length,</span><br><span class="line">           dirty, ttl = TTL,</span><br><span class="line">           next, current, target = this,</span><br><span class="line">           watchLog = [],</span><br><span class="line">           logIdx, logMsg, asyncTask;</span><br><span class="line"></span><br><span class="line">       beginPhase(&apos;$digest&apos;);</span><br><span class="line">       // Check for changes to browser url that happened in sync before the call to $digest</span><br><span class="line">       $browser.$$checkUrlChange();</span><br><span class="line"></span><br><span class="line">       if (this === $rootScope &amp;&amp; applyAsyncId !== null) &#123;</span><br><span class="line">         // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span><br><span class="line">         // cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span><br><span class="line">         $browser.defer.cancel(applyAsyncId);</span><br><span class="line">         flushApplyAsync();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">       do &#123; // &quot;while dirty&quot; loop</span><br><span class="line">         dirty = false;</span><br><span class="line">         current = target;</span><br><span class="line"></span><br><span class="line">         while (asyncQueue.length) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">             asyncTask = asyncQueue.shift();</span><br><span class="line">             asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);</span><br><span class="line">           &#125; catch (e) &#123;</span><br><span class="line">             $exceptionHandler(e);</span><br><span class="line">           &#125;</span><br><span class="line">           lastDirtyWatch = null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         traverseScopesLoop:</span><br><span class="line">          do &#123; // &quot;traverse the scopes&quot; loop</span><br><span class="line">           if ((watchers = current.$$watchers)) &#123;</span><br><span class="line">             // process our watches</span><br><span class="line">             length = watchers.length;</span><br><span class="line">             while (length--) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 watch = watchers[length];</span><br><span class="line">                 // Most common watches are on primitives, in which case we can short</span><br><span class="line">                 // circuit it with === operator, only when === fails do we use .equals</span><br><span class="line">                 if (watch) &#123;</span><br><span class="line">                   if ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</span><br><span class="line">                       !(watch.eq</span><br><span class="line">                           ? equals(value, last)</span><br><span class="line">                           : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">                              &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) &#123;</span><br><span class="line">                     dirty = true;</span><br><span class="line">                     lastDirtyWatch = watch;</span><br><span class="line">                     watch.last = watch.eq ? copy(value, null) : value;</span><br><span class="line">                     watch.fn(value, ((last === initWatchVal) ? value : last), current);</span><br><span class="line">                     if (ttl &lt; 5) &#123;</span><br><span class="line">                       logIdx = 4 - ttl;</span><br><span class="line">                       if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">                       watchLog[logIdx].push(&#123;</span><br><span class="line">                         msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">                         newVal: value,</span><br><span class="line">                         oldVal: last</span><br><span class="line">                       &#125;);</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">                     // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">                     // have already been tested.</span><br><span class="line">                     dirty = false;</span><br><span class="line">                     break traverseScopesLoop;</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125; catch (e) &#123;</span><br><span class="line">                 $exceptionHandler(e);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">            // Insanity Warning: scope depth-first traversal</span><br><span class="line">           // yes, this code is a bit crazy, but it works and we have tests to prove it!</span><br><span class="line">           // this piece should be kept in sync with the traversal in $broadcast</span><br><span class="line">           if (!(next = (current.$$childHead ||</span><br><span class="line">               (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">             while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">               current = current.$parent;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; while ((current = next));</span><br><span class="line"></span><br><span class="line">         // `break traverseScopesLoop;` takes us to here</span><br><span class="line"></span><br><span class="line">         if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">           clearPhase();</span><br><span class="line">           throw $rootScopeMinErr(&apos;infdig&apos;,</span><br><span class="line">               &apos;&#123;0&#125; $digest() iterations reached. Aborting!\n&apos; +</span><br><span class="line">               &apos;Watchers fired in the last 5 iterations: &#123;1&#125;&apos;,</span><br><span class="line">               TTL, watchLog);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; while (dirty || asyncQueue.length);</span><br><span class="line"></span><br><span class="line">       clearPhase();</span><br><span class="line"></span><br><span class="line">       while (postDigestQueue.length) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">           postDigestQueue.shift()();</span><br><span class="line">         &#125; catch (e) &#123;</span><br><span class="line">           $exceptionHandler(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p><code>asyncQueue</code>代表异步队列，这里有两层循环，外层循环是为了保证所有的model都能被检测到，循环的两个条件，一是asyncQueue.length不为空；二是dirty为true,在监控watch的值的变化时，会将dirty置为true，循环开始会执行<code>asyncQueue</code>队列中的表达式。</p><p>内层循环用来遍历所有的watch函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(value = watch.get(current)) !== (last = watch.last) &amp;&amp;  </span><br><span class="line">!(watch.eq</span><br><span class="line">    ? equals(value, last)</span><br><span class="line">    : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">       &amp;&amp; isNaN(value) &amp;&amp; isNaN(last))))</span><br></pre></td></tr></table></figure><p>判断新值和旧值是否发生了变化，并且用watch.eq判断是否为深度监听，<code>equals</code>函数用来比较两个值是否相等，这个函数把所有可能的情况都考虑了进去，以前自己实现过两个值的比较，但是对于像DateRegExp这种类型的值的比较是没有考虑的，也正好查漏补缺。<br>内层循环的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">  while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">    current = current.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码表示，在当前作用域下执行完对watch的监控之后，还要继续查找它的子作用域，兄弟作用域，父作用域，如果next有值就会一直循环，直到这一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (ttl &lt; 5) &#123;</span><br><span class="line">    logIdx = 4 - ttl;</span><br><span class="line">    if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">    watchLog[logIdx].push(&#123;</span><br><span class="line">      msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">      newVal: value,</span><br><span class="line">      oldVal: last</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">  // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">  // have already been tested.</span><br><span class="line">  dirty = false;</span><br><span class="line">  break traverseScopesLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的ttl的初始值为10（默认值），ttl的存在就是为了防止循环次数过多，如果超过最大次数，就会throw错误并告诉开发者循环可能永远不会稳定。当ttl小于5的时候开始记录<code>watchLog</code>对象，如果当前的watch与最后一次检查的<code>lastDirtyWatch</code>相等的话就跳出内层循环同时结束外层循环。最后会执行<code>postDigestQueue</code>队列中的函数，这个跟asyncQueue不同的是，它不会主动触发<code>digest</code>方法,只是往<code>postDigestQueue</code>队列中增加执行表达式，在<code>digest</code>内最后执行。</p><p>通过阅读angularjs脏值检测的源码部分，对它底层的实现有了大致的了解，对于parse.js可以作为一个字符串的解析器，实际场景比如实现一个计算器，equals函数用来比较两个值是否相等，都是值得借鉴的部分。与之前实现的简易版本比较，实际angularjs框架做的东西就多得多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;angularjs的双向数据绑定原理及简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangxiaotong" scheme="http://xgfe.github.io/categories/yangxiaotong/"/>
    
    
      <category term="angularjs" scheme="http://xgfe.github.io/tags/angularjs/"/>
    
  </entry>
  
</feed>
