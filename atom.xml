<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2019-04-16T08:45:15.191Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>宏任务和微任务</title>
    <link href="http://xgfe.github.io/2019/04/16/zhangpeng/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://xgfe.github.io/2019/04/16/zhangpeng/宏任务和微任务/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-16T08:45:15.191Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。</p><a id="more"></a><h2 id="一、宏任务和微任务"><a href="#一、宏任务和微任务" class="headerlink" title="一、宏任务和微任务"></a>一、宏任务和微任务</h2><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1.宏任务"></a>1.宏任务</h3><p>事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。<br>宏任务：</p><ul><li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li><li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li><li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收。</li></ul><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2.微任务"></a>2.微任务</h3><p>微任务：</p><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><h3 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h3><p>ECMA的规范没有提及到事件循环，但在HTML规范里却有提及<br>（1）里面也讨论了宏任务和微任务的概念<br>（2）ECMA规范提及到了Promise<br>（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用<br> 事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。</p><p> 事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。<br> 从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。</p><p> 当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。<br> 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。<br> 因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。</p><p> 所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。<br> 浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。<br> 现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">在另一个16ms结束前，事件循环执行到&quot;是否需要渲染&quot;的决策的环节。因为更新UI是一个复杂的操作，</span><br><span class="line">如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作</span><br><span class="line">在最后的一个渲染操作完成后大约16ms，事件循环执行到&quot;是否需要进行渲染&quot;的决策环节，</span><br><span class="line">在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。</span><br><span class="line">在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，</span><br><span class="line">且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，</span><br><span class="line">反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，</span><br><span class="line">用户可能会觉得网页挂掉了。</span><br><span class="line">在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，</span><br><span class="line">可能会导致网页的性能低下。  </span><br><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">主线程javascript代码执行时间需要15ms</span><br><span class="line">第一个单击事件处理器需要运行8ms</span><br><span class="line">第二个单击事件处理器需要运行5ms</span><br><span class="line">让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，</span><br><span class="line">我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms，</span><br><span class="line">第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript</span><br><span class="line">代码开始，立刻从DOM获取firstButton和secondButton元素，</span><br><span class="line">并注册firstHandle和secondHandle的事件处理器。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.</span><br><span class="line">由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。</span><br><span class="line">记住，一个任务一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，</span><br><span class="line">等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，</span><br><span class="line">等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。</span><br><span class="line"></span><br><span class="line">在第12ms的时候，</span><br><span class="line">1.执行主线程javascript代码，执行当前任务。</span><br><span class="line">2.单击firstButton，单击firstButton的时候，创建事件</span><br><span class="line">3.单击secondButton,单击secondButton的时候，创建事件</span><br><span class="line">在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，</span><br><span class="line">任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，</span><br><span class="line">UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。</span><br><span class="line"></span><br><span class="line">接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，</span><br><span class="line">secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，</span><br><span class="line">接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，</span><br><span class="line">浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。</span><br><span class="line">最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms，</span><br><span class="line">执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，</span><br><span class="line">但是对应的事件处理任务在第23ms时才开始执行。</span><br></pre></td></tr></table></figure></p><h3 id="4-宏任务和微任务"><a href="#4-宏任务和微任务" class="headerlink" title="4.宏任务和微任务"></a>4.宏任务和微任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;     </span><br><span class="line">第5ms单击firstButton</span><br><span class="line">第12m单击secondButton</span><br><span class="line">firstButton 的单击事件处理函数firstHandle需要执行8ms。</span><br><span class="line"></span><br><span class="line">secondButton 的单击事件的处理函数secondHandle需要执行5ms。</span><br><span class="line"></span><br><span class="line">在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。</span><br><span class="line">因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。</span><br><span class="line"></span><br><span class="line">我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，</span><br><span class="line">但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，</span><br><span class="line">需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。</span><br><span class="line"></span><br><span class="line">在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，</span><br><span class="line">单击firstButton和secondButton按钮这两个任务处于等待状态，</span><br><span class="line">但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，</span><br><span class="line">此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，</span><br><span class="line">若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，</span><br><span class="line">处理firstButton按钮单机相关任务的代码如下。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，</span><br><span class="line">此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，</span><br><span class="line">第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，</span><br><span class="line">此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，</span><br><span class="line">在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，</span><br><span class="line">添加了一个微任务处理PROMISE成功兑现。</span><br><span class="line">如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，</span><br><span class="line">微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，</span><br><span class="line">事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。</span><br><span class="line"></span><br><span class="line">正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，</span><br><span class="line">在更早的队列中secondButton单击任务执行完毕则继续等待。</span><br><span class="line"></span><br><span class="line">当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。</span><br><span class="line">可以在主线程和第一个按钮单击任务之间重新渲染页面，</span><br><span class="line">但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。</span><br><span class="line">注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，</span><br><span class="line">所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，</span><br><span class="line">事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意。</span><br></pre></td></tr></table></figure><h3 id="5-计时器"><a href="#5-计时器" class="headerlink" title="5.计时器"></a>5.计时器</h3><p>计时器是能延迟一段代码的运行，延迟时长是指定的时长，<br>将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，<br>在事件循环中执行计时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* run 18ms */</span><br><span class="line">假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，</span><br><span class="line">在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，</span><br><span class="line">发生了3件重要的事件。</span><br><span class="line">在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.</span><br><span class="line">计时器的引用保存在浏览器。</span><br><span class="line">在6ms，单击鼠标。</span><br><span class="line">在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。</span><br><span class="line"></span><br><span class="line">从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。</span><br><span class="line">新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，</span><br><span class="line">该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，</span><br><span class="line">计时器事件与input输入框的输入事件类似，都会被添加到队列中。</span><br><span class="line">注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。</span><br><span class="line">运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，</span><br><span class="line">因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，</span><br><span class="line">3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，</span><br><span class="line">这意味着单击事件处理器开始执行，setTimeout函数只到期一次，</span><br><span class="line">setInterval函数则不同，setTnterval会持续执行到被清除，</span><br><span class="line">因此，在第20ms的时候，setInterval又一次触发，</span><br><span class="line">但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发。</span><br><span class="line">但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。</span><br><span class="line">单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，</span><br><span class="line">第28ms,事件循环进行下一次迭代，执行延迟计时器任务。</span><br><span class="line"></span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。</span><br><span class="line">这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，</span><br><span class="line">至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，</span><br><span class="line">而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，</span><br><span class="line">但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，</span><br><span class="line">因为队列中已经有一个与之相匹配的间隔计时器，</span><br><span class="line">在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，</span><br><span class="line">然后进入下一个事件循环迭代。</span><br><span class="line"></span><br><span class="line">最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,</span><br><span class="line">又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。</span><br><span class="line"></span><br><span class="line">间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，</span><br><span class="line">此时，由于间隔处理器正在执行，不是在队列中等待，</span><br><span class="line">设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，</span><br><span class="line">每一个任务的执行时间有可能不同，一个接一个的完成。</span><br><span class="line"></span><br><span class="line">最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，</span><br><span class="line">事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，</span><br><span class="line">间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，</span><br><span class="line">回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。&lt;/p&gt;
    
    </summary>
    
      <category term="ZHANGPENG" scheme="http://xgfe.github.io/categories/ZHANGPENG/"/>
    
    
      <category term="宏任务和微任务" scheme="http://xgfe.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/"/>
    <id>http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/</id>
    <published>2019-03-09T08:15:00.000Z</published>
    <updated>2019-04-16T07:07:55.916Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。</p><a id="more"></a><h2 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</p></blockquote><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>用户注册时验证用户名是否被占用为例在输入的时候就在判断这个用户名是否已被注册。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数前<br><img src="/uploads/yangfan/DebounceThrottle/debouncebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数后<br><img src="/uploads/yangfan/DebounceThrottle/debounceafter.gif" width="400px"><br></div><br></div><p>使用防抖函数前做法存在明显缺陷当用户输入发生变化的时候，就请求判断了，不仅对服务器的压力增大了，而且用户在输入中时频繁的校验提示中断用户交互明显降低了用户体验。而理想的做法应该是，用户输入发生变化后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。而函数防抖所做的工作就是延迟一段时间去执行函数而在延迟期间又调用了此动作则重新计时。</p><h3 id="DemoCode"><a href="#DemoCode" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"ordinary"</span>&gt;</span>普通<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'ordinary'</span> <span class="attr">id</span>=<span class="string">'ordinary'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"debounce"</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'debounce'</span> <span class="attr">id</span>=<span class="string">'debounce'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ajax requestDtae:<span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ordinaryInput = <span class="built_in">document</span>.getElementById(<span class="string">'ordinary'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceInput = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceAjax = _.debounce(ajax, <span class="number">1000</span>)</span><br><span class="line">ordinaryInput.addEventListener(<span class="string">'keyup'</span>, ajax);</span><br><span class="line">debounceInput.addEventListener(<span class="string">'keyup'</span>, debounceAjax);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            func(args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Throttle（节流）"><a href="#Throttle（节流）" class="headerlink" title="Throttle（节流）"></a>Throttle（节流）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></blockquote><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>在瀑布流式布局的页面中，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。在发生滚动时就需要判断页面是否滚动到底部。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用节流函数前<br><img src="/uploads/yangfan/DebounceThrottle/throttlebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用节流函数后<br><img src="/uploads/yangfan/DebounceThrottle/throttleafter.gif" width="400px"><br></div><br></div><p>使用节流函数前明显缺点是消耗性能，因为当在滚动的时候，浏览器会无时不刻地在计算判断是否滚动到底部的逻辑，而在实际的场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间在去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时不刻地在执行的函数。</p><h3 id="DemoCode-1"><a href="#DemoCode-1" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`scroll bodyY:<span class="subst">$&#123;body.getBoundingClientRect().y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throttleScrollAnimation = _.throttle(scrollAnimation, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//window.addEventListener('scroll', scrollAnimation);</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttleScrollAnimation);</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">let</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (curr - start &gt;= wait) &#123;</span><br><span class="line">            func(args);</span><br><span class="line">            start = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                func(args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果还是不能完全体会 debounce 和 throttle 的差异，可以到 <a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">这个页面</a> 看一下两者可视化的比较。<br>在实际的开发中根据根据需求的不同合理使用 debounce 或 throttle。<br>例如：在模糊查询时使用 debounce 在无限滚动时使用 throttle。（requestAnimationFrame）</p><h2 id="附lodash实现代码"><a href="#附lodash实现代码" class="headerlink" title="附lodash实现代码"></a>附lodash实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isObject <span class="keyword">from</span> <span class="string">'./isObject.js'</span></span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">'./.internal/root.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a debounced function that delays invoking `func` until after `wait`</span></span><br><span class="line"><span class="comment"> * milliseconds have elapsed since the last time the debounced function was</span></span><br><span class="line"><span class="comment"> * invoked, or until the next browser frame is drawn. The debounced function</span></span><br><span class="line"><span class="comment"> * comes with a `cancel` method to cancel delayed `func` invocations and a</span></span><br><span class="line"><span class="comment"> * `flush` method to immediately invoke them. Provide `options` to indicate</span></span><br><span class="line"><span class="comment"> * whether `func` should be invoked on the leading and/or trailing edge of the</span></span><br><span class="line"><span class="comment"> * `wait` timeout. The `func` is invoked with the last arguments provided to the</span></span><br><span class="line"><span class="comment"> * debounced function. Subsequent calls to the debounced function return the</span></span><br><span class="line"><span class="comment"> * result of the last `func` invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **Note:** If `leading` and `trailing` options are `true`, `func` is</span></span><br><span class="line"><span class="comment"> * invoked on the trailing edge of the timeout only if the debounced function</span></span><br><span class="line"><span class="comment"> * is invoked more than once during the `wait` timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span></span><br><span class="line"><span class="comment"> * until the next tick, similar to `setTimeout` with a timeout of `0`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`</span></span><br><span class="line"><span class="comment"> * invocation will be deferred until the next frame is drawn (typically about</span></span><br><span class="line"><span class="comment"> * 16ms).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span></span><br><span class="line"><span class="comment"> * for details over the differences between `debounce` and `throttle`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 0.1.0</span></span><br><span class="line"><span class="comment"> * @category Function</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func The function to debounce.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [wait=0]</span></span><br><span class="line"><span class="comment"> *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is</span></span><br><span class="line"><span class="comment"> *  used (if available).</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; [options=&#123;&#125;] The options object.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.leading=false]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the leading edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [options.maxWait]</span></span><br><span class="line"><span class="comment"> *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.trailing=true]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125; Returns the new debounced function.</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Avoid costly calculations while the window size is in flux.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('resize', debounce(calculateLayout, 150))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Invoke `sendMail` when clicked, debouncing subsequent calls.</span></span><br><span class="line"><span class="comment"> * jQuery(element).on('click', debounce(sendMail, 300, &#123;</span></span><br><span class="line"><span class="comment"> *   'leading': true,</span></span><br><span class="line"><span class="comment"> *   'trailing': false</span></span><br><span class="line"><span class="comment"> * &#125;))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span></span><br><span class="line"><span class="comment"> * const debounced = debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;)</span></span><br><span class="line"><span class="comment"> * const source = new EventSource('/stream')</span></span><br><span class="line"><span class="comment"> * jQuery(source).on('message', debounced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Cancel the trailing debounced invocation.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('popstate', debounced.cancel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Check for pending invocations.</span></span><br><span class="line"><span class="comment"> * const status = debounced.pending() ? "Pending..." : "Ready"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastArgs, </span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> maxing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span></span><br><span class="line">    <span class="keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> root.requestAnimationFrame === <span class="string">'function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = !!options.leading</span><br><span class="line">        maxing = <span class="string">'maxWait'</span> <span class="keyword">in</span> options</span><br><span class="line">        maxWait = maxing ? <span class="built_in">Math</span>.max(+options.maxWait || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = lastArgs</span><br><span class="line">        <span class="keyword">const</span> thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params">pendingFunc, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            root.cancelAnimationFrame(timerId);</span><br><span class="line">            <span class="keyword">return</span> root.requestAnimationFrame(pendingFunc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTimeout(pendingFunc, wait)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancelTimer</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.cancelAnimationFrame(id)</span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Reset any `maxWait` timer.</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        <span class="comment">// Start the timer for the trailing edge.</span></span><br><span class="line">        timerId = startTimer(timerExpired, wait)</span><br><span class="line">        <span class="comment">// Invoke the leading edge.</span></span><br><span class="line">        <span class="keyword">return</span> leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">        <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxing ?</span><br><span class="line">            <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke) :</span><br><span class="line">            timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either this is the first call, activity has stopped and we're at the</span></span><br><span class="line">        <span class="comment">// trailing edge, the system time has gone backwards and we're treating</span></span><br><span class="line">        <span class="comment">// it as the trailing edge, or we've hit the `maxWait` limit.</span></span><br><span class="line">        <span class="comment">// timeSinceLastCall &lt; 0 修改系统时间时不会出现bug</span></span><br><span class="line">        <span class="keyword">return</span> (lastCallTime === <span class="literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class="line">            (timeSinceLastCall &lt; <span class="number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">            <span class="keyword">return</span> trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restart the timer.</span></span><br><span class="line">        timerId = startTimer(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        timerId = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only invoke if we have `lastArgs` which means `func` has been</span></span><br><span class="line">        <span class="comment">// debounced at least once.</span></span><br><span class="line">        <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timerId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            cancelTimer(timerId)</span><br><span class="line">        &#125;</span><br><span class="line">        lastInvokeTime = <span class="number">0</span></span><br><span class="line">        lastArgs = lastCallTime = lastThis = timerId = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId === <span class="literal">undefined</span> ? result : trailingEdge(<span class="built_in">Date</span>.now())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId !== <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">const</span> isInvoking = shouldInvoke(time)</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = <span class="keyword">this</span></span><br><span class="line">        lastCallTime = time</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">                <span class="comment">// Handle invocations in a tight loop.</span></span><br><span class="line">                timerId = startTimer(timerExpired, wait)</span><br><span class="line">                <span class="keyword">return</span> invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            timerId = startTimer(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = <span class="string">'leading'</span> <span class="keyword">in</span> options ? !!options.leading : leading</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。&lt;/p&gt;
    
    </summary>
    
      <category term="yangfan" scheme="http://xgfe.github.io/categories/yangfan/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="debounce&amp;throttle" scheme="http://xgfe.github.io/tags/debounce-throttle/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 使用及原理分析</title>
    <link href="http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/"/>
    <id>http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-03-09T04:05:41.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。<br><a id="more"></a><br>那么问题来了，什么是依赖注入？</p><blockquote><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。<br>—摘自百度百科</p></blockquote><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在日常编码中经常会有类之间的依赖，为了方便理解，我们举个例子。手机类Phone包含了摄像头Camera组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        mCamera = new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到 Phone 和 Carmera 是耦合的，Phone 需要知道 Camera 的实现类 BackCamera 的存在，一旦 Camera 的实现变为其他，比如 FrontCamera 时，我们还需要修改 Phone 的构造方法。类似问题就可以使用依赖注入来解决。依赖注入的常用方法有构造方法注入和 setter 方法注入，两种方式都可以对 Phone 和 Camera 解耦，使得 Phone 无需关注 Camera 的实现，即使 Camera 的类型变了也无需修改 Phone 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone(Camera camera) &#123;</span><br><span class="line">        mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCamera(Camera camera) &#123;</span><br><span class="line">        this.mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Component-和-Inject"><a href="#Component-和-Inject" class="headerlink" title="@Component 和 @Inject"></a>@Component 和 @Inject</h3><p>那使用 Dagger2 该如何注入呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BackCamera implements Camera &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getCameraType() &#123;</span><br><span class="line">        return &quot;后置摄像头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera mCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到首先需要声明一个 @Component，然后需要在 BackCamera 的构造方法前增加注解 @Inject，接着在 Phone 的 mCamera 前增加 @Inject 以及构造方法中调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，几者间关系如下：</p><p><img src="/uploads/wangwenming/dagger-1.png" alt=""></p><h3 id="Module-和-Provides"><a href="#Module-和-Provides" class="headerlink" title="@Module 和 @Provides"></a>@Module 和 @Provides</h3><p>那么问题来了，@Inject 只能标记构造方法，如果需要注入的是来自三方库的对象怎么办呢？这就需要用到 @Module，下面我们用 @Module 改造下上面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    public BackCamera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component(modules = &#123;CameraModule.class&#125;)</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Module 和 @Provides 配合可以实现对三方库对象的注入。</p><h3 id="Named-和-Qualifier"><a href="#Named-和-Qualifier" class="headerlink" title="@Named 和 @Qualifier"></a>@Named 和 @Qualifier</h3><p>@Qualifier 是限定符用于自定义注解，@Named 是 @Qualifier 的一种实现。在一些情况下我们需要两个有相同父类或实现同一接口的依赖，当需求方使用的又是他们父类时，Component 就不知道到底提供哪一个了。还是拿手机举例，我们在原有基础上增加一个前置摄像头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera provideFrontCamera() &#123;</span><br><span class="line">        return new FrontCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera mFrontCamera;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera mBackCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为 Module 中的 provide 方法加上 @Named 注解，然后在需要使用的地方加上对应的 @Named 注解。上面例子同样可以使用 @Qualifier 来实现，使用 @Qualifier 定义两个运行时注解 @Front 和 @Back，使用两个注解替换上面的 @Named 注解即可。</p><h3 id="Singleton-和-Scope"><a href="#Singleton-和-Scope" class="headerlink" title="@Singleton 和 @Scope"></a>@Singleton 和 @Scope</h3><p>@Scope 同样用于自定义注解，我能可以通过 @Scope 自定义的注解来限定注解作用域，实现局部的单例；@Singleton 是 @Scope 的一个实现。在一些场景下我们需要使用单例，@Singleton 和 @Scope 可以帮助我们实现局部单例。为什么说是局部单例呢，因为 @Singleton 或 @Scope 能保证在对应的 Component 下是单例的，如果需要全局的单例，我们就需要其他手段保证 Component 是单例。下面看个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Singleton</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">    void inject(App app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Singleton</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public Logger()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;Logger&quot;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger2;</span><br><span class="line"></span><br><span class="line">    public App()&#123;</span><br><span class="line">        DaggerAppComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;App&quot;, &quot;app:&quot; + this);</span><br><span class="line">        logger.printMessage();</span><br><span class="line">        logger2.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 @Singleton 标注 Component 和需要注入的类即可。在上面的例子中，如果调用 App 的 printMessage 方法可以看到 logger 和 logger2 为同一对象，对于不同 App 对象的 logger 则是不同对象。当然我们也可以使用 @Scope 自定义一个注解来实现局部注解，来替换 @Singleton。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>前面简单介绍了 Dagger2 使用，接下来我们分析一下实现原理。Dagger2 在编译时根据注解生成一些辅助类，接下来我们具体分析下生成的辅助类。辅助类可以通过 DaggerXXXComponent 来快速定位。上面两个例子对应生成辅助类如下：</p><p><img src="/uploads/wangwenming/dagger-2.png" alt=""></p><p>简单来看辅助类和注解对应关系很明显，拿手机的例子来说对应关系如下：</p><table><thead><tr><th style="text-align:left">辅助类</th><th style="text-align:left">注解</th></tr></thead><tbody><tr><td style="text-align:left">BackCamera_Factory</td><td style="text-align:left">BackCamera 构造方法的 @Inject</td></tr><tr><td style="text-align:left">CameraModule_ProvideBackCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">CameraModule_ProvideFrontCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">DaggerPhoneComponent</td><td style="text-align:left">PhoneComponent 的 @Component</td></tr><tr><td style="text-align:left">Phone_MembersInjector</td><td style="text-align:left">Phone 对应的 @Inject</td></tr></tbody></table><p>原始类以及辅助类类图如下：</p><p><img src="/uploads/wangwenming/dagger-3.png" alt=""></p><p>接下来我们分析下具体的注入过程，首先 Phone 中会调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，我们来看下 DaggerPhoneComponent 的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Generated(</span><br><span class="line">  value = &quot;dagger.internal.codegen.ComponentProcessor&quot;,</span><br><span class="line">  comments = &quot;https://google.github.io/dagger&quot;</span><br><span class="line">)</span><br><span class="line">public final class DaggerPhoneComponent implements PhoneComponent &#123;</span><br><span class="line">  private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">  private DaggerPhoneComponent(Builder builder) &#123;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static PhoneComponent create() &#123;</span><br><span class="line">    return new Builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private void initialize(final Builder builder) &#123;</span><br><span class="line">    this.cameraModule = builder.cameraModule;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void inject(Phone phone) &#123;</span><br><span class="line">    injectPhone(phone);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Phone injectPhone(Phone instance) &#123;</span><br><span class="line">    Phone_MembersInjector.injectMFrontCamera(</span><br><span class="line">        instance, CameraModule_ProvideFrontCameraFactory.proxyProvideFrontCamera(cameraModule));</span><br><span class="line">    Phone_MembersInjector.injectMBackCamera(</span><br><span class="line">        instance, CameraModule_ProvideBackCameraFactory.proxyProvideBackCamera(cameraModule));</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">    private Builder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public PhoneComponent build() &#123;</span><br><span class="line">      if (cameraModule == null) &#123;</span><br><span class="line">        this.cameraModule = new CameraModule();</span><br><span class="line">      &#125;</span><br><span class="line">      return new DaggerPhoneComponent(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder cameraModule(CameraModule cameraModule) &#123;</span><br><span class="line">      this.cameraModule = Preconditions.checkNotNull(cameraModule);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DaggerPhoneComponent 在创建时首先会创建一个 CameraModule，在进行注入时首先会调用工厂的代理方法最终调用 Module 中对应 @Provides 的方法创建对象，然后通过 Phone_MembersInjector 将上面创建的对象进行注入，工厂与 Injector 核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 工厂类核心</span><br><span class="line"> public static Camera proxyProvideFrontCamera(CameraModule instance) &#123;</span><br><span class="line">    return Preconditions.checkNotNull(</span><br><span class="line">        instance.provideFrontCamera(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Injector 核心</span><br><span class="line"> public static void injectMBackCamera(Phone instance, Camera mBackCamera) &#123;</span><br><span class="line">    instance.mBackCamera = mBackCamera;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Dagger2 的基本使用并从辅助代码的源码层面进行了原理分析。关于从注解到辅助代码的生成并没有介绍，感兴趣的同学可以自行查阅注解处理器相关知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="wangwenming" scheme="http://xgfe.github.io/categories/wangwenming/"/>
    
    
      <category term="dagger2" scheme="http://xgfe.github.io/tags/dagger2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 React-Native 与 Redux 数据流</title>
    <link href="http://xgfe.github.io/2018/11/25/juga/%E6%B5%85%E8%B0%88React-Native%E4%B8%8ERedux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://xgfe.github.io/2018/11/25/juga/浅谈React-Native与Redux数据流/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2018-12-04T03:01:22.504Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。</p><a id="more"></a><h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React-Native 介绍"></a>React-Native 介绍</h4><ul><li><p>React-Native 在官网上给的定义是：使用 JavaScript 和 React 编写原生移动应用。在设计原理上是和 React 一致的，可以通过生命是的组件机制来搭建丰富多彩的用户界面。RN 产出的不是“网页应用”或者“HTML5应用”，RN 所产出的其实是一个真正的移动应用。从感受上来说和 Objective-C 或 Java 编写的应用基本是一样的。</p></li><li><p><a href="https://reactnative.cn/" target="_blank" rel="noopener">RN官网</a></p></li></ul><h4 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h4><ul><li><p>官网上有教大家如何构建一个新的 React-Native 应用，这里就不多说了，这里直接切入组件的开发。可以在项目里面新建一个 Component 组件文件夹，专门用来存放组件。在该文件家里面建一个 TestComponen 子文件夹，然后在此子文件下面再建 TestComponent.js 和TestComponentStyle.js 两个文件夹，组件的逻辑写在TestComponent.js 文件下，样式写在 TestComponentStyle.js 文件下。<br><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc82f8j20hk03uaaa.jpg" alt="文件结构"></p></li><li><p>JS文件分析</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">//引入Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  Button</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>; <span class="comment">//引入RN原生组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;Style&#125; <span class="keyword">from</span> <span class="string">'./TestComponentStyle'</span>; <span class="comment">//引入样式</span></span><br></pre></td></tr></table></figure><ul><li>简单的计数器实现</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc2m1qj207g010dfq.jpg" alt="计数器"></p><p>点击加号数字动态变化 +1，点击减号数字动态 -1。首先这个组件由一个 Text 和两个  Button 组件组成，其中 Text 组件中有两个变量，children 作为对外暴露的属性，写在 this.props 里面，state 是组件内部的可变化的状态，写在 this.state 里面。<br>官网上是这样描述 props 和 state：我们使用两种数据来控制一个组件：props 和 state.props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用 state 。<br>这里先介绍一下 render 函数部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; <span class="comment">//渲染函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">      children</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props; <span class="comment">//组件对外暴露的属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state; <span class="comment">//组件内部的状态</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="comment">//返回要渲染的组件</span></span><br><span class="line">      &lt;View style=&#123;Style.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;Style.txt&#125;&gt;&#123;<span class="string">`<span class="subst">$&#123;children&#125;</span> <span class="subst">$&#123;num&#125;</span>`</span>&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button title=&#123;'-'&#125; color=&#123;'red'&#125; onPress=&#123;this.clickBtnSub&#125;/</span>&gt;</span><br><span class="line">        &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;<span class="keyword">this</span>.clickBtnAdd&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件的结构由一个 View 组件包裹一个 Text ，两个 Button 组件。Text 组件为展示的数字名和数字大小，Button 则是两个加减按钮。</p><p>然后可以看到 Style.container 和 Style.txt 都是引自  TestComponentStyle.js 文件。接下来我们看一下该文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;StyleSheet&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Style = StyleSheet.create(&#123;</span><br><span class="line"><span class="comment">// styles</span></span><br><span class="line">  container: &#123;</span><br><span class="line">    flexDirection: <span class="string">'row'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'space-around'</span>,</span><br><span class="line">    width: <span class="number">200</span>,</span><br><span class="line">    height: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  txt: &#123;</span><br><span class="line">    fontSize: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个是 RN 样式的基本写法，这个文件专门放 css 层的东西。这里要注意的是 css 的属性值接受的是字符串形式，在 RN 里面的 css 很多样式的值都被阉割了，所以这点要特别注意，这里有个推荐的网站可以看常用的RN样式：<br><a href="https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html" target="_blank" rel="noopener">RN css 样式</a></p><p>然后可以看到 Button 组件里面分别有一个点击事件。clickBtnSub 事件处理减 1，clickBtnAdd 处理加 1。<br>这里我推荐是使用箭头函数来定义函数，就可以在该组件的作用域里面直接调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickBtnSub = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num - <span class="number">1</span>&#125;);<span class="comment">//调用setState()函数，改变组件内部的状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> clickBtnAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num + <span class="number">1</span>&#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h4><p>组件写好之后可以引入到某个功能模块中使用。这里我们可以建一个 TestModule 文件夹来存放模块文件，里面可以建这么几个文件。如下图<br><img src="https://wx2.sinaimg.cn/mw690/ba56005dgy1fxkcvcd0coj20ia08o755.jpg" alt="文件结构"><br>接下来我们一个一个来介绍这几个文件的用处。<br>其实上面的组件计数器，除了使用 setState 来改变数字还可以使用 Redux 来完成这件事。<br>接下来就让我们来看看如何使用 Redux 完成</p><ul><li>TestModule.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import部分省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _renderTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text&gt;计数器&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;num&#125; = this.props.data /</span><span class="regexp">/从store取得的数据，在reducer里面初始化</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*引入计数器组件*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View style=&#123;Style.container&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;TestComponent children=&#123;'数字: '&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*使用Redux完成的计数器*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;Text&gt;&#123;num&#125;&lt;/</span>Text&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'-'</span>&#125; color=&#123;<span class="string">'red'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.sub(num)&#125; /&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.add(num)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  (state) =&gt; (&#123; <span class="comment">//state其实就是store.getState()，得到数据</span></span><br><span class="line">    data: state.modules[CONSTANTS.NAME]</span><br><span class="line">  &#125;),</span><br><span class="line">  (dispatch) =&gt; (&#123; <span class="comment">//dispatch是一个发布器他需要接受一个对象用于触发reducer</span></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    add: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.add(num)),</span><br><span class="line">    sub: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.sub(num))</span><br><span class="line">  &#125;)</span><br><span class="line">)(TestModule);</span><br></pre></td></tr></table></figure></li></ul><p>模块的主要页面内容都是写在这个文件里面，这里我们直接从 components 引入了 TestComponent 组件进行使用。直接将组件当成标签名使用 <testcomponent>。这就是自定义组件方便的地方。中间可以看到组件渲染不一定要都放在 render() 里面，可以利用一个渲染函数，单独抽出来，这样可以让程序的结构上看起来更加明了，不要让所有的子组件都堆积在 render() 函数中。当然如果抽出来的组件内容太少，就没必要抽了。<br>这个文件的最下面 connect 函数是 Provider 提供的一种 store 注入方式，其中封装了两个函数，第一个函数其实是 store.getState() ，是从 store 得到数据的。<br>第二个函数 dispatch 是一个触发器，在里面写 action 函数来触发 reducer 来对数据进行所需要的操作。dispatch 触发 TestModuleActions.js 里面的函数。下面就介绍一下 TestModuleActions.js 文件<br>这里我们写了一个加一个减函数，接着在 actions.js 文件里定义这两个 action 函数。</testcomponent></p><ul><li>TestModuleActios.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ADD,</span><br><span class="line">  SUB</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ADD, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sub = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: SUB, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件主要是写 actions 的文件，定义 action，dispatch中根据 type 类型去 TestModuleReducers.js 那处理数据。通过 payload 把数据传到 reducer 里面。</p><ul><li>TestModuleConstants.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAME = <span class="string">'testmodule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action types</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/ADD`</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUB = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/SUB`</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件用来放全局常量。这里定义了 ADD 和 SUB 。</p><ul><li>TestModuleReducer.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ADD, SUB&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="comment">//初始化数据的地方</span></span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> handleActions(&#123; <span class="comment">//处理数据的地方</span></span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  [ADD]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SUB]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, initialState);</span><br></pre></td></tr></table></figure></li></ul><p>reducer 利用 action.payload 拿到从 action 传来的数据，处理数据，处理完返回。<br>这里就要说一下Redux的数据流了，请先看一下下图：<br><img src="https://wx3.sinaimg.cn/mw690/ba56005dgy1fxkcvc6dthj20xm0mk77l.jpg" alt="Redux Flow"></p><p>(图片来自网上)<br>这里我们在TestModule.js 文件中的 connect 中 dispatch( action ) ，把原先的计数器中数字 num (图中 previousState )，和 action ( ADD 或 SUB )传到了 reducer 里面，根据 actions 文件里面的 action 的 TYPE 来执行各自的数据处理。处理完之后就有新的 newState 传到 Store ，再传到组件中，驱动组件改变状态重新渲染。</p><ul><li>index.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./TestModule'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./TestModuleReducer'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./TestModuleActions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NAME&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  NAME,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  reducer,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件将 NAME，module，reducer，actions 暴露出去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 RN + Redux 为基础框架开发已有三个多月，很多东西都还需要多加学习研究，这只是最基础的组件和模块开发。</p><p>组件开发总的时间为十的话，一定要思考占七，动手写占三，认真的多思考组件的构造，这样在动手写的时候才能尽量的避免结构的冗余，或者是样式的冗余，而且要想为什么做这个组件，必需能在某个项目中能多次的使用该组件，这样组件的开发才会变得有意义，不然一个组件只用一次的话，就没有必要单独拿出来封装成一个组件。另外就是组件写的过程尽量的思考拓展性，很多结构不要写死了，这次组件可能只需要展示 2 个 tab，但是下一次就不一定了，所以写的时候要多想。</p><p>模块开发的时候，尽量保持结构层次的清晰，这样的话代码的维护就会得比较轻松，模块里有很多独立的功能部分可以单抽出来做成一个渲染函数，这样就能让 render 函数看起来没那么的冗余，且结构不会过于复杂。一些点击事件和逻辑功能也是能单独抽出来写成事件函数，这样的话，调试出问题的时候就可以快速定位到问题代码块。还有就是尽量避免写一些重复的组件，能简化的就简化，可以考虑使用 map 函数来渲染重复的组件。</p><p>虽然这里用 Redux 也实现了计数器，但是其实是杀鸡用牛刀了，这样的简单的数据重新渲染其实大可不必，用 setState 就可以了，当然 Redux 也有其优点，他让数据和我们的组件模块解耦，数据单独处理了，不需要在每一个组件中来对 state 进行管理，需要的数据从上游作为 props 传进来了。不过经常可以看到这么一句话，如果你不知道你为什么需要 Redux，那你就是不需要 Redux..   (=. = redux 对于新手真的有点不友好)</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/Helloyongwei/article/details/82937808" target="_blank" rel="noopener">Redux 的数据流</a></li><li><a href="https://www.jianshu.com/p/2a20c8485a90" target="_blank" rel="noopener">看了我这篇 RN 你就入门了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="juga" scheme="http://xgfe.github.io/categories/juga/"/>
    
    
      <category term="React-Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="http://xgfe.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>koa-router 源码解读</title>
    <link href="http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/"/>
    <id>http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/</id>
    <published>2018-09-27T11:18:00.000Z</published>
    <updated>2018-12-07T07:40:15.959Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果实现一个简单的路由，可以解析<code>node</code>原生<code>request即IncomingMessage</code>对象的<code>url</code>属性，用 <code>if...else</code>判断路径从而返回不同的结果；当然也可以利用<code>koa</code>的<code>request</code>对象和<code>response</code>对象来处理。下面就是用<code>koa</code>实现的简单路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pageUrl = <span class="string">`./page/<span class="subst">$&#123;page&#125;</span>`</span>;</span><br><span class="line">        fs.readFile(pageUrl, <span class="string">"binary"</span>, (err,data) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">444</span>);</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> page = <span class="string">'404.html'</span>;</span><br><span class="line">    <span class="keyword">switch</span>(url)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/index'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/todo'</span>:</span><br><span class="line">            page = <span class="string">'todo.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/404'</span>:</span><br><span class="line">            page = <span class="string">'404.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> render(page);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url = ctx.request.url;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> route(url);</span><br><span class="line">    </span><br><span class="line">    ctx.body = html;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'starting at 3000'</span>);</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>路由越多消耗的性能也就越大</li><li>不能对特殊路由添加中间件</li><li>也没有处理响应头类型</li></ul><p>更好的方法是使用面向对象的方式，根据请求的<code>path</code>和<code>method</code>执行相应的中间件处理函数；而在实际开发中我们常用的是<code>koa</code>路由库<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>。本文通过解析<code>koa-router</code>的源码来达到深入学习其原理的目的。</p><h2 id="kao-router的简单使用demo"><a href="#kao-router的简单使用demo" class="headerlink" title="kao-router的简单使用demo"></a>kao-router的简单使用demo</h2><p>使用<code>koa-router</code>第一步就是新建一个<code>router</code>实例对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> pagePromptRouter <span class="built_in">require</span>(<span class="string">'./controllers/pagePrompt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 创建router实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套路由</span></span><br><span class="line">router.use(<span class="string">'/admin/prompt'</span>, pagePromptRouter.routes(), pagePrompt.allowedMethods());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.routes()); </span><br><span class="line"><span class="comment">// 对请求进行一些限制处理</span></span><br><span class="line">app.use(router.allowedMethods()); </span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>构建应用的时候，我们的首要目标就是创建多个<code>CGI</code>接口以适配不同的业务需求，那么接下来就需要注册对应的路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/queryPagePromptList'</span>, queryPagePromptList);</span><br><span class="line">router.post(<span class="string">'/deletePagePromptById'</span>, deletePagePromptById);</span><br><span class="line">router.post(<span class="string">'/savePagePrompt'</span>, savePagePrompt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryPagePromptList</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> getResult();</span><br><span class="line">ctx.body = &#123;</span><br><span class="line">    data: result.data,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为了让<code>koa</code>实例使用我们配置后的路由模块，需要使用<code>routes()</code>方法将路由(上面的例子中为了代码分层使用了嵌套路由)加入到应用全局的中间件函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes());  <span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.allowedMethods()); <span class="comment">// 对请求进行一些限制处理</span></span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/router.js" target="_blank" rel="noopener">router.js</a></p><p><img src="http://vfile.meituan.net/xgfe/88ed43b2f2951c77384f10d7ff4e1a6a172778.png" alt="router"></p><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/layer.js" target="_blank" rel="noopener">layer.js</a></p><p><img src="http://vfile.meituan.net/xgfe/190cd799e93c05d43fd05b1bda3574ad116451.png" alt="layer"></p><p>router和layer的关系</p><p><img src="http://p0.meituan.net/xgfe/b736ea9f7cc83ba0f0aeaf22782185ff20689.png" alt="router-layer"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Router-构造函数"><a href="#Router-构造函数" class="headerlink" title="Router 构造函数"></a>Router 构造函数</h3><p><code>Node</code>本身提供了数十个<code>HTTP</code>请求动词，<code>koa-router</code>只是实现了部分常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Router(opts) &#123;</span><br><span class="line">  if (!(this instanceof Router)) &#123;</span><br><span class="line">    return new Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  this.methods = this.opts.methods || [</span><br><span class="line">    &apos;HEAD&apos;,</span><br><span class="line">    &apos;OPTIONS&apos;,</span><br><span class="line">    &apos;GET&apos;,</span><br><span class="line">    &apos;PUT&apos;,</span><br><span class="line">    &apos;PATCH&apos;,</span><br><span class="line">    &apos;POST&apos;,</span><br><span class="line">    &apos;DELETE&apos;</span><br><span class="line">  ];</span><br><span class="line">  //省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="router-get-post-delete-all…"><a href="#router-get-post-delete-all…" class="headerlink" title="router.(get|post|delete|all…)()"></a>router.(get|post|delete|all…)()</h3><p>这些请求动词的实现是通过第三方模块<a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>支持的，然后<code>koa-router</code>内部进行了注册处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 这里的methods就是上面的methods模块提供的数组</span><br><span class="line">methods.forEach(function (method) &#123;</span><br><span class="line">  Router.prototype[method] = function (name, path, middleware) &#123;</span><br><span class="line">    var middleware;</span><br><span class="line"></span><br><span class="line">    // 这段代码做了两件事：</span><br><span class="line">    // 1.name 参数是可选的，所以要做一些参数置换的处理</span><br><span class="line">    // 2.将所有路由中间件（因为可以注册多个中间件）合并成一个数组</span><br><span class="line">    if (typeof path === &apos;string&apos; || path instanceof RegExp) &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">      path = name;</span><br><span class="line">      name = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用register方法</span><br><span class="line">    this.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面函数先判断<code>path</code>是否是字符串或者正则表达式，是因为注册路由的时候还可以为路由进行命名(命名空间方便管理)，然后准确地获取回调的函数数组(注册路由可以接收多个回调)， 这样如果匹配到某个路由，回调函数数组中的函数就会依次执行。留意到每个方法都会返回对象本身，也就是说注册路由的时候是可以支持链式调用的。</p><h3 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h3><p><code>this.register</code>接受请求路径、方法、中间件作为参数，返回已经注册的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.register = function (path, methods, middleware, opts) &#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  var router = this;</span><br><span class="line"></span><br><span class="line">  // 全部路由</span><br><span class="line">  var stack = this.stack;</span><br><span class="line"></span><br><span class="line">  // 说明路由的path是支持数组的</span><br><span class="line">  // 如果是数组的话，需要递归调用register来注册路由，因为一个path对应一个路由</span><br><span class="line">  if (Array.isArray(path)) &#123;</span><br><span class="line">    path.forEach(function (p) &#123;</span><br><span class="line">      router.register.call(router, p, methods, middleware, opts);</span><br><span class="line">    &#125;);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建路由，路由就是Layer的实例</span><br><span class="line">  // methods是路由处理的http方法</span><br><span class="line">  // 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的</span><br><span class="line">  var route = new Layer(path, methods, middleware, &#123;</span><br><span class="line">    end: opts.end === false ? opts.end : true,</span><br><span class="line">    name: opts.name,</span><br><span class="line">    sensitive: opts.sensitive || this.opts.sensitive || false,</span><br><span class="line">    strict: opts.strict || this.opts.strict || false,</span><br><span class="line">    prefix: opts.prefix || this.opts.prefix || &quot;&quot;,</span><br><span class="line">    ignoreCaptures: opts.ignoreCaptures</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 处理路径前缀</span><br><span class="line">  if (this.opts.prefix) &#123;</span><br><span class="line">    route.setPrefix(this.opts.prefix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将全局的路由参数添加到每个路由中</span><br><span class="line">  Object.keys(this.params).forEach(function (param) &#123;</span><br><span class="line">    route.param(param, this.params[param]);</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 往路由数组中添加新创建的路由</span><br><span class="line">  stack.push(route);</span><br><span class="line"></span><br><span class="line">  return route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的逻辑我们应该知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/test&apos;, async (ctx, next) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>其实它相当于下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(&apos;/test&apos;, [&apos;GET&apos;], [async (ctx, next) =&gt; &#123;&#125;], &#123; name: null &#125;);</span><br></pre></td></tr></table></figure><p><code>register</code>函数将路由作为第一个参数传入，然后方法名放入到方法数组中作为第二个参数， 第三个函数是路由的回调数组；其实每个路由注册的时候，后面都可以添加很多个函数，而这些函数都会被添加到一个数组里面，如果被匹配到，就会利用中间件机制来逐个执行这些函数。最后一个参数是将路由的命名空间传入。</p><p>对于<code>stack</code>数组，则是存储每一个路由，也就是<code>Layer</code>的实例对象，每一个路由都相当于一个<code>Layer</code>实例对象。</p><p>对于<code>Layer</code>类来说, 创建一个实例对象用于管理每个路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Layer(path, methods, middleware, opts) &#123;</span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  // 路由命名</span><br><span class="line">  this.name = this.opts.name || null;</span><br><span class="line">  // 路由对应的方法</span><br><span class="line">  this.methods = [];</span><br><span class="line">  // 路由参数名数组</span><br><span class="line">  this.paramNames = [];</span><br><span class="line">  // 路由处理中间件数组</span><br><span class="line">  this.stack = Array.isArray(middleware) ? middleware : [middleware];</span><br><span class="line">  // 存储路由方法</span><br><span class="line">  methods.forEach(function(method) &#123;</span><br><span class="line">    var l = this.methods.push(method.toUpperCase());</span><br><span class="line">    if (this.methods[l-1] === &apos;GET&apos;) &#123;</span><br><span class="line">      this.methods.unshift(&apos;HEAD&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 将添加的回调处理中间件函数添加到Layer实例对象的 stack 数组中</span><br><span class="line">  this.stack.forEach(function(fn) &#123;</span><br><span class="line">    var type = (typeof fn);</span><br><span class="line">    if (type !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        methods.toString() + &quot; `&quot; + (this.opts.name || path) +&quot;`: `middleware` &quot;</span><br><span class="line">        + &quot;must be a function, not `&quot; + type + &quot;`&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  this.path = path;</span><br><span class="line">  this.regexp = pathToRegExp(path, this.paramNames, this.opts);</span><br><span class="line"></span><br><span class="line">  debug(&apos;defined route %s %s&apos;, this.methods, this.opts.prefix + this.path);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到, 对于<code>Layer</code>的实例对象, 核心的逻辑还是在于将<code>path</code>转化为正则表达式用于匹配请求的路由,  然后将路由的处理中间件添加到<code>Layer</code>的<code>stack</code>数组中。 注意这里的<code>stack</code>和<code>Router</code>里面的<code>stack</code>是不一样的, <code>Router</code>的<code>stack</code>数组是存放每个路由对应的<code>Layer</code>实例对象的, 而 <code>Layer</code>实例对象里面的<code>stack</code>数组是存储每个路由的处理函数中间件的, 换言之, 一个路由可以添加多个处理函数。</p><p>下面的图详细描述了<code>Router</code>和<code>Layer</code>的关系：</p><p><img src="https://vfile.meituan.net/xgfe/baf7698bb56fa67e38d3c84ad2121a0725705.png" alt="Router和Layer的关系"></p><h3 id="router-routes"><a href="#router-routes" class="headerlink" title="router.routes()"></a>router.routes()</h3><p><code>app.use(router.routes())</code>就这样，<code>koa-router</code>就启动了，所以大家也一定会很好奇这个<code>routes</code>函数到底做了什么，但可以肯定的是<code>router.routes()</code>返回了一个中间件函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch.router = this;</span><br><span class="line">  return dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里形成了一个闭包，在<code>routes</code>函数内部返回了一个<code>dispatch</code>函数作为中间件。 </p><p>接下来看下<code>dispatch</code>函数的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">    var path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line"></span><br><span class="line">    // router.match函数内部遍历所有路由（this.stack),</span><br><span class="line">    // 根据路径和请求方法找到对应的路由</span><br><span class="line">    // 返回的matched对象为： </span><br><span class="line">    /* </span><br><span class="line">      var matched = &#123;</span><br><span class="line">        path: [], // 保存了path匹配的路由数组</span><br><span class="line">        pathAndMethod: [], // 保存了path和methods都匹配的路由数组</span><br><span class="line">        route: false // 是否有对应的路由</span><br><span class="line">      &#125;;</span><br><span class="line">    */</span><br><span class="line">    var matched = router.match(path, ctx.method);</span><br><span class="line">    var layerChain, layer, i;</span><br><span class="line">    if (ctx.matched) &#123;</span><br><span class="line">      ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ctx.matched = matched.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有对应的路由，则直接进入下一个中间件</span><br><span class="line">    if (!matched.route) return next();</span><br><span class="line"></span><br><span class="line">    // 找到正确的路由的path</span><br><span class="line">    var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path;</span><br><span class="line">    ctx._matchedRoute = mostSpecificPath;</span><br><span class="line"></span><br><span class="line">    // 使用reduce方法将路由的所有中间件形成一条链</span><br><span class="line">    // 构建路径对应路由的处理中间件函数数组</span><br><span class="line">    // 这里的目的是在每个匹配的路由对应的中间件处理函数数组前添加一个用于处理</span><br><span class="line">    // 对应路由的 captures, params, 以及路由命名的函数</span><br><span class="line">    layerChain = matched.pathAndMethod.reduce(function(memo, layer) &#123;</span><br><span class="line"></span><br><span class="line">      // 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params</span><br><span class="line">      // 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了</span><br><span class="line">      memo.push(function(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">       // captures是存储路由中参数的值的数组</span><br><span class="line">        ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line"></span><br><span class="line">        // params是一个对象, 键为参数名, 根据参数名可以获取路由中的参数值, 值从captures中拿</span><br><span class="line">        ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line"></span><br><span class="line">        // 执行下一个中间件</span><br><span class="line">        return next();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // 将上面另外加的中间件和已有的路由中间件合并到一起</span><br><span class="line">      // 所以最终 layerChain 将会是一个中间件的数组</span><br><span class="line">      return memo.concat(layer.stack);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    // 最后调用上面提到的compose模块提供的方法，返回将layerChain(中间件的数组) </span><br><span class="line">    // 顺序执行所有中间件的执行函数， 并立即执行。</span><br><span class="line">    return compose(layerChain)(ctx, next);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="router-allowedMethod"><a href="#router-allowedMethod" class="headerlink" title="router.allowedMethod()"></a>router.allowedMethod()</h3><p>对于<code>allowedMethod</code>方法来说, 它的作用就是用于处理请求的错误, 所以它作为路由模块的最后一个函数来执行。同样地, 它也是以一个<code>koa</code>的中间件插件函数的形式出现, 同样在函数内部形成了一个闭包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = function (options) &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  var implemented = this.methods;</span><br><span class="line"></span><br><span class="line">  return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码很简单, 就是保存<code>Router</code>配置中允许的<code>HTTP</code>方法数组在闭包内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    // 从这里可以看出, allowedMethods函数是用于在中间件机制中处理返回结果的函数</span><br><span class="line">    // 先执行next函数, next函数返回的是一个Promise对象</span><br><span class="line">    return next().then(function() &#123;</span><br><span class="line">      var allowed = &#123;&#125;;</span><br><span class="line">      // allowedMethods函数的逻辑建立在statusCode没有设置或者值为404的时候</span><br><span class="line">      if (!ctx.status || ctx.status === 404) &#123;</span><br><span class="line">        // 这里的matched就是在match函数执行之后返回结果集中的 path 数组</span><br><span class="line">        // 也就是说请求路径与路由正则匹配的 layer 实例对象数组</span><br><span class="line">        ctx.matched.forEach(function (route) &#123;</span><br><span class="line">          // 将这些layer路由的HTTP方法存储起来</span><br><span class="line">          route.methods.forEach(function (method) &#123;</span><br><span class="line">            allowed[method] = method;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 将上面的allowed整理为数组</span><br><span class="line">        var allowedArr = Object.keys(allowed);</span><br><span class="line">        // implemented就是Router配置中的methods数组, 也就是允许的方法</span><br><span class="line">        // 这里通过~运算判断当前的请求方法是否在配置允许的方法中</span><br><span class="line">        // 如果该方法不被允许</span><br><span class="line">        if (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          // 如果 Router 配置中配置 throw 为 true</span><br><span class="line">          if (options.throw) &#123;</span><br><span class="line">            var notImplementedThrowable;</span><br><span class="line">            // 如果配置中规定了throw抛出错误的函数, 那么就执行对应的函数</span><br><span class="line">            if (typeof options.notImplemented === &apos;function&apos;) &#123;</span><br><span class="line">              notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 如果没有则直接抛出HTTP Error</span><br><span class="line">              notImplementedThrowable = new HttpError.NotImplemented();</span><br><span class="line">            &#125;</span><br><span class="line">            // 抛出错误</span><br><span class="line">            throw notImplementedThrowable;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // Router配置throw为false</span><br><span class="line">            // 设置状态码为 501</span><br><span class="line">            ctx.status = 501;</span><br><span class="line">            // 并且设置Allow头部, 值为上面得到的允许的方法数组allowedArr</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (allowedArr.length) &#123;</span><br><span class="line">          // 来到这里说明该请求的方法是被允许的, 那么为什么会没有状态码statusCode或者 statusCode为404呢?</span><br><span class="line">          // 原因在于除却特殊情况, 我们一般在业务逻辑里面不会处理OPTIONS请求的</span><br><span class="line">          // 发出这个请求一般常见就是非简单请求, 则会发出预检请求OPTIONS</span><br><span class="line">          // 例如 application/json 格式的POST请求</span><br><span class="line">          </span><br><span class="line">          // 如果是 OPTIONS 请求, 状态码为 200, 然后设置 Allow 头部, 值为允许的方法数组 methods</span><br><span class="line">          if (ctx.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">            ctx.status = 200;</span><br><span class="line">            ctx.body = &apos;&apos;;</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125; else if (!allowed[ctx.method]) &#123;</span><br><span class="line">          // 方法被服务端允许, 但是在路径匹配的路由中没有找到对应本次请求的方法的处理函数</span><br><span class="line">            // 类似上面的逻辑</span><br><span class="line">            if (options.throw) &#123;</span><br><span class="line">              var notAllowedThrowable;</span><br><span class="line">              if (typeof options.methodNotAllowed === &apos;function&apos;) &#123;</span><br><span class="line">                notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                notAllowedThrowable = new HttpError.MethodNotAllowed();</span><br><span class="line">              &#125;</span><br><span class="line">              throw notAllowedThrowable;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              // 这里的状态码为 405</span><br><span class="line">              ctx.status = 405;</span><br><span class="line">              ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是, <code>Router.methods</code>数组里面的方法是服务端需要实现并支持的方法, 如果客户端发送过来的请求方法不被允许, 那么这是一个服务端错误<code>501</code>, 但是如果这个方法被允许, 但是找不到对应这个方法的路由处理函数(比如相同路由的<code>POST</code>路由但是用<code>GET</code>方法来获取数据), 这是一个客户端错误<code>405</code>。</p><h3 id="router-use"><a href="#router-use" class="headerlink" title="router.use()"></a>router.use()</h3><p><code>use</code>函数就是用于添加中间件的, 只不过不同于<code>koa</code>中的<code>use</code>函数, <code>router</code>的<code>use</code>函数添加的中间件函数会在所有路由执行之前执行。此外, 它还可以对某些特定路径的进行中间件函数的绑定执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">router.prototype.use = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  // 中间件函数数组</span><br><span class="line">  var middleware = Array.prototype.slice.call(arguments);</span><br><span class="line">  var path;</span><br><span class="line"></span><br><span class="line">  // 支持同时为多个路由绑定中间件函数: router.use([&apos;/use&apos;, &apos;/admin&apos;], auth());</span><br><span class="line">  if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &apos;string&apos;) &#123;</span><br><span class="line">    middleware[0].forEach(function (p) &#123;</span><br><span class="line">      // 递归调用</span><br><span class="line">      router.use.apply(router, [p].concat(middleware.slice(1)));</span><br><span class="line">    &#125;);</span><br><span class="line">    // 直接返回, 下面是非数组 path 的逻辑</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果第一个参数有传值为字符串, 说明有传路径</span><br><span class="line">  var hasPath = typeof middleware[0] === &apos;string&apos;;</span><br><span class="line">  if (hasPath) &#123;</span><br><span class="line">    path = middleware.shift();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  middleware.forEach(function (m) &#123;</span><br><span class="line">    // 如果有router属性, 说明这个中间件函数是由 Router.prototype.routes暴露出来的</span><br><span class="line">    // 属于嵌套路由</span><br><span class="line">    if (m.router) &#123;</span><br><span class="line">      // 这里的逻辑很有意思, 如果是嵌套路由, 相当于将需要嵌套路由重新注册到现在的 Router 对象上</span><br><span class="line">      m.router.stack.forEach(function (nestedLayer) &#123;</span><br><span class="line">        // 如果有path, 那么为需要嵌套的路由加上路径前缀</span><br><span class="line">        if (path) nestedLayer.setPrefix(path);</span><br><span class="line">        // 如果本身的router有前缀配置, 也添加上</span><br><span class="line">        if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix);</span><br><span class="line">        // 将需要嵌套的路由模块的 stack 中存储的 Layer 加入到本 router 对象上</span><br><span class="line">        router.stack.push(nestedLayer);</span><br><span class="line">      &#125;);</span><br><span class="line">      // 这里与register函数的逻辑类似, 注册的时候检查添加参数校验函数 params</span><br><span class="line">      if (router.params) &#123;</span><br><span class="line">        Object.keys(router.params).forEach(function (key) &#123;</span><br><span class="line">          m.router.param(key, router.params[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 没有router属性则是常规中间件函数, 如果有给定的 path 那么就生成一个 Layer 模块进行管理</span><br><span class="line">      // 如果没有path, 那么就生成通配的路径 (.*) 来生成 Layer 来管理</span><br><span class="line">      router.register(path || &apos;(.*)&apos;, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>眼尖的同学可能会看到一些 http code：404, 501, 204, 405 。那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：</p><ul><li>如果请求的方法<code>koa-router</code>不支持并且没有设置<code>throw</code>选项，则返回<code>501</code>(未实现)</li><li>如果是<code>options</code>请求，则返回 <code>204</code>(无内容)</li><li>如果请求的方法支持但没有设置<code>throw</code>选项，则返回 <code>405</code>(不允许此方法 )</li></ul><h3 id="Router-prototype-match"><a href="#Router-prototype-match" class="headerlink" title="Router.prototype.match"></a>Router.prototype.match</h3><p>我们已经注册好了路由, 但是, 如果请求过来了, 请求是怎么匹配然后进行到相对应的处理函数去的呢? 答案就是利用<code>match</code>函数.先看一下<code>match</code>函数的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.match = function (path, method) &#123;</span><br><span class="line">  // 取所有路由 Layer 实例</span><br><span class="line">  var layers = this.stack;</span><br><span class="line">  var layer;</span><br><span class="line">  // 匹配结果</span><br><span class="line">  var matched = &#123;</span><br><span class="line">    path: [],</span><br><span class="line">    pathAndMethod: [],</span><br><span class="line">    route: false</span><br><span class="line">  &#125;;</span><br><span class="line">  // 遍历路由 Router 的 stack 逐个判断</span><br><span class="line">  for (var len = layers.length, i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    layer = layers[i];</span><br><span class="line"></span><br><span class="line">    debug(&apos;test %s %s&apos;, layer.path, layer.regexp);</span><br><span class="line">    // 这里是使用由路由字符串生成的正则表达式判断当前路径是否符合该正则</span><br><span class="line">    if (layer.match(path)) &#123;</span><br><span class="line">      // 将对应的 Layer 实例加入到结果集的 path 数组中</span><br><span class="line">      matched.path.push(layer);</span><br><span class="line">      // 如果对应的 layer 实例中 methods 数组为空或者数组中有找到对应的方法</span><br><span class="line">      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123;</span><br><span class="line">        // 将 layer 放入到结果集的 pathAndMethod 中</span><br><span class="line">        matched.pathAndMethod.push(layer);</span><br><span class="line">        // 这里是用于判断是否有真正匹配到路由处理函数</span><br><span class="line">        // 因为像 router.use(session()); 这样的中间件也是通过 Layer 来管理的, 它们的 methods 数组为空</span><br><span class="line">        if (layer.methods.length) matched.route = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return matched;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面返回的结果集, 我们知道一个请求来临的时候, 我们可以使用正则来匹配路由是否符合, 然后在<code>path</code>数组或者<code>pathAndMethod</code>数组中找到对应的<code>Layer</code>实例对象.</p><h2 id="router处理请求的流程"><a href="#router处理请求的流程" class="headerlink" title="router处理请求的流程"></a>router处理请求的流程</h2><p><img src="https://vfile.meituan.net/xgfe/63d452eb5a23d3fe3e1bf2e0219bceea93599.png" alt="router处理请求的流程"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>koa-router</code>用到了第三方的<code>node</code>模块</p><ul><li><p><a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a>:<br> 提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数。</p></li><li><p><a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>：<br> <code>node</code>中支持的<code>http</code>动词，就是<code>http.METHODS</code>，可以在终端输出看看。 </p></li><li><p><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>：<br> 将路径字符串转换成强大的正则表达式，还可以输出路径参数。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过分析<code>koa-router</code>的源码，总结了：</p><ul><li><code>koa-router</code>涉及到的<code>router</code>和<code>layer</code>的关系；</li><li><code>koa-router</code>处理请求的整体流程；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。&lt;/p&gt;
    
    </summary>
    
      <category term="zuopengfei" scheme="http://xgfe.github.io/categories/zuopengfei/"/>
    
    
      <category term="node" scheme="http://xgfe.github.io/tags/node/"/>
    
      <category term="koa" scheme="http://xgfe.github.io/tags/koa/"/>
    
      <category term="koa-router" scheme="http://xgfe.github.io/tags/koa-router/"/>
    
  </entry>
  
  <entry>
    <title>Category 与Extension 相关知识</title>
    <link href="http://xgfe.github.io/2018/08/24/wanglibin/category%E4%B8%8EExtension%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://xgfe.github.io/2018/08/24/wanglibin/category与Extension相关知识/</id>
    <published>2018-08-24T07:27:55.863Z</published>
    <updated>2018-08-24T07:27:55.864Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Category 和 Extension 的相关知识以及使用。<br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><ul><li>Category的背景和概念</li><li>Category的声明及实现</li><li>Category的使用</li><li>Category扩展属性（变量）</li></ul><h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><ul><li>Extension的格式</li><li>Extension的实现</li></ul><h2 id="Category和Extension的区别"><a href="#Category和Extension的区别" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><h3 id="一、Category"><a href="#一、Category" class="headerlink" title="一、Category"></a>一、Category</h3><h4 id="1、Category的背景和概念"><a href="#1、Category的背景和概念" class="headerlink" title="1、Category的背景和概念"></a>1、Category的背景和概念</h4><p>在日常开发中，经常需要对已有类进行功能上的扩展，在学习“类别”之前，常用的类扩展方式有以下三种：</p><ul><li>原有类的修改</li><li>继承</li><li>protocol（协议）</li></ul><p>针对以上三种扩展方式，</p><ol><li><p>第一种为最原始的方法；</p></li><li><p>第二种在继承父类的同时，也扩展自己，包括（方法和变量）。但是在面向对象的开发原则中“优先使用组合慎用继承”，因为继承在一定程度上破坏了封装性、子类随父类变动。</p></li><li><p>第三种协议，主要是依靠实现类的具体方法实现，当扩展功能时，需要修改原有类，协议定义过多，实现类过于庞大。</p></li></ol><p>那么，在oc中，当我们想避免上述两种扩展方式的缺点，又想只对现有类进行扩展些方法，并且不用去修改原有类以及使用它的地方的代码，就用到了Category（类别）。</p><p>类别是OC的特有语法，可以通过在类上声明和实现方法来扩展现有类的功能。原则上只能增加方法（包括对象方法和类方法），不能增加成员变量。</p><h4 id="2、Category的声明及实现"><a href="#2、Category的声明及实现" class="headerlink" title="2、Category的声明及实现"></a>2、Category的声明及实现</h4><pre><code>@interface 需扩展的类 （类别的名称）-（void）appendMethod;@end@implementation 需扩展的类 （类别的名称）-（void）appendMethod{}@end</code></pre><h4 id="3、Category的使用"><a href="#3、Category的使用" class="headerlink" title="3、Category的使用"></a>3、Category的使用</h4><p>如果需要扩展一个类，定义好此类的Category ，则可以通过该类的对象直接调用Category中的扩展方法。与此同时，在Category中也可以访问原有类.h中的属性和方法。</p><p>.h文件：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface pson : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;- (void) run;+ (void) jump;@end</code></pre><p>.m文件</p><pre><code>#import &quot;pson.h&quot;@implementation pson-(void) run{    NSLog(@&quot;run&quot;);}+(void) jump{    NSLog(@&quot;jump&quot;);}@end</code></pre><p>为pson类添加eat方法，Category的.m文件如下所示：</p><p>pson+eat.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;@end</code></pre><p>pson+eat.m文件</p><pre><code>#import &quot;pson+eat.h&quot;@implementation pson (eat)-(void) eat{   //调用原有类的公共方法[self run];//调用原有类的非私有属性NSLog(@&quot;%@&quot;,self.name);}+(void) drink{    NSLog(@&quot;drink&quot;);}@end</code></pre><p>在main方法中</p><pre><code>pson *me = [[pson alloc] init];    [me run];    //调用扩展类中的对象方法    [me eat];    //调用扩展类中的类方法    [pson drink]</code></pre><h4 id="4、Category扩展属性（变量）"><a href="#4、Category扩展属性（变量）" class="headerlink" title="4、Category扩展属性（变量）"></a>4、Category扩展属性（变量）</h4><p>由于Category本质上是个指向类型的结构体指针，在结构体中只有方法的列表，没有属性的列表，所以理论上只能增加方法不能增加属性。</p><p>如何通过Category来扩展属性呢？</p><p>无法添加属性的根本原因是：在Category中@property声明属性，系统不会生成_成员变量和setter、getter。</p><p>解决方法：手动添加setter和getter方法，采用的就是：关联引用（objc_setAssociatedObject和objc_getAssociatedObject）</p><p>其中，</p><p>objc_setAssociatedObject，接收4个参数：想关联到数据的对象、获取数据的键值、存储引用的值、关联的策略；</p><p>objc_getAssociatedObject，接收2个参数：关联到数据的对象、键值</p><p>常见的关联策略，如下表所示：</p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td>OBJC _ ASSOCIATION _ ASSIGN</td><td>指定值将被简单赋值、没有保留和释放</td></tr><tr><td>OBJC _ ASSOCIATION _ RETAIN _ NONATOMIC</td><td>指定值通过非线程安全的方式赋值并保留</td></tr><tr><td>OBJC _ ASSOCIATION _ COPY _ NONATOMIC</td><td>指定值通过非线程安全的方式复制</td></tr><tr><td>OBJC _ ASSOCIATION _ RETAIN</td><td>指定值通过线程安全的方式赋值并保留</td></tr><tr><td>OBJC _ ASSOCIATION _ COPY</td><td>指定值通过线程安全的方式复制</td></tr></tbody></table><p>具体实现例子如下所示：</p><p>Category的.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;+(void) drink;@end</code></pre><p>Category的.m文件</p><pre><code>#import &quot;pson+eat.h&quot;#import &quot;objc/runtime.h&quot;static NSString *key = @&quot;personEatKey&quot;;@implementation pson (eat)-(void) eat{    NSLog(@&quot;eat&quot;);}-(void) setFood:(NSString *)food{    objc_setAssociatedObject(self, &amp;key, food,     OBJC_ASSOCIATION_COPY);}-(NSString *) food{    return objc_getAssociatedObject(self, &amp;key);}@end</code></pre><p>main方法中的使用如下：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &quot;pson.h&quot;#import &quot;pson+eat.h&quot;int main(int argc, const char * argv[]) {    @autoreleasepool {        pson *me = [[pson alloc] init];        [me eat];        me.food = @&quot;鸡蛋&quot;;        NSLog(@&quot;%@&quot;,me.food);    }    return 0;}</code></pre><h3 id="二、Extension"><a href="#二、Extension" class="headerlink" title="二、Extension"></a>二、Extension</h3><p>Extension 是Category的特例，少了类别的名称，是匿名分类。声明私有方法和属性的机制。具体实现在原有类的.m文件中。</p><h4 id="1、Extension的格式"><a href="#1、Extension的格式" class="headerlink" title="1、Extension的格式"></a>1、Extension的格式</h4><pre><code>@interface XXX ()    //私有属性    //私有方法（如果不实现，编译时会报警,Method definition for &apos;XXX&apos; not found）@end</code></pre><h4 id="2、Extension的实现"><a href="#2、Extension的实现" class="headerlink" title="2、Extension的实现"></a>2、Extension的实现</h4><ul><li>通过单独的.h声明，在原有类的.m中导入。</li><li>直接在原有类的.m中使用。</li></ul><h2 id="Category和Extension的区别-1"><a href="#Category和Extension的区别-1" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><ul><li>Category原则上只能增加方法；而Extension方法和变量都可以。</li><li>Extension声明方法没有被实现，编译器报警。Category在运行时添加、Extension是编译阶段。</li><li>Extension没有自己独立的实现部分。</li><li>Extension是私有。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Category 和 Extension 的相关知识以及使用。&lt;br&gt;
    
    </summary>
    
      <category term="wanglibin" scheme="http://xgfe.github.io/categories/wanglibin/"/>
    
    
      <category term="OC" scheme="http://xgfe.github.io/tags/OC/"/>
    
      <category term="Category" scheme="http://xgfe.github.io/tags/Category/"/>
    
      <category term="Extension" scheme="http://xgfe.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>angularjs的双向数据绑定</title>
    <link href="http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs双向绑定/</id>
    <published>2018-08-15T13:00:00.000Z</published>
    <updated>2018-12-10T07:42:54.159Z</updated>
    
    <content type="html"><![CDATA[<p>angularjs的双向数据绑定原理及简单的实现。</p><a id="more"></a><p>之前对vue.js的双向绑定比较感兴趣，自己动手实现了一个类似于vue.js的mvvm框架。vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。其核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">this.watch = function(obj, callback) &#123;</span><br><span class="line">this.$observeObj = function() &#123;</span><br><span class="line">var that = this;</span><br><span class="line">this.callback = callback;</span><br><span class="line">//console.log(Object.keys(obj));</span><br><span class="line">Object.keys(obj).forEach(function(prop) &#123;</span><br><span class="line">var val = obj[prop];</span><br><span class="line">Object.defineProperty(obj, prop, &#123;</span><br><span class="line">get: function() &#123;</span><br><span class="line">return val;</span><br><span class="line">&#125;,</span><br><span class="line">set: function(newVal) &#123;</span><br><span class="line">var temp = val;</span><br><span class="line">//console.log(newVal);</span><br><span class="line">val = newVal;</span><br><span class="line">//通知所有订阅者改变</span><br><span class="line"></span><br><span class="line">that.cache.forEach(function(item) &#123;</span><br><span class="line">if (item[prop]) &#123;</span><br><span class="line">item[prop] = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">that.callback();</span><br><span class="line">&#125;,    </span><br><span class="line">enumerable: true,</span><br><span class="line">   configurable: true</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$observeObj();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>set</code>属性在改变数据的同时触发视图的更新。</p><p>angularjs实现数据双向绑定与vue.js有所不同，它依赖于脏值检测，这里我写了一个简易的版本，其主要代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">initWatch() &#123;  </span><br><span class="line">    for (let i = 0, len = this.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">        //用来保证初值的正常加载，以及当我改变input框中的值为空时能正常显示</span><br><span class="line">        this.flags.push(false);</span><br><span class="line">        this.watch(() =&gt; &#123;</span><br><span class="line">            let value = this.elements[i].value;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">            let key = this.elements[i].getAttribute(&apos;ng-model&apos;);</span><br><span class="line">            const elementType = this.elements[i].tagName.toLowerCase();</span><br><span class="line"></span><br><span class="line">            this.data[key] = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            //设置属性值</span><br><span class="line">            if (elementType === &apos;input&apos; || elementType === &apos;textarea&apos; || elementType === &apos;select&apos;) &#123;</span><br><span class="line">                this.elements[i].value = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.elements[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let j = 0, len = this.bind.length; j &lt; len; j++) &#123;</span><br><span class="line">                let item = this.bind[i].getAttribute(&apos;ng-bind&apos;);</span><br><span class="line">                if (item === key) &#123;</span><br><span class="line">                    this.bind[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&apos;keyup&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">    document.addEventListener(&apos;change&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听函数</span><br><span class="line">watch(watchFn, callback) &#123;</span><br><span class="line">    this.watchers.push(&#123;</span><br><span class="line">        watchFn: watchFn,</span><br><span class="line">        callback: callback || function() &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新数据</span><br><span class="line">digest() &#123;</span><br><span class="line">    let dirty;</span><br><span class="line">    do &#123;</span><br><span class="line">        dirty = false;</span><br><span class="line"></span><br><span class="line">    for (let i = 0, len = this.watchers.length; i &lt; len; i++) &#123;</span><br><span class="line">        let newVal = this.watchers[i].watchFn();</span><br><span class="line">        let oldVal = this.watchers[i].last;</span><br><span class="line"></span><br><span class="line">        if (newVal !== oldVal) &#123;</span><br><span class="line">            this.watchers[i].callback(newVal, oldVal);</span><br><span class="line">            dirty = true;</span><br><span class="line">            this.watchers[i].last = newVal;</span><br><span class="line">            this.flags[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; while(dirty);</span><br></pre></td></tr></table></figure><p><code>watch</code>接受两个参数（这里只考虑了单值的情况，用<code>ng-bind</code>来绑定值），监听的数据与监听的回调函数。digest函数只会在指定事件触发后，才执行，比如这里input框    ,改变输入的值会触发keyup事件，调用<code>digest</code>函数，这个函数会遍历所有的<code>watchers</code>，对比以前的值和新值是否一样，如果不一样就执行回调函数更新数据和视图。<br>我自己实现的版本很基础也很片面，我们可以看看angularjs源码对这部分的描述（这里看angularjs 1.3.20版本）：</p><h3 id="parse"><a href="#parse" class="headerlink" title="$parse"></a>$parse</h3><p><code>parse</code>是一个解析函数，angularjs中单独在一个名叫parse.js的文件中。我们从<code>$get</code>方法出发，它最后会返回一个<code>$parse</code>函数，这个函数的核心部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var lexer = new Lexer(parseOptions);</span><br><span class="line">var parser = new Parser(lexer, $filter, parseOptions);</span><br><span class="line">parsedExpression = parser.parse(exp);</span><br></pre></td></tr></table></figure><p>其中，<code>Lexer</code>这个构造函数中的<code>lex</code>方法用于解析传入数据的所有特殊情况，比如当我检测到这个监控数据为带有引号的字符串时（检查到第一个字符为单引号或者双引号），readString方法就会继续解析后面的字符，最后将结果存到this.tokens中，同理，当检测到是number类型的便会执行readNumber方法，将结果存在this.tokens中。<code>parse</code>就是处理<code>lexer</code>实例返回的this.tokens值，生成执行表达式，其实就是返回一个执行函数。因为这个函数中对四则运算也做了处理，所以当输入1+2的表达式时，最终会返回结果3。  </p><h3 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$watch: function(watchExp, listener, objectEquality) &#123;</span><br><span class="line">    var get = $parse(watchExp);</span><br><span class="line"></span><br><span class="line">    if (get.$$watchDelegate) &#123;</span><br><span class="line">      return get.$$watchDelegate(this, listener, objectEquality, get);</span><br><span class="line">    &#125;</span><br><span class="line">    var scope = this,</span><br><span class="line">        array = scope.$$watchers,</span><br><span class="line">        watcher = &#123;</span><br><span class="line">          fn: listener,</span><br><span class="line">          last: initWatchVal,</span><br><span class="line">          get: get,</span><br><span class="line">          exp: watchExp,</span><br><span class="line">          eq: !!objectEquality</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">    if (!isFunction(listener)) &#123;</span><br><span class="line">      watcher.fn = noop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!array) &#123;</span><br><span class="line">      array = scope.$$watchers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // we use unshift since we use a while loop in $digest for speed.</span><br><span class="line">    // the while loop reads in reverse order.</span><br><span class="line">    array.unshift(watcher);</span><br><span class="line"></span><br><span class="line">    return function deregisterWatch() &#123;</span><br><span class="line">      arrayRemove(array, watcher);</span><br><span class="line">      lastDirtyWatch = null;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>$watch</code>主要接收三个参数:监听的数据，监听的回调函数，是否深度监听。  </p><ul><li>watch参数：  </li><li>fn：监听函数，当新旧值不想等的时候会执行  </li><li>last：存放旧值  </li><li>get：保存监控表达式对应的函数，主要用来获取表达式的值做新旧值的对比  </li><li>exp：原始监控表达式  </li><li>eq：是否深度比较，存储的是<code>$watch</code>的第三个参数  </li></ul><p>当需要监听数据的时候，<code>get.$$watchDelegate</code>是否存在取决于<code>parse</code>中的parsedExpression.constant的值，而它的值取决于<code>$watch</code>监听的数据是否为常量，如果是常量的话，这个监听函数只会执行一次，不会被push进<code>$$watchers</code>的队列中，如果监听的是变量，那么这个<code>watch</code>会被push到<code>$$watchers</code>队列的最前面。最后会返回一个函数，这个函数的功能就是删除当前的<code>watch</code>，所以如果我们想取消这个监听，可以用一个变量接收<code>$watch</code>的返回值，再执行这个函数就达到了效果。</p><h3 id="evalAsync"><a href="#evalAsync" class="headerlink" title="$evalAsync"></a>$evalAsync</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$evalAsync: function(expr, locals) &#123;</span><br><span class="line">// if we are outside of an $digest loop and this is the first time we are scheduling async</span><br><span class="line">// task also schedule async auto-flush</span><br><span class="line">if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) &#123;</span><br><span class="line">  $browser.defer(function() &#123;</span><br><span class="line">    if (asyncQueue.length) &#123;</span><br><span class="line">      $rootScope.$digest();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncQueue.push(&#123;scope: this, expression: expr, locals: locals&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>$evalAsync</code>函数的作用是延迟执行表达式，<code>$$asyncQueue</code>是一个异步的队列，保存着所有需要异步执行的表达式。<code>$bowser.defer</code>是用setTimeout来实现的。</p><h3 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">$digest: function() &#123;</span><br><span class="line">       var watch, value, last,</span><br><span class="line">           watchers,</span><br><span class="line">           length,</span><br><span class="line">           dirty, ttl = TTL,</span><br><span class="line">           next, current, target = this,</span><br><span class="line">           watchLog = [],</span><br><span class="line">           logIdx, logMsg, asyncTask;</span><br><span class="line"></span><br><span class="line">       beginPhase(&apos;$digest&apos;);</span><br><span class="line">       // Check for changes to browser url that happened in sync before the call to $digest</span><br><span class="line">       $browser.$$checkUrlChange();</span><br><span class="line"></span><br><span class="line">       if (this === $rootScope &amp;&amp; applyAsyncId !== null) &#123;</span><br><span class="line">         // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span><br><span class="line">         // cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span><br><span class="line">         $browser.defer.cancel(applyAsyncId);</span><br><span class="line">         flushApplyAsync();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">       do &#123; // &quot;while dirty&quot; loop</span><br><span class="line">         dirty = false;</span><br><span class="line">         current = target;</span><br><span class="line"></span><br><span class="line">         while (asyncQueue.length) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">             asyncTask = asyncQueue.shift();</span><br><span class="line">             asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);</span><br><span class="line">           &#125; catch (e) &#123;</span><br><span class="line">             $exceptionHandler(e);</span><br><span class="line">           &#125;</span><br><span class="line">           lastDirtyWatch = null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         traverseScopesLoop:</span><br><span class="line">          do &#123; // &quot;traverse the scopes&quot; loop</span><br><span class="line">           if ((watchers = current.$$watchers)) &#123;</span><br><span class="line">             // process our watches</span><br><span class="line">             length = watchers.length;</span><br><span class="line">             while (length--) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 watch = watchers[length];</span><br><span class="line">                 // Most common watches are on primitives, in which case we can short</span><br><span class="line">                 // circuit it with === operator, only when === fails do we use .equals</span><br><span class="line">                 if (watch) &#123;</span><br><span class="line">                   if ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</span><br><span class="line">                       !(watch.eq</span><br><span class="line">                           ? equals(value, last)</span><br><span class="line">                           : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">                              &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) &#123;</span><br><span class="line">                     dirty = true;</span><br><span class="line">                     lastDirtyWatch = watch;</span><br><span class="line">                     watch.last = watch.eq ? copy(value, null) : value;</span><br><span class="line">                     watch.fn(value, ((last === initWatchVal) ? value : last), current);</span><br><span class="line">                     if (ttl &lt; 5) &#123;</span><br><span class="line">                       logIdx = 4 - ttl;</span><br><span class="line">                       if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">                       watchLog[logIdx].push(&#123;</span><br><span class="line">                         msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">                         newVal: value,</span><br><span class="line">                         oldVal: last</span><br><span class="line">                       &#125;);</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">                     // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">                     // have already been tested.</span><br><span class="line">                     dirty = false;</span><br><span class="line">                     break traverseScopesLoop;</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125; catch (e) &#123;</span><br><span class="line">                 $exceptionHandler(e);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">            // Insanity Warning: scope depth-first traversal</span><br><span class="line">           // yes, this code is a bit crazy, but it works and we have tests to prove it!</span><br><span class="line">           // this piece should be kept in sync with the traversal in $broadcast</span><br><span class="line">           if (!(next = (current.$$childHead ||</span><br><span class="line">               (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">             while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">               current = current.$parent;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; while ((current = next));</span><br><span class="line"></span><br><span class="line">         // `break traverseScopesLoop;` takes us to here</span><br><span class="line"></span><br><span class="line">         if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">           clearPhase();</span><br><span class="line">           throw $rootScopeMinErr(&apos;infdig&apos;,</span><br><span class="line">               &apos;&#123;0&#125; $digest() iterations reached. Aborting!\n&apos; +</span><br><span class="line">               &apos;Watchers fired in the last 5 iterations: &#123;1&#125;&apos;,</span><br><span class="line">               TTL, watchLog);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; while (dirty || asyncQueue.length);</span><br><span class="line"></span><br><span class="line">       clearPhase();</span><br><span class="line"></span><br><span class="line">       while (postDigestQueue.length) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">           postDigestQueue.shift()();</span><br><span class="line">         &#125; catch (e) &#123;</span><br><span class="line">           $exceptionHandler(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p><code>asyncQueue</code>代表异步队列，这里有两层循环，外层循环是为了保证所有的model都能被检测到，循环的两个条件，一是asyncQueue.length不为空；二是dirty为true,在监控watch的值的变化时，会将dirty置为true，循环开始会执行<code>asyncQueue</code>队列中的表达式。</p><p>内层循环用来遍历所有的watch函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(value = watch.get(current)) !== (last = watch.last) &amp;&amp;  </span><br><span class="line">!(watch.eq</span><br><span class="line">    ? equals(value, last)</span><br><span class="line">    : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">       &amp;&amp; isNaN(value) &amp;&amp; isNaN(last))))</span><br></pre></td></tr></table></figure><p>判断新值和旧值是否发生了变化，并且用watch.eq判断是否为深度监听，<code>equals</code>函数用来比较两个值是否相等，这个函数把所有可能的情况都考虑了进去，以前自己实现过两个值的比较，但是对于像DateRegExp这种类型的值的比较是没有考虑的，也正好查漏补缺。<br>内层循环的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">  while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">    current = current.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码表示，在当前作用域下执行完对watch的监控之后，还要继续查找它的子作用域，兄弟作用域，父作用域，如果next有值就会一直循环，直到这一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (ttl &lt; 5) &#123;</span><br><span class="line">    logIdx = 4 - ttl;</span><br><span class="line">    if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">    watchLog[logIdx].push(&#123;</span><br><span class="line">      msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">      newVal: value,</span><br><span class="line">      oldVal: last</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">  // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">  // have already been tested.</span><br><span class="line">  dirty = false;</span><br><span class="line">  break traverseScopesLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的ttl的初始值为10（默认值），ttl的存在就是为了防止循环次数过多，如果超过最大次数，就会throw错误并告诉开发者循环可能永远不会稳定。当ttl小于5的时候开始记录<code>watchLog</code>对象，如果当前的watch与最后一次检查的<code>lastDirtyWatch</code>相等的话就跳出内层循环同时结束外层循环。最后会执行<code>postDigestQueue</code>队列中的函数，这个跟asyncQueue不同的是，它不会主动触发<code>digest</code>方法,只是往<code>postDigestQueue</code>队列中增加执行表达式，在<code>digest</code>内最后执行。</p><p>通过阅读angularjs脏值检测的源码部分，对它底层的实现有了大致的了解，对于parse.js可以作为一个字符串的解析器，实际场景比如实现一个计算器，equals函数用来比较两个值是否相等，都是值得借鉴的部分。与之前实现的简易版本比较，实际angularjs框架做的东西就多得多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;angularjs的双向数据绑定原理及简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangxiaotong" scheme="http://xgfe.github.io/categories/yangxiaotong/"/>
    
    
      <category term="angularjs" scheme="http://xgfe.github.io/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>Day.js 源码学习</title>
    <link href="http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/"/>
    <id>http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/</id>
    <published>2018-07-11T04:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。<br><a id="more"></a></p><p>📚<a href="https://github.com/iamkun/dayjs/blob/master/docs/zh-cn/API-reference.md" target="_blank" rel="noopener">官方 API 文档（中文）</a></p><h2 id="一-特性"><a href="#一-特性" class="headerlink" title="一 特性"></a>一 特性</h2><ul><li>和 Moment.js 相同的 API 和用法</li><li>不可变数据（Immutable）</li><li>支持链式操作（Chainable）</li><li>l18n 国际化</li><li>仅 2kb 大小</li><li>全浏览器兼容</li></ul><p>基本用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(<span class="string">'month'</span>).add(<span class="number">1</span>, <span class="string">'day'</span>).set(<span class="string">'year'</span>, <span class="number">2018</span>).format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="二-解析"><a href="#二-解析" class="headerlink" title="二 解析"></a>二 解析</h2><h3 id="构造器-dayjs-existing-string-number-Date-Dayjs"><a href="#构造器-dayjs-existing-string-number-Date-Dayjs" class="headerlink" title="构造器 dayjs(existing?: string | number | Date | Dayjs)"></a>构造器 dayjs(existing?: string | number | Date | Dayjs)</h3><p>从源码可以看出，调用 dayjs 时会返回一个 Dayjs 对象，Dayjs 构造器调用了 parseDate 方法，返回了一个全新的包含 Javascript Date 对象的 Dayjs 的对象；其他的值都是根据 Javascript Date 对象得来的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="function">(<span class="params">date, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDayjs(date)) &#123;</span><br><span class="line">    <span class="keyword">return</span> date.clone()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cfg = c || &#123;&#125;</span><br><span class="line">  cfg.date = date</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Dayjs(cfg) <span class="comment">// eslint-disable-line no-use-before-define</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> parseDate = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> reg</span><br><span class="line">  <span class="keyword">if</span> (date === <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="literal">NaN</span>) <span class="comment">// Treat null as an invalid date</span></span><br><span class="line">  <span class="keyword">if</span> (Utils.isUndefined(date)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> date</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> date === <span class="string">'string'</span>)</span><br><span class="line">    &amp;&amp; (<span class="regexp">/.*[^Z]$/i</span>.test(date)) <span class="comment">// looking for a better way</span></span><br><span class="line">    &amp;&amp; (reg = date.match(C.REGEX_PARSE))) &#123;</span><br><span class="line">    <span class="comment">// 2018-08-08 or 20180808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(</span><br><span class="line">      reg[<span class="number">1</span>], reg[<span class="number">2</span>] - <span class="number">1</span>, reg[<span class="number">3</span>] || <span class="number">1</span>,</span><br><span class="line">      reg[<span class="number">5</span>] || <span class="number">0</span>, reg[<span class="number">6</span>] || <span class="number">0</span>, reg[<span class="number">7</span>] || <span class="number">0</span>, reg[<span class="number">8</span>] || <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date) <span class="comment">// timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dayjs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parse(cfg) <span class="comment">// for plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">  parse(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$d = parseDate(cfg.date)</span><br><span class="line">    <span class="keyword">this</span>.init(cfg)</span><br><span class="line">  &#125;</span><br><span class="line">  init(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$y = <span class="keyword">this</span>.$d.getFullYear()</span><br><span class="line">    <span class="keyword">this</span>.$M = <span class="keyword">this</span>.$d.getMonth()</span><br><span class="line">    <span class="keyword">this</span>.$D = <span class="keyword">this</span>.$d.getDate()</span><br><span class="line">    <span class="keyword">this</span>.$W = <span class="keyword">this</span>.$d.getDay()</span><br><span class="line">    <span class="keyword">this</span>.$H = <span class="keyword">this</span>.$d.getHours()</span><br><span class="line">    <span class="keyword">this</span>.$m = <span class="keyword">this</span>.$d.getMinutes()</span><br><span class="line">    <span class="keyword">this</span>.$s = <span class="keyword">this</span>.$d.getSeconds()</span><br><span class="line">    <span class="keyword">this</span>.$ms = <span class="keyword">this</span>.$d.getMilliseconds()</span><br><span class="line">    <span class="keyword">this</span>.$L = <span class="keyword">this</span>.$L || parseLocale(cfg.locale, <span class="literal">null</span>, <span class="literal">true</span>) || L</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 init 实例方法中，使用实例属性 $d（为 JavaScript 原生 Date 对象）来获取 年、月、日、周、时、分、秒、毫秒，且保存在实例中。并且调用 parseLocale 函数来获取语言，赋值给 Dayjs 实例的 $L 属性。</p><p>可传参数有5类：  </p><h5 id="1-当前时间"><a href="#1-当前时间" class="headerlink" title="1.当前时间"></a>1.当前时间</h5><p>dayjs 本质上是个函数，因此可以直接运行该函数，得到包含当前时间和日期的 Dayjs 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs();</span><br></pre></td></tr></table></figure></p><h5 id="2-标准的-ISO-8601-时间字符串"><a href="#2-标准的-ISO-8601-时间字符串" class="headerlink" title="2.标准的 ISO 8601 时间字符串"></a>2.标准的 ISO 8601 时间字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="string">"2018-07-14"</span>);</span><br></pre></td></tr></table></figure><h5 id="3-解析-Unix-时间戳-毫秒"><a href="#3-解析-Unix-时间戳-毫秒" class="headerlink" title="3.解析 Unix 时间戳(毫秒)"></a>3.解析 Unix 时间戳(毫秒)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="number">1531469940578</span>);</span><br></pre></td></tr></table></figure><h5 id="4-解析-Date-对象"><a href="#4-解析-Date-对象" class="headerlink" title="4.解析 Date 对象"></a>4.解析 Date 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h5 id="5-解析-dayjs-对象"><a href="#5-解析-dayjs-对象" class="headerlink" title="5.解析 dayjs 对象"></a>5.解析 dayjs 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(dayjs());</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>dayjs 对象是不可变的如果要复制对象，需要调用 .clone()，或者是在解析一个 dayjs 对象。 向 dayjs() 里传入一个 Dayjs 对象也能实现同样的效果。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().clone();</span><br><span class="line">dayjs(Dayjs);</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="function">(<span class="params">date, instance</span>) =&gt;</span> dayjs(date, &#123; <span class="attr">locale</span>: instance.$L &#125;)</span><br><span class="line">clone() &#123;</span><br><span class="line">  <span class="keyword">return</span> wrapper(<span class="keyword">this</span>.toDate(), <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>检测当前 Dayjs 对象是否是一个有效的时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().isValid();</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isValid() &#123;</span><br><span class="line">  <span class="keyword">return</span> !(<span class="keyword">this</span>.$d.toString() === <span class="string">'Invalid Date'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三-获取-设置"><a href="#三-获取-设置" class="headerlink" title="三 获取+设置"></a>三 获取+设置</h2><h5 id="获取各种时间"><a href="#获取各种时间" class="headerlink" title="获取各种时间"></a>获取各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dayjs().year();        <span class="comment">// 年</span></span><br><span class="line">dayjs().month();       <span class="comment">// 月</span></span><br><span class="line">dayjs().date();        <span class="comment">// 日</span></span><br><span class="line">dayjs().day();         <span class="comment">// 星期(星期天 0, 星期六 6)</span></span><br><span class="line">dayjs().hour();        <span class="comment">// 时</span></span><br><span class="line">dayjs().minute();      <span class="comment">// 分</span></span><br><span class="line">dayjs().second();      <span class="comment">// 秒</span></span><br><span class="line">dayjs().millisecond(); <span class="comment">// 毫秒</span></span><br></pre></td></tr></table></figure><h5 id="设置各种时间"><a href="#设置各种时间" class="headerlink" title="设置各种时间"></a>设置各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().set(unit : <span class="built_in">String</span>, <span class="attr">value</span> : Int);</span><br><span class="line">dayjs().set(<span class="string">'date'</span>, <span class="number">1</span>);</span><br><span class="line">dayjs().set(<span class="string">'month'</span>, <span class="number">3</span>); <span class="comment">// 四月</span></span><br><span class="line">dayjs().set(<span class="string">'second'</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>设置时间也是通过返回一个新的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(string, int) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clone().$set(string, int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四-格式化显示"><a href="#四-格式化显示" class="headerlink" title="四 格式化显示"></a>四 格式化显示</h2><p>格式化显示和 momentjs 一样，通过 .format() 即可，返回的是 String 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().format(<span class="built_in">String</span>);</span><br><span class="line">dayjs().format();             <span class="comment">// "2018-07-13T20:10:31+08:00"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// "2018-07-13"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY/MM/DD'</span>); <span class="comment">// "2018/07/13"</span></span><br></pre></td></tr></table></figure></p><h2 id="五-操作"><a href="#五-操作" class="headerlink" title="五 操作"></a>五 操作</h2><h5 id="增加和减少"><a href="#增加和减少" class="headerlink" title="增加和减少"></a>增加和减少</h5><p>在此之前先看看源码实现的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 部分源码</span></span><br><span class="line">add(number, units) &#123;</span><br><span class="line">  number = <span class="built_in">Number</span>(number) <span class="comment">// eslint-disable-line no-param-reassign</span></span><br><span class="line">  <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">  <span class="keyword">const</span> instanceFactory = <span class="function">(<span class="params">u, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">this</span>.set(C.DATE, <span class="number">1</span>).set(u, n + number)</span><br><span class="line">    <span class="keyword">return</span> date.set(C.DATE, <span class="built_in">Math</span>.min(<span class="keyword">this</span>.$D, date.daysInMonth()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.M) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.M, <span class="keyword">this</span>.$M)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.Y) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.Y, <span class="keyword">this</span>.$y)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> step</span><br><span class="line">  <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">    <span class="keyword">case</span> C.MIN:</span><br><span class="line">      step = C.MILLISECONDS_A_MINUTE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.H:</span><br><span class="line">      step = C.MILLISECONDS_A_HOUR</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.D:</span><br><span class="line">      step = C.MILLISECONDS_A_DAY</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.W:</span><br><span class="line">      step = C.MILLISECONDS_A_WEEK</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.S:</span><br><span class="line">      step = C.MILLISECONDS_A_SECOND</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// ms</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextTimeStamp = <span class="keyword">this</span>.valueOf() + (number * step)</span><br><span class="line">  <span class="keyword">return</span> wrapper(nextTimeStamp, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">subtract(number, string) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.add(number * <span class="number">-1</span>, string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dayjs 类中 add、subtract 等方法，都会通过 wrapper 返回一个新的 Dayjs 实例，是通过使用 Dayjs 类中的 clone() 方法实现的。所以，通过这个 clone() 方法，实现了 dayjs 的 immutable 特性。<br>当增加或减少的单位是年或月时，会先将日设置为1，然后再加减，最后再比较当前月的总天数和原来的天数（主要是解决像2月只有28天这类问题），取较小的值再返回；对于天／周／时／分／秒则是按照时间戳来计算，再通过 wrapper 返回一个新的 Date 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().add(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().add(<span class="number">5</span>, <span class="string">'day'</span>);</span><br><span class="line">dayjs().subtract(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().subtract(<span class="number">2</span>, <span class="string">'year'</span>);</span><br></pre></td></tr></table></figure></p><h5 id="开头和末尾"><a href="#开头和末尾" class="headerlink" title="开头和末尾"></a>开头和末尾</h5><p>返回当前时间的开头时间的 Dayjs 对象，如月份的第一天。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().startOf(<span class="string">'year'</span>).format(<span class="string">'YYYY-MM-DD'</span>);  <span class="comment">// 2018-01-01</span></span><br></pre></td></tr></table></figure></p><p>返回当前时间的末尾时间的 Dayjs 对象，如月份的最后一天。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().endOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().endOf(<span class="string">'month'</span>).format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// 2018-07-31</span></span><br></pre></td></tr></table></figure><h2 id="六-时间差"><a href="#六-时间差" class="headerlink" title="六 时间差"></a>六 时间差</h2><p>时间差是两个 dayjs 对象的之差所得的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().diff(Dayjs, unit);</span><br><span class="line">dayjs().diff(dayjs(<span class="string">'2000-2-1'</span>), <span class="string">'years'</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></p><p>源码逻辑是先计算出两个时间相差的毫秒数和月数，再根据传入的单位去选择计算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">diff(input, units, float) &#123;</span><br><span class="line">    <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">    <span class="keyword">const</span> that = dayjs(input)</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="keyword">this</span> - that</span><br><span class="line">    <span class="keyword">let</span> result = Utils.monthDiff(<span class="keyword">this</span>, that)</span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">      <span class="keyword">case</span> C.Y:</span><br><span class="line">        result /= <span class="number">12</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.M:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.Q:</span><br><span class="line">        result /= <span class="number">3</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.W:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_WEEK</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.D:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_DAY</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.H:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_HOUR</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.MIN:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_MINUTE</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.S:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_SECOND</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">// milliseconds</span></span><br><span class="line">        result = diff</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> float ? result : Utils.absFloor(result)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="七-其他方法"><a href="#七-其他方法" class="headerlink" title="七 其他方法"></a>七 其他方法</h2><h5 id="获取-unix-毫秒时间戳："><a href="#获取-unix-毫秒时间戳：" class="headerlink" title="获取 unix 毫秒时间戳："></a>获取 unix 毫秒时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().valueOf(); <span class="comment">// 1531633650522</span></span><br></pre></td></tr></table></figure><h5 id="获取-unix-秒级时间戳："><a href="#获取-unix-秒级时间戳：" class="headerlink" title="获取 unix 秒级时间戳："></a>获取 unix 秒级时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().unix(); <span class="comment">// 1531633677</span></span><br></pre></td></tr></table></figure><h5 id="返回月份的天数："><a href="#返回月份的天数：" class="headerlink" title="返回月份的天数："></a>返回月份的天数：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().daysInMonth(); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h5 id="获取-Date-对象："><a href="#获取-Date-对象：" class="headerlink" title="获取 Date 对象："></a>获取 Date 对象：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toDate(); <span class="comment">// Sun Jul 15 2018 13:48:41 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure><h5 id="获取数组格式："><a href="#获取数组格式：" class="headerlink" title="获取数组格式："></a>获取数组格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toArray(); <span class="comment">//[2018, 6, 13, 20, 34, 13, 424];</span></span><br></pre></td></tr></table></figure><h5 id="获取对象格式："><a href="#获取对象格式：" class="headerlink" title="获取对象格式："></a>获取对象格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toObject();<span class="comment">// &#123;years: 2018, months: 6, date: 13, hours: 20, minutes: 34...&#125;</span></span><br></pre></td></tr></table></figure><h2 id="八-dayjs-插件用法"><a href="#八-dayjs-插件用法" class="headerlink" title="八 dayjs 插件用法"></a>八 dayjs 插件用法</h2><p>dayjs 的插件，通过挂载到 dayjs 函数下的 extend 函数加载，然后使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> plugin <span class="comment">// 导入插件</span></span><br><span class="line">dayjs.extend(plugin, options) <span class="comment">// 加载插件的同时，加入插件所需要的参数</span></span><br></pre></td></tr></table></figure></p><p>使用官方的 IsLeapYear 插件(判断是否是闰年):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isLeapYear <span class="keyword">from</span> <span class="string">'dayjs/plugin/isLeapYear'</span></span><br><span class="line">dayjs.extend(isLeapYear)</span><br><span class="line">dayjs(<span class="string">'2000-01-01'</span>).isLeapYear() <span class="comment">// true</span></span><br><span class="line">dayjs(<span class="string">'2018-01-01'</span>).isLeapYear() <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>dayjs.extend() 方法，接受两个参数，即插件（函数）和插件的选项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展插件的方法</span></span><br><span class="line"><span class="comment">// plugin：插件函数</span></span><br><span class="line"><span class="comment">// option：插件的选项</span></span><br><span class="line">dayjs.extend = <span class="function">(<span class="params">plugin, option</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 插件函数接受三个参数</span></span><br><span class="line">  <span class="comment">// 1.插件选项 2.Dayjs 类 3.dayjs 函数</span></span><br><span class="line">  <span class="comment">// 插件的方法都是挂载在 Dayjs 类的原型对象上的（Dayjs.prototype）。</span></span><br><span class="line">  plugin(option, Dayjs, dayjs)</span><br><span class="line">  <span class="keyword">return</span> dayjs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IsLeapYear 的源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (o, c) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> proto = c.prototype</span><br><span class="line">  proto.isLeapYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">this</span>.$y % <span class="number">4</span> === <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.$y % <span class="number">100</span> !== <span class="number">0</span>)) || (<span class="keyword">this</span>.$y % <span class="number">400</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 isLeapYear 函数挂载到 Dayjs 类的原型上，所以每个 Dayjs 实例都可以使用 isLeapYear 方法。</p><hr><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p> 特别感谢 DaisyXL 和 Young 的支持和分析！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="dayjs" scheme="http://xgfe.github.io/tags/dayjs/"/>
    
      <category term="momentjs" scheme="http://xgfe.github.io/tags/momentjs/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://xgfe.github.io/2018/06/24/matengfei/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://xgfe.github.io/2018/06/24/matengfei/webpack入门/</id>
    <published>2018-06-24T12:31:49.000Z</published>
    <updated>2018-12-06T11:56:44.285Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。</p><a id="more"></a><h1 id="1、webpack-简介"><a href="#1、webpack-简介" class="headerlink" title="1、webpack 简介"></a>1、webpack 简介</h1><p>前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p><h2 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h2><ul><li>1、支持 CommonJs 和 AMD 模块，意思也就是我们基本可以无痛迁移旧项目。</li><li>2、支持模块加载器和插件机制，可对模块灵活定制。babel-loader 更是有效支持 ES6 。 </li><li>3、可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。 </li><li>4、将样式文件和图片等静态资源也可视为模块进行打包。配合 loader 加载器，可以支持 sass ，less 等 CSS 预处理器。 </li><li>5、内置有 source map ，即使打包在一起依旧方便调试。</li></ul><h2 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h2><p>Webpack 具有四个核心的概念，想要入门 Webpack 就得先好好了解这四个核心概念。它们分别是Entry（入口）、Output（输出）、loader 和 Plugins（插件）。接下来详细介绍这四个核心概念。</p><h3 id="1-Entry"><a href="#1-Entry" class="headerlink" title="1. Entry"></a>1. Entry</h3><p>Entry 是 Webpack 的入口起点指示，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。可以在配置文件（webpack.config.js）中配置 entry 属性来指定一个或多个入口点，默认为 ./src（ webpack 4开始引入默认值）。<br>具体配置方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: string | <span class="built_in">Array</span>&lt;string&gt;</span><br></pre></td></tr></table></figure><p>前者一个单独的 string 是配置单独的入口文件，配置为后者（一个数组）时，是多文件入口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./app.js'</span>,</span><br><span class="line">        vendors: <span class="string">'./vendors.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上配置表示从 app 和 vendors 属性开始打包构建依赖树，这样做的好处在于分离自己开发的业务逻辑代码和第三方库的源码，因为第三方库安装后，源码基本就不再变化，这样分开打包有利于提升打包速度，减少了打包文件的个数。</p><h3 id="2-Output"><a href="#2-Output" class="headerlink" title="2. Output"></a>2. Output</h3><p>Output 属性告诉 webpack 在哪里输出它所创建的 bundles ，也可指定 bundles 的名称，默认位置为 ./dist。整个应用结构都会被编译到指定的输出文件夹中去，最基本的属性包括 filename（文件名）和 path（输出路径）。</p><p>值得注意的是，即是你配置了多个入口文件，你也只能有一个输出点。</p><p>具体配置方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/dist'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，output.filename 必须是绝对路径，如果是一个相对路径，打包时 webpack 会抛出异常。</p><p>多个入口时，使用下面的语法输出多个 bundle ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Loaders"><a href="#3-Loaders" class="headerlink" title="3. Loaders"></a>3. Loaders</h3><p>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件，比如 png、csv、xml、css、json 等各种类型的文件，使用合适的 loader 可以让 JavaScript 的 import 导入非 JavaScript 模块。JavaScript 只认为 JavaScript 文件是模块，而 webpack 的设计思想即万物皆模块，为了使得 webpack 能够认识其他“模块”，所以需要 loader 这个“编译器”。</p><p>webpack 中配置 loader 有两个目标：</p><p>（1）test 属性：标志有哪些后缀的文件应该被处理，是一个正则表达式。</p><p>（2）use 属性：指定 test 类型的文件应该使用哪个 loader 进行预处理。</p><p>比如 webpack.config.js :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'...'</span>,</span><br><span class="line">    output: <span class="string">'...'</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: <span class="string">'css-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该配置文件指示了所有的 css 文件在 import 时都应该经过 css-loader 处理，经过 css-loader 处理后，可以在 JavaScript 模块中直接使用 import 语句导入 css 模块。但是使用 css-loader 的前提是先使用 npm 安装 css-loader。</p><p>此处需要注意的是定义 loaders 规则时，不是定义在对象的 rules 属性上，而是定义在 module 属性的 rules 属性中。</p><p>配置多个 loader ：</p><p>有时候，导入一个模块可能要先使用多个 loader 进行预处理，这时就要对指定类型的文件配置多个 loader 进行预处理，配置多个 loader ，把 use 属性赋值为数组即可，webpack 会按照数组中 loader 的先后顺序，使用对应的 loader 依次对模块文件进行预处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'style-loader'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Plugins"><a href="#4-Plugins" class="headerlink" title="4. Plugins"></a>4. Plugins</h3><p>loader 用于转换非 JavaScript 类型的文件，而插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，功能十分强大。要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</p><p>插件是 webpack 的支柱功能，目前主要是解决 loader 无法实现的其他许多复杂功能，通过 plugins 属性使用插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Mode"><a href="#5-Mode" class="headerlink" title="5. Mode"></a>5. Mode</h3><p>模式（ Mode ）可以通过配置对象的 mode 属性进行配置，主要值为 production 或者 development。两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack 会自动对代码进行压缩等优化，省去了配置的麻烦。</p><p>学习完以上基本概念之后，基本也就入门 webpack 了，因为 webpack 的强大就是建立在这些基本概念之上，利用 webpack 多样的 loaders 和 plugins，可以实现强大的打包功能。</p><h1 id="2、js-模块化"><a href="#2、js-模块化" class="headerlink" title="2、js 模块化"></a>2、js 模块化</h1><h2 id="2-1-命名空间"><a href="#2-1-命名空间" class="headerlink" title="2.1 命名空间"></a>2.1 命名空间</h2><p>命名空间是通过为项目或库创建一个全局对象，然后将所有功能添加到该全局变量中。通过减少程序中全局变量的数量，实现单全局变量，从而在具有大量函数、对象和其他变量的情况下不会造成全局污染，同时也避免了命名冲突等问题。</p><p>然而，在不同的文件中给一个命名空间添加属性的时候，首先要保证这个命名空间是已经存在的，同时不对已有的命名空间造成任何破坏。可以通过非破坏性的命名空间函数实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> KUI = KUI || &#123;&#125;;</span><br><span class="line">KUI.utils = KUI.utils || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">KUI.utils.namespace = <span class="function"><span class="keyword">function</span>(<span class="params">ns</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = ns.split(<span class="string">"."</span>),</span><br><span class="line">        object = KUI,</span><br><span class="line">        i, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parts[<span class="number">0</span>] === <span class="string">"KUI"</span>)&#123;</span><br><span class="line">        parts = parts.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, len = parts.length; i &lt; len; i+=<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!object[parts[i]])&#123;</span><br><span class="line">            object[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        object = object[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KUI.utils.namespace(<span class="string">"KUI.common"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"KUI.common.testing"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"KUI.modules.function.plugins"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"format"</span>);</span><br></pre></td></tr></table></figure><p>看一下经过上述后 KUI 都有什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"utils"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"common"</span>: &#123;</span><br><span class="line">        <span class="string">"testing"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"modules"</span>: &#123;</span><br><span class="line">        <span class="string">"function"</span>: &#123;</span><br><span class="line">            <span class="string">"plugins"</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"format"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间模式的缺点</p><p>1.需要输入更长的字符，并且需要更长的解析时间；<br>2.对单全局变量的依赖性，即任何代码都可以修改该全局实例，其他代码将获得修改后的实例。</p><h2 id="2-2-CommonJs"><a href="#2-2-CommonJs" class="headerlink" title="2.2 CommonJs"></a>2.2 CommonJs</h2><p>CommonJS 是 nodejs 也就是服务器端广泛使用的模块化机制。<br>该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p><p>根据这个规范，每个文件就是一个模块，有自己的作用域，文件中的变量、函数、类等都是对其他文件不可见的。</p><p>如果想在多个文件分享变量，必须定义为 global 对象的属性。</p><h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>在每个模块内部，module 变量代表当前模块。它的 exports 属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取 module.exports 变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>require 方法用于加载模块，后缀名默认为.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'./app.js'</span>);</span><br></pre></td></tr></table></figure><p>模块加载的顺序，按照其在代码中出现的顺序</p><p>根据参数的不同格式，require 命令去不同路径寻找模块文件。</p><ul><li>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。</li><li>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件</li><li>如果参数字符串不以“./” 或 “/”开头，则表示加载的是一个默认提供的核心模块（ node 核心模块，或者通过全局安装或局部安装在 node_modules 目录中的模块）</li></ul><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>一般都会有一个主文件（入口文件），在 index.html 中加载这个入口文件，然后在这个入口文件中加载其他文件。</p><p>可以通过在 package.json 中配置 main 字段来指定入口文件。</p><h3 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h3><p>第一次加载某个模块时，Node 会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的 module.exports 属性。</p><h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p><p>由于 CommonJS 是同步加载模块，这对于服务器端不是一个问题，因为所有的模块都放在本地硬盘。等待模块时间就是硬盘读取文件时间很小。但是，对于浏览器而言，它需要从服务器加载模块，涉及到网速，代理等原因，一旦等待时间过长，浏览器处于”假死”状态。</p><h2 id="2-3-AMD"><a href="#2-3-AMD" class="headerlink" title="2.3 AMD"></a>2.3 AMD</h2><p>AMD 是 “Asynchronous Module Definition” 的缩写，即 “异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。 </p><p>这里异步指的是不堵塞浏览器其他任务（ dom 构建，css 渲染等），而加载内部是同步的（加载完模块后立即执行回调）。</p><blockquote><p>requirejs 即为遵循AMD规范的模块化工具。 </p></blockquote><p>RequireJS 的基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。</p><p>RequireJS 主要解决两个问题：</p><ul><li>多个 js 文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li><li>js 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。</li></ul><h3 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h3><p>RequireJS 定义了一个函数 define，它是全局变量，用来定义模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p></li><li><p>依赖 dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。<br>依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于 3 ，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。</p></li><li><p>工厂方法 factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"alpha"</span>, [<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"beta"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, beta</span>) </span>&#123;</span><br><span class="line">      exports.verb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> beta.verb();</span><br><span class="line">          <span class="comment">//Or:</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">"beta"</span>).verb();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="加载模块-1"><a href="#加载模块-1" class="headerlink" title="加载模块"></a>加载模块</h3><p>AMD 也采用 require 命令加载模块，但是不同于 CommonJS ，它要求两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一个参数是一个数组，里面的成员是要加载的模块，第二个参数是加载完成后的回调函数。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>require 方法本身也是一个对象，它带有一个 config 方法，用来配置 require.js 运行参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"backbone"</span>: <span class="string">"vendor/backbone"</span>,</span><br><span class="line">        <span class="string">"underscore"</span>: <span class="string">"vendor/underscore"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        <span class="string">"backbone"</span>: &#123;</span><br><span class="line">            deps: [ <span class="string">"underscore"</span> ],</span><br><span class="line">            exports: <span class="string">"Backbone"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"underscore"</span>: &#123;</span><br><span class="line">            exports: <span class="string">"_"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>paths：paths 参数指定各个模块的位置。这个位置可以是同一个服务器上的相对位置，也可以是外部网址。可以为每个模块定义多个位置，如果第一个位置加载失败，则加载第二个位置。上面就是指定了 jquery 的位置，那么就可以直接在文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require（[&apos;jquery&apos;],function($)&#123;&#125;）</span><br></pre></td></tr></table></figure><p>shim：有些库不是 AMD 兼容的，这时就需要指定 shim 属性的值。shim 可以理解成“垫片”，用来帮助require.js 加载非 AMD 规范的库。</p><h2 id="2-4-CMD"><a href="#2-4-CMD" class="headerlink" title="2.4 CMD"></a>2.4 CMD</h2><p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个requireJS，CMD 有个浏览器的实现 SeaJS ，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块代码</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require 是可以把其他模块导入进来的一个参数; 而 exports 是可以把模块内的一些属性和方法导出的; module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p><ul><li>AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块;</li><li>CMD 是按需加载依赖就近,只有在用到某个模块的时候再去 require ;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-5-ES6-Module"><a href="#2-5-ES6-Module" class="headerlink" title="2.5 ES6 Module"></a>2.5 ES6 Module</h2><p>ES6 正式提出了内置的模块化语法，我们在浏览器端无需额外引入 requirejs 来进行模块化。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过 import 命令输入。</p><p>ES6 中的模块有以下特点：</p><ul><li>模块自动运行在严格模式下</li><li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在</li><li>模块顶级作用域的 this 值为 undefined</li><li>对于需要让模块外部代码访问的内容，模块必须导出它们</li></ul><h3 id="定义模块-2"><a href="#定义模块-2" class="headerlink" title="定义模块"></a>定义模块</h3><p>使用 export 关键字将任意变量、函数或者类公开给其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"cz"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象，即导出引用</span></span><br><span class="line"><span class="keyword">export</span> &#123;multiply&#125;</span><br></pre></td></tr></table></figure><h3 id="重命名模块"><a href="#重命名模块" class="headerlink" title="重命名模块"></a>重命名模块</h3><p>重命名想导出的变量、函数或类的名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125;</span><br></pre></td></tr></table></figure><p>这里将本地的 sum 函数重命名为 add 导出，因此在使用此模块的时候必须使用 add 这个名称。</p><h3 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h3><p>模块的默认值是使用 default 关键字所指定的单个变量、函数或类，而你在每个模块中只能设置一个默认导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用 export 导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。</p><p>也可以使用重命名语法来导出默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="加载模块-2"><a href="#加载模块-2" class="headerlink" title="加载模块"></a>加载模块</h3><p>在模块中使用 import 关键字来导入其他模块。<br>import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1,identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure><ul><li>大括号中指定了从给定模块导入的标识符</li><li>from 指明了需要导入的模块。模块由一个表示模块路径的字符串来指定。</li></ul><p>当从模块导入了一个绑定时，你不能在当前文件中再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 import 语句之前使用此标识符，更不能修改它的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入单个绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入多个绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum,multiply&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全导入一个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line">example.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">example.multiply(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入默认值</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>然而要记住，无论你对同一个模块使用了多少次 import 语句，该模块都只会被执行一次。</p><p>在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; multiply &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; magicNumber &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>尽管此处的模块使用了三个 import 语句，但 example.js 只会被执行一次。若同一个应用中的其他模块打算从 example.js 导入绑定，则那些模块都会使用这段代码中所用的同一个模块实例。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export 与 import。</p><h1 id="3、webpack-使用"><a href="#3、webpack-使用" class="headerlink" title="3、webpack 使用"></a>3、webpack 使用</h1><h2 id="3-1-打包-js"><a href="#3-1-打包-js" class="headerlink" title="3.1 打包 js"></a>3.1 打包 js</h2><p>webpack 对各种模块化的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// es module</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./sum'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs</span></span><br><span class="line"><span class="keyword">var</span> minus = <span class="built_in">require</span>(<span class="string">'./minux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//amd</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'muti'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(muti(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(minus(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minus.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// muti.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="压缩-JS-代码："><a href="#压缩-JS-代码：" class="headerlink" title="压缩 JS 代码："></a>压缩 JS 代码：</h3><p>现在你写的 JS 代码，在上线之前，都是需要进行压缩的，在没有 webpack 和 gulp 这些工具前，你可能需要找一个压缩软件或者在线进行压缩，在 Webpack 中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个 uglifyjs-webpack-plugin ( JS 压缩插件，简称 uglify )。</p><p>注意：虽然 uglifyjs 是插件，但是 webpack 版本里默认已经集成，不需要再次安装。</p><p>引入：</p><p>我们需要在 webpack.config.js 中引入 uglifyjs-webpack-glugin 插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>引入后在 plugins 配置里new一个 uglify 对象就可以了，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        <span class="keyword">new</span> uglify()</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><p>这时候在终端中使用 webpack 进行打包，你会发现 JS 代码已经被压缩了。</p><h2 id="3-2-编译-ES6"><a href="#3-2-编译-ES6" class="headerlink" title="3.2 编译 ES6"></a>3.2 编译 ES6</h2><p>在前端开发中都开始使用 ES6 的语法了，虽然说 webpack3 增加了一些 ES6 的转换支持，但是实际效果不是很好。所以我在开发中还是喜欢添加 Babel-loader 的，我也查看了一些别人的 webpack 配置也都增加了 babel-loader，所以这节课我们学习一下如何增加 Babel 支持。</p><p>Babel 是什么？<br>Babel 其实是一个编译 JavaScript 的平台，它的强大之处表现在可以通过便宜帮你达到以下目的：</p><ul><li>使用下一代的 javaScript 代码( ES6, ES7….)，即使这些标准目前并未被当前的浏览器完全支持。</li><li>使用基于 JavaScript 进行了扩展的语言，比如 React 的 JSX 。</li></ul><h3 id="Babel-的安装与配置"><a href="#Babel-的安装与配置" class="headerlink" title="Babel 的安装与配置"></a>Babel 的安装与配置</h3><p>Babel 其实是几个模块化的包，其核心功能位于称为 babel-core 的 npm 包中，webpack 可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析 ES6 的 babel-preset-es2015 包和解析 JSX 的 babel-preset-react 包）。</p><p>安装依赖包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure><p>在 webpack 中配置 Babel 的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                <span class="string">"es2015"</span>,<span class="string">"react"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babelrc配置"><a href="#babelrc配置" class="headerlink" title=".babelrc配置"></a>.babelrc配置</h3><p>虽然 Babel 可以直接在 webpack.config.js 中进行配置，但是考虑到 babel 具有非常多的配置选项，如果卸载 webapck.config.js 中会非常的雍长不可阅读，所以我们经常把配置卸载 .babelrc 文件里。</p><p>在项目根目录新建 .babelrc 文件，并把配置写到文件里。</p><p>. babelrc</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.webpack.config.js 里的 loader 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ENV："><a href="#ENV：" class="headerlink" title="ENV："></a>ENV：</h3><p>babel-preset-env 代替 babel-preset-ES2015 , babel 官方推出了 babel-preset-env ，并建议在使用的时候选择 env 代替之前的 ES20** 。env 为我们提供了更智能的编译选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure><p>然后修改 .babelrc 里的配置文件。其实只要把之前的 es2015 换成 env 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-打包公共代码"><a href="#3-3-打包公共代码" class="headerlink" title="3.3 打包公共代码"></a>3.3 打包公共代码</h2><p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件 (又称作 chunk ) 的功能，这个文件包括多个入口 chunk 的公共模块。</p><p>通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p><h3 id="公共chunk-用于-入口chunk-entry-chunk"><a href="#公共chunk-用于-入口chunk-entry-chunk" class="headerlink" title="公共chunk 用于 入口chunk (entry chunk)"></a>公共chunk 用于 入口chunk (entry chunk)</h3><p>生成一个额外的 chunk 包含入口 chunk 的公共模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">"commons"</span>,</span><br><span class="line">  <span class="comment">// ( 公共chunk(commnons chunk) 的名称)</span></span><br><span class="line"></span><br><span class="line">  filename: <span class="string">"commons.js"</span>,</span><br><span class="line">  <span class="comment">// ( 公共chunk 的文件名)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// minChunks: 3,</span></span><br><span class="line">  <span class="comment">// (模块必须被3个 入口 chunk 共享)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// chunks: ["pageA", "pageB"],</span></span><br><span class="line">  <span class="comment">// (只使用这些 入口chunk)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你必须在 入口 chunk 之前加载生成的这个公共 chunk:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"commons.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"entry.bundle.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="明确第三方库-chunk"><a href="#明确第三方库-chunk" class="headerlink" title="明确第三方库 chunk"></a>明确第三方库 chunk</h3><p>将你的代码拆分成公共代码和应用代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  vendor: [<span class="string">"jquery"</span>, <span class="string">"other-lib"</span>],</span><br><span class="line">  app: <span class="string">"./entry"</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">"vendor"</span>,</span><br><span class="line">    <span class="comment">// filename: "vendor.js"</span></span><br><span class="line">    <span class="comment">// (给 chunk 一个不同的名字)</span></span><br><span class="line"></span><br><span class="line">    minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="comment">// (随着 entry chunk 越来越多，</span></span><br><span class="line">    <span class="comment">// 这个配置保证没其它的模块会打包进 vendor chunk)</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="将公共模块打包进父-chunk"><a href="#将公共模块打包进父-chunk" class="headerlink" title="将公共模块打包进父 chunk"></a>将公共模块打包进父 chunk</h3><p>使用代码拆分功能，一个 chunk 的多个子 chunk 会有公共的依赖。为了防止重复，可以将这些公共模块移入父 chunk。这会减少总体的大小，但会对首次加载时间产生不良影响。如果预期到用户需要下载许多兄弟 chunks（例如，入口 trunk 的子 chunk），那这对改善加载时间将非常有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  <span class="comment">// names: ["app", "subPageA"]</span></span><br><span class="line">  <span class="comment">// (选择 chunks，或者忽略该项设置以选择全部 chunks)</span></span><br><span class="line"></span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// minChunks: 3,</span></span><br><span class="line">  <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="额外的异步公共-chunk"><a href="#额外的异步公共-chunk" class="headerlink" title="额外的异步公共 chunk"></a>额外的异步公共 chunk</h3><p>与上面的类似，但是并非将公共模块移动到父 chunk（增加初始加载时间），而是使用新的异步加载的额外公共 chunk 。当下载额外的 chunk 时，它将自动并行下载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">"app"</span>,</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  names: [<span class="string">"app"</span>, <span class="string">"subPageA"</span>]</span><br><span class="line">  <span class="comment">// the name or list of names must match the name or names</span></span><br><span class="line">  <span class="comment">// of the entry points that create the async chunks</span></span><br><span class="line"></span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (创建一个异步 公共chunk)</span></span><br><span class="line"></span><br><span class="line">  minChunks: <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-4-代码分割和懒加载"><a href="#3-4-代码分割和懒加载" class="headerlink" title="3.4 代码分割和懒加载"></a>3.4 代码分割和懒加载</h2><p>webpack 可以帮助我们将代码分成不同的逻辑块，在需要的时候加载这些代码。</p><h3 id="使用-require-ensure-来拆分代码"><a href="#使用-require-ensure-来拆分代码" class="headerlink" title="使用 require.ensure() 来拆分代码"></a>使用 require.ensure() 来拆分代码</h3><p>require.ensure() 是一种使用 CommonJS 的形式来异步加载模块的策略。在代码中通过 require.ensure([<fileurl>]) 引用模块，其使用方法如下：</fileurl></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require</span>), <span class="title">chunkName</span>: <span class="title">String</span>);</span></span><br></pre></td></tr></table></figure><p>第一个参数指定依赖的模块，第二个参数是一个函数，在这个函数里面你可以使用 require 来加载其他的模块，webpack 会收集 ensure 中的依赖，将其打包在一个单独的文件中，在后续用到的时候使用 jsonp 异步地加载进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行代码分割</span></span><br><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'lodash'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);<span class="comment">//上边的require.ensure只会引入进来，但是并不会执行，再次require才会执行。</span></span><br><span class="line">&#125;,<span class="string">'vendor'</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(page==<span class="string">'subPageA'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">    &#125;,<span class="string">'subPageA'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page==<span class="string">'subPageB'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,subPageB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>,<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">        <span class="keyword">var</span> subPageB=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,common)</span><br><span class="line">    <span class="comment">//common表示这个模块的名字</span></span><br></pre></td></tr></table></figure><p>但是仅仅这样配置并不能把公共 js 抽离出来，在多页面应用中可以通过 new webpack.optimize.CommonsChunkPlugin 这个 plugin 来实现，但是对于单页面来说，就需要借助 require.include 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.include(<span class="string">'./moduleA'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(page==<span class="string">'subPageA'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">    &#125;,<span class="string">'subPageA'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page==<span class="string">'subPageB'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,subPageB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会把公共模块 moduleA 给抽离出来。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import 与 require.ensure 最大的区别就是，他在引入的时候会直接执行，而不需要在此 require 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./subPageA'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是这样打包出来的是没有 chunkname 的，怎么添加 chunkname 呢？需要 webpack3+ 的魔法注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/*webpackChunkName:'subPageA'*/</span><span class="string">'./subPageA'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-5-处理css"><a href="#3-5-处理css" class="headerlink" title="3.5 处理css"></a>3.5 处理css</h2><h3 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h3><p>首先，在 src 目录下建立 css 文件夹，和 index.css 文件，并编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: burlywood;</span><br><span class="line">    color:white;</span><br><span class="line">    font-size:<span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立好后，需要引入到入口文件中，才可以打包。在 entery.js 的首行加入代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">'./css/index.css'</span>;</span><br></pre></td></tr></table></figure><p>CSS 和引入做好后，我们就需要使用 loader 来解析 CSS 文件了，这里我们需要两个解析用的 loader，分别是 style-loader 和 css-loader。</p><h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><p>它是用来处理 css 文件中的 url() 等。<br>用 npm install 进行项目安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure><h3 id="CSS-loader"><a href="#CSS-loader" class="headerlink" title="CSS-loader"></a>CSS-loader</h3><p>它是用来将 css 插入到页面的 style 标签。<br>用 npm install 进行项目安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure><h3 id="loaders配置："><a href="#loaders配置：" class="headerlink" title="loaders配置："></a>loaders配置：</h3><p>修改 webpack.config.js 中 module 属性中的配置代码如下：</p><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="提取-CSS"><a href="#提取-CSS" class="headerlink" title="提取 CSS"></a>提取 CSS</h3><p>目前，打包后的文件中，css 是打包在 js 代码里面的，这样不便于以后的维护，所以需要把 CSS 从 js 中分离出来，我们需要使用插件 Extract Text Plugin。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>在 Plugins中配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>);</span><br><span class="line"><span class="comment">//css/index.css是分离后的路径位置</span></span><br></pre></td></tr></table></figure><p>修改 Loader 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:<span class="string">"css-loader"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Less"><a href="#配置Less" class="headerlink" title="配置Less"></a>配置Less</h3><p>Less 作为目前很火的 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin 、函数等特性，使 CSS 更易维护和扩展；</p><p>安装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less less-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:<span class="string">"css-loader"</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    loader:<span class="string">"less-loader"</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置sass"><a href="#配置sass" class="headerlink" title="配置sass"></a>配置sass</h3><p>Sass 的打包和分离和 less 的类似，首先下载安装 Sass 所支持的服务与 loader。<br>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev node-sass sass-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:<span class="string">"css-loader"</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    loader:<span class="string">"sass-loader"</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostCSS-in-webpack"><a href="#PostCSS-in-webpack" class="headerlink" title="PostCSS-in-webpack"></a>PostCSS-in-webpack</h3><p>CSS3 是目前作为一个前端必须要掌握的技能，但是由于现在好多浏览器还是不兼容 CSS3，所以前端需要多写很丑很难看的前缀代码；以前都是边查 Can I Use ，边添加，这样很麻烦，现在配置一个插件 postcss就可以搞定；</p><p>PostCSS 是一个 CSS 的处理平台，它可以帮助你的 CSS 实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下 PostCSS 。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure><p>在根目录下，建立一个 postcss.config.js 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是对 postCSS 一个简单的配置，引入了 autoprefixer 插件。让 postCSS 拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。</p><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, </span><br><span class="line">                options: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-Tree-shaking"><a href="#3-6-Tree-shaking" class="headerlink" title="3.6 Tree-shaking"></a>3.6 Tree-shaking</h2><p>Tree-shaking 字面意思就是摇晃树， 其实就是去除那些引用的但却没有使用的代码。<br>Tree-shaking 概念最早由 Rollup.js 提出，后来在 webpack2 中被引入进来，但是这个这一特性能够被支持得益于 ES6 modules 的静态特性。ES6的模块声明相比于传统 CommonJS 的同步 require 有着本质区别。这种 modules 设计保证了依赖关系是提前确定的，使得静态分析成为了可能，与运行时无关。<br>并且 webpack 中并没有直接对 tree-shaking 的配置，需要借助 uglifyjs-webpack-plugin。</p><p>webpack 中 tree-shaking主要分为两个方面:</p><ul><li>JS tree shaking： JS 文件中定义的多个方法或者变量没有全部使用。</li><li>CSS tree shaking： 样式通过 css 选择器没有匹配到相应的 DOM 节点。</li></ul><h3 id="JS-Tree-shaking"><a href="#JS-Tree-shaking" class="headerlink" title="JS Tree-shaking"></a>JS Tree-shaking</h3><p>将文件标记为无副作用( side-effect-free )<br>在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。</p><p>这种方式是通过 package.json 的 “sideEffects” 属性来实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同上面提到的，如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。</p><blockquote><p>「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export 。举例说明，例如 polyfill ，它影响全局作用域，并且通常不提供 export 。</p></blockquote><p>如果你的代码确实有一些副作用，那么可以改为提供一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"./src/some-side-effectful-file.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩输出<br>通过如上方式，我们已经可以通过 import 和 export 语法，找出那些需要删除的“未使用代码(dead code)”，然而，我们不只是要找出，还需要在 bundle 中删除它们。为此，我们将使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。</p><blockquote><p>注意，–optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。<br>从 webpack 4 开始，也可以通过 “mode” 配置选项轻松切换到压缩输出，只需设置为 “production”。</p></blockquote><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">"production"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了学会使用 tree shaking，你必须……</p><ul><li>使用 ES2015 模块语法（即 import 和 export）。</li><li>在项目 package.json 文件中，添加一个 “sideEffects” 入口。</li><li>引入一个能够删除未引用代码( dead code )的压缩工具( minifier )（例如 UglifyJSPlugin ）。</li></ul><h3 id="CSS-Tree-shaking"><a href="#CSS-Tree-shaking" class="headerlink" title="CSS Tree-shaking"></a>CSS Tree-shaking</h3><p>像 Bootstrap 这样的框架往往会带有很多 CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS 也会越来越多，有时候需求更改，带来了 DOM 结构的更改，这时候我们可能无暇关注 CSS 样式，造成很多 CSS 的冗余。</p><p>PurifyCSS<br>使用 PurifyCSS 可以大大减少 CSS 冗余，比如我们经常使用的 BootStrap (140KB)就可以减少到只有 35KB 大小。这在实际开发当中是非常有用的。</p><p>安装 PurifyCSS-webpack<br>从名字你就可以看出这是一个插件，而不是 loader。所以这个需要安装还需要引入。 PurifyCSS-webpack 要以来于 purify-css 这个包，所以这两个都需要安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i –save-dev purifycss-webpack purify-css</span><br></pre></td></tr></table></figure><p>引入 glob<br>因为我们需要同步检查html模板，所以我们需要引入 node 的 glob 对象使用。在 webpack.config.js 文件头部引入 glob。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br></pre></td></tr></table></figure><p>引入 purifycss-webpack<br>同样在 webpack.config.js 文件头部引入 purifycss-webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCSSPlugin = <span class="built_in">require</span>(<span class="string">"purifycss-webpack"</span>);</span><br></pre></td></tr></table></figure><p>配置 plugins<br>引入完成后我们需要在 webpack.config.js 里配置 plugins 。代码如下，重点看标黄部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="comment">//new uglify() </span></span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify:&#123;</span><br><span class="line">            removeAttrubuteQuotes:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash:<span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">'./src/index.html'</span></span><br><span class="line">        </span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">"css/index.css"</span>),</span><br><span class="line">    <span class="keyword">new</span> PurifyCSSPlugin(&#123;</span><br><span class="line">        <span class="comment">// Give paths to parse for rules. These should be absolute!</span></span><br><span class="line">        paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里配置了一个 paths ，主要是需找 html 模板，purifycss 根据这个配置会遍历你的文件，查找哪些css 被使用了。</p><p>配置好上边的代码，我们可以故意在 css 文件里写一些用不到的属性，然后用 webpack 打包，你会发现没用的 CSS 已经自动给你删除掉了。在工作中记得一定要配置这个 plugins ，因为这决定你代码的质量，非常有用。</p><h2 id="3-7-文件处理"><a href="#3-7-文件处理" class="headerlink" title="3.7 文件处理"></a>3.7 文件处理</h2><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>在 index.html 文件中增加一个放置 div 的标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"tupian"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>编写 css 文件，把图片作为背景显示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#tupian&#123;</span><br><span class="line">   background-image: url(../images/manhua.png);</span><br><span class="line">   width:<span class="number">466</span>px;</span><br><span class="line">   height:<span class="number">453</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 file-loader 和 url-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure><p>file-loader ：解决引用路径的问题，拿 background 样式用 url 引入背景图来说，我们都知道， webpack 最终会将各个模块打包成一个文件，因此我们样式中的 url 路径是相对入口 html 页面的，而不是相对于原始 css 文件所在的路径的。这就会导致图片引入失败。这个问题是用 file-loader 解决的，file-loader 可以解析项目中的 url 引入（不仅限于 css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。<br>url-loader：如果图片较多，会发很多 http 请求，会降低页面性能。这个问题可以通过 url-loader 解决。url-loader 会将引入的图片编码，生成 dataURl 。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl ，大于 limit 的还会使用 file-loader 进行 copy。</p><p>配置 url-loader<br>我们安装好后，就可以使用这个 loader 了，记得在 loader 使用时不需要用 require 引入，在plugins 才需要使用 require 引入。</p><p>webpack.config.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块：例如解读 CSS,图片如何转换，压缩</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:<span class="number">500000</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li>test： /.(png|jpg|gif)/ 是匹配图片文件后缀名称。</li><li>use：是指定使用的 loader 和 loader 的配置参数。</li><li>limit：是把小于 500000B 的文件打成 Base64 的格式，写入JS 。</li><li>写好后就可以使用 webpack 进行打包了，这回你会发现打包很顺利的完成了。具体的 Base64 的格式，你可以查看视频中的样子。</li></ul><h4 id="为什么只使用了url-loader"><a href="#为什么只使用了url-loader" class="headerlink" title="为什么只使用了url-loader"></a>为什么只使用了url-loader</h4><p>有的小伙伴会发现我们并没有在 webpack.config.js 中使用 file-loader ，但是依然打包成功了。我们需要了解 file-loader 和 url-loader 的关系。url-loader 和 file-loader 是什么关系呢？简答地说，url-loader 封装了 file-loader 。 url-loader 不依赖于 file-loader ，即使用 url-loader 时，只需要安装 url-loader 即可，不需要安装 file-loader ，因为 url-loader内置了 file-loader 。通过上面的介绍，我们可以看到，url-loader 工作分两种情况：</p><ul><li><p>1.文件大小小于 limit 参数， url-loader 将会把文件转为 DataURL（ Base64格式 ）；</p></li><li><p>2.文件大小大于 limit ， url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。</p></li></ul><p>也就是说，其实我们只安装一个 url-loader 就可以了。但是为了以后的操作方便，我们这里就顺便安装上 file-loader。</p><h4 id="如何把图片放到指定的文件夹下"><a href="#如何把图片放到指定的文件夹下" class="headerlink" title="如何把图片放到指定的文件夹下"></a>如何把图片放到指定的文件夹下</h4><p>前边两节课程，打包后的图片并没有放到images文件夹下，要放到 images 文件夹下，其实只需要配置我们的 url-loader 选项就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">     rules: [</span><br><span class="line">         &#123;</span><br><span class="line">           test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">           use: extractTextPlugin.extract(&#123;</span><br><span class="line">             fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">             use: <span class="string">"css-loader"</span></span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,&#123;</span><br><span class="line">            test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    limit:<span class="number">5000</span>,</span><br><span class="line">                    outputPath:<span class="string">'images/'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">         &#125;</span><br><span class="line">       ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="CSS-分离时图片路径处理"><a href="#CSS-分离时图片路径处理" class="headerlink" title="CSS 分离时图片路径处理"></a>CSS 分离时图片路径处理</h3><p>在处理 css 时我们已经学会如何使用 extract-text-webpack-plugin 插件提取 css，利用 extract-text-webpack-plugin 插件很轻松的就把 CSS 文件分离了出来，但是 CSS 路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用 publicPath 解决，我也一直在用。</p><p>publicPath：是在 webpack.config.js 文件的 output 选项中，主要作用就是处理静态文件路径的。</p><p>在处理前，我们在 webpack.config.js 上方声明一个对象，叫 website。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> website =&#123;</span><br><span class="line">    publicPath:<span class="string">"http://192.168.1.108:1717/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 IP 和端口，是你本机的 ip 或者是你 devServer 配置的 IP 和端口。<br>然后在 output 选项中引用这个对象的 publicPath 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出口文件的配置项</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">//输出的路径，用了Node语法</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        <span class="comment">//输出的文件名称</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>,</span><br><span class="line">        publicPath:website.publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>配置完成后，你再使用 webpack 命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。</p><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><h4 id="将字体图标和-css-打包到同一个文件中"><a href="#将字体图标和-css-打包到同一个文件中" class="headerlink" title="将字体图标和 css 打包到同一个文件中"></a>将字体图标和 css 打包到同一个文件中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test:<span class="regexp">/\.(png|woff|woff2|svg|ttf|eot)$/</span>,</span><br><span class="line">   use:&#123;</span><br><span class="line">        loader:<span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: <span class="number">100000</span>,  <span class="comment">//这里要足够大这样所有的字体图标都会打包到css中</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中的 limit 一定要保证大于最大字体文件的大小，因为这个参数是告诉 url-loader，如果文件小于这个参数，那么就以 Data Url 的方式直接构建到文件中。使用这种方式最方便，不用打包后路径的问题，但是缺点就是构建出来的文件特别大，如果线上不要使用这种方式打包。 </p><h4 id="将字体图标独放打包到一个文件夹中"><a href="#将字体图标独放打包到一个文件夹中" class="headerlink" title="将字体图标独放打包到一个文件夹中"></a>将字体图标独放打包到一个文件夹中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: <span class="regexp">/\.(woff|woff2|svg|ttf|eot)$/</span>,</span><br><span class="line">   use:[</span><br><span class="line">        &#123;</span><br><span class="line">        loader:<span class="string">'file-loader'</span>,</span><br><span class="line">        options:&#123;<span class="attr">name</span>:<span class="string">'fonts/[name].[hash:8].[ext]'</span>&#125;&#125;</span><br><span class="line">        <span class="comment">//项目设置打包到dist下的fonts文件夹下</span></span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>打包中会遇到的问题就是路径不对，可以通过配置 publicPath 解决。</p><h3 id="Json-配置文件使用"><a href="#Json-配置文件使用" class="headerlink" title="Json 配置文件使用"></a>Json 配置文件使用</h3><p>在实际工作中，我们的项目都会配置一个 Json 的文件或者说 API 文件，作为项目的配置文件。有时候你也会从后台读取到一个 json 的文件，这节课就学习如何在 webpack 环境中使用 Json。如果你会 webpack1 或者 webpack2 版本中，你是需要加载一个 json-loader 的 loader 进来的，但是在webpack3.x 版本中，你不再需要另外引入了。</p><p>读出 Json 内容<br>第一步：现在我们的 index.html 模板中加入一个层，并给层一个 Id，为了是在 javascript 代码中可以方便引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"json"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>第二步：到 src 文件夹下，找到入口文件，我这里是 entry.js 文件。修改里边的代码，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json =<span class="built_in">require</span>(<span class="string">'../config.json'</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"json"</span>).innerHTML= json.name;</span><br></pre></td></tr></table></figure><p>这两行代码非常简单，第一行是引入我们的 json 文件，第二行驶写入到到 DOM 中。</p><h2 id="3-8-html-in-webpack"><a href="#3-8-html-in-webpack" class="headerlink" title="3.8 html in webpack"></a>3.8 html in webpack</h2><h3 id="生成html"><a href="#生成html" class="headerlink" title="生成html"></a>生成html</h3><p>html-webpack-plugin 可以根据你设置的模板，在每次运行后生成对应的模板文件，同时所依赖的 CSS/JS 也都会被引入，如果 CSS/JS 中含有 hash 值，则 html-webpack-plugin 生成的模板文件也会引入正确版本的 CSS/JS 文件。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>引入</p><p>在webpack.config.js中引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./app/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: <span class="string">"This is the result"</span>,</span><br><span class="line">            filename: <span class="string">"./index.html"</span>,</span><br><span class="line">            template: <span class="string">"./app/index.html"</span>,</span><br><span class="line">            inject: <span class="string">"body"</span>,</span><br><span class="line">            favicon: <span class="string">""</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                caseSensitive: <span class="literal">false</span>,</span><br><span class="line">                collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            hash: <span class="literal">true</span>,</span><br><span class="line">            cache: <span class="literal">true</span>,</span><br><span class="line">            chunks: <span class="string">""</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后看一下这些参数的意义：</p><ul><li>title: 生成的HTML模板的 title，如果模板中有设置 title 的名字，则会忽略这里的设置</li><li>filename: 生成的模板文件的名字</li><li>template: 模板来源文件</li><li>inject: 引入模块的注入位置；取值有 true/false/body/head</li><li>favicon: 指定页面图标；</li><li>minify: 是 html-webpack-plugin 中集成的 html-minifier ，生成模板文件压缩配置</li><li>caseSensitive: false, //是否大小写敏感</li><li>collapseBooleanAttributes: true, //是否简写 boolean 格式的属性如：disabled=”disabled” 简写为 disabled </li><li>collapseWhitespace: true //是否去除空格</li><li>hash: 是否生成hash添加在引入文件地址的末尾，类似于我们常用的时间戳</li><li>cache: 是否需要缓存，如果填写 true，则文件只有在改变时才会重新生成</li><li>chunks: 引入的模块，这里指定的是 entry 中设置多个 js 时，在这里指定引入的 js，如果不设置则默认全部引入</li></ul><h3 id="html中引入图片"><a href="#html中引入图片" class="headerlink" title="html中引入图片"></a>html中引入图片</h3><p>html-withimg-loader<br>html-withimg-loader 就是我们今天的重点了，这个插件并不是很火，也是我个人喜欢的一个小loader 。解决的问题就是在hmtl文件中引入 <img> 标签的问题。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure><p>配置 loader<br>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在终端中可以进行打包了。你会发现 images 被很好的打包了。并且路径也完全正确。</p><h1 id="webpack-环境配置"><a href="#webpack-环境配置" class="headerlink" title="webpack 环境配置"></a>webpack 环境配置</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>在使用 webpack-cli 进行打包时，通过命令 webpack –watch 即可开启 watch 模式，进入 watch 模式之后，一旦依赖树中的某一个模块发生了变化，webpack 就会重新进行编译。</p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>在 webpack 中打包生成的文件会覆盖之前的文件，不过生成文件的时候文件名加了 hash 之后会每次都生成不一样的文件，这就会很麻烦，不但会生成很多冗余的文件，还很难搞清楚到底是哪个文件，这就需要引入该插件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install –save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="comment">//引入clean-webpack-plugin</span></span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//plugin 插入你想删除的路径，注意在生成出来文件之前，他会删除 public 的文件夹，而不是根据生成的文件来删除对应的文件。</span></span><br><span class="line"><span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'public'</span>]);</span><br></pre></td></tr></table></figure><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack dev server"></a>webpack dev server</h3><p>webpack-dev-server 简介：</p><ul><li>是一个小型 node.js express 服务器</li><li>新建一个开发服务器，可以 serve 我们 pack 以后的代码，并且当代码更新的时候自动刷新浏览器</li><li>启动 webpack-dev-server 后，你在目标文件夹中是看不到编译后的文件的，实时编译后的文件都保存到了内存当中。<br>两种自动刷新方式：</li><li>iframe mode<br>在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个 iframe 当中去，因此每次你修改的文件后，都是这个 iframe 进行了 reload<br>命令行：webpack-dev-server，无需 –inline<br>浏览器访问：<a href="http://localhost:8080/webpack-dev-server/index.html" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server/index.html</a></li><li>inline mode<br>命令行：webpack-dev-server –inline<br>浏览器访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ul><p>安装 webpack-dev-server</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var webpack=require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">……</span><br><span class="line">devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    inline: true,//注意：不写hot: true，否则浏览器无法自动更新；也不要写  colors:true，progress:true等，webpack2.x已不支持这些</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">    ……</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line"> ]</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 package.json 里配置运行的命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: </span><br><span class="line">&#123; </span><br><span class="line">　　<span class="string">"start"</span>: <span class="string">"webpack-dev-server --inline"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="代理远程接口"><a href="#代理远程接口" class="headerlink" title="代理远程接口"></a>代理远程接口</h2><p>如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。<br>webpack-dev-server 使用了非常强大的 http-proxy-middleware 包。</p><p>配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">'/apis'</span>: &#123;</span><br><span class="line">        target: <span class="string">''</span>, <span class="comment">//要代理到的地址</span></span><br><span class="line">        secure: <span class="literal">false</span>, <span class="comment">//若地址为https，需要设置为false</span></span><br><span class="line">        onProxyReq: <span class="function"><span class="keyword">function</span>(<span class="params">proxyReq, req, res</span>) </span>&#123; <span class="comment">//提前设置一些代理的头部，如token信息等</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//...其他配置请自行查阅文档http-proxy-middleware文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h2><p>DevServer 还支持一 种叫做模块热替换( Hot Module Replacement )的技术可在不刷新整个网页的情况下 做到超 灵敏实时预览。原理是在一个源码发生变化时，只需重新编译发生变化的模块，再用新输 出 的模块替换掉浏览器中对应的老模块 。</p><p>模块热替换技术的优势如下：</p><ul><li>实时预览反应更快，等待时间更短。</li><li>不刷新浏览器时能保留当前网页的运行状态，例如在使用 Redux 管理数据的应用中搭配模块热替换能做到在代码更新时 Redux 中的数据保持不变。</li></ul><p>总的来说，模块热替换技术在很大程度上提升了开发效率和体验 。</p><p>DevServer 默认不会开启模块热替换模式，要开启该模式，则只 需在启动时带上参数 –hot ，完整的命令是 webpack-dev-server –hot。</p><p>除了通过在启动时带上 –hot 参数，还可以通过接入 Plugin 实现，相关代码如下 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">canst HotModuleReplacementPlugin = <span class="built_in">require</span> (’ webpack/lib/HotModuleReplacementPlugin ’);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">entry:&#123;</span><br><span class="line"><span class="comment">//为每个入口都注入代理客户端</span></span><br><span class="line">main: [’ webpack-dev-server/client?http:<span class="comment">//localhost:8080 /’, ’webpack/hot/dev-server ’,’. / src/main.j s ’],</span></span><br><span class="line">&#125;,</span><br><span class="line"> plugIns : [</span><br><span class="line"><span class="comment">//该插件的作用就是实现模块热替换，实际上若启动时带上 、 --hot 、参数，就会注入该插件，生 成 .hot-update.json 文件。</span></span><br><span class="line"><span class="keyword">new</span> HotModuleReplacementPlugin() ,</span><br><span class="line">],</span><br><span class="line">devServer : &#123;</span><br><span class="line"><span class="comment">//告诉 DevServer 要开启 模块热替换模式 </span></span><br><span class="line">hot: <span class="literal">true</span> ,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>借助于 style-loader 的帮助，CSS 的模块热替换实际上是相当简单的。当更新 CSS 依赖模块时，此 loader 在后台使用 module.hot.accept 来修补(patch) <code>&lt;style&gt;</code>标签。</p><p>但当修改 js 文件时，我们会发现模块热替换没有生效，而是整个页面被刷新了，为了让使用者在使用模块热替换功能时能灵活地控制老模块被替换时的逻辑，webpack 允许在源码中定义一些代码去做相应的处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当开启了模块热替换时 module.hot 才存在 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept([<span class="string">'.IAppComponent'</span>],()=&gt;&#123;</span><br><span class="line"><span class="comment">//在新的 AppComponent 加载成功后重新执行组建渲染逻辑 render(&lt;AppComponentl&gt;, window.document.getElementByid ('app'));</span></span><br><span class="line">&#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 module.hot 是当开启模块热替换后注入全局的 API，用于控制模块热替换的逻辑 。<br>当子模块发生更新时，更新事件会一层层地向上传递，也就是从 AppComponent.js 文件传递到 main.js 文件，直到有某层的文件接收了当前变化的模块，即 main.js 文 件中定义的 module.hot.accept([‘.IAppComponent’], callback)，这时就会调用 callback 函数去执行自定义逻辑。 如果事件一直往上抛，到最外层都没有文件接收它，则会直接刷新网页。</p><h2 id="开启调试-SourceMap"><a href="#开启调试-SourceMap" class="headerlink" title="开启调试 SourceMap"></a>开启调试 SourceMap</h2><p>作为一个程序员每天的大部分工作就是调试自己写的程序，那我们使用了webpack后，所以代码都打包到了一起，给调试带来了麻烦，但是 webpack 已经为我们充分考虑好了这点，它支持生产 Source Maps 来方便我们的调试。<br>在使用 webpack 时只要通过简单的 devtool 配置，webapck 就会自动给我们生产 source maps 文件，map 文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。</p><p>在配置 devtool 时，webpack 给我们提供了四种选项：</p><ul><li>source-map: 在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的 source map ，但是它会减慢打包速度；</li><li>cheap-module-source-map: 在一个单独的文件中产生一个不带列映射的map ，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</li><li>eval-source-map: 使用 eval 打包源文件模块，在同一个文件中生产干净的完整版的 sourcemap ，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</li><li>cheap-module-eval-source-map: 这是在打包文件时最快的生产 source map 的方法，生产的 Source map 会和打包后的 JavaScript 文件同行显示，没有影射列，和 eval-source-map 选项具有相似的缺点。<br>四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。</li></ul><p>个人意见是，如果大型项目可以使用 source-map，如果是中小型项目使用 eval-source-map 就完全可以应对，需要强调说明的是，source map 只适用于开发阶段，上线前记得修改这些调试设置。</p><p>简单的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  entry:  __dirname + <span class="string">"/app/main.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">"/public"</span>,</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置-ESLint-检查代码格式"><a href="#设置-ESLint-检查代码格式" class="headerlink" title="设置 ESLint 检查代码格式"></a>设置 ESLint 检查代码格式</h2><p>首先，要使 webpack 支持 eslint，就要要安装 eslint-loader ，命令如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">    enforce: <span class="string">"pre"</span>,</span><br><span class="line">    include: [path.resolve(__dirname, <span class="string">'src'</span>)], <span class="comment">// 指定检查的目录</span></span><br><span class="line">    options: &#123; <span class="comment">// 这里的配置项参数将会被传递到 eslint 的 CLIEngine </span></span><br><span class="line">        formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>) <span class="comment">// 指定错误报告的格式规范</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：formatter 默认是 stylish ，如果想用第三方的可以安装该插件，如上方的示例中的 eslint-friendly-formatter 。</p></blockquote><p>其次，要想 webpack 具有 eslint 的能力，就要安装 eslint，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br></pre></td></tr></table></figure><p>最后，项目想要使用那些 eslin 规则，可以创建一个配置项文件 ‘.eslintrc.js’，代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>, </span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"indent"</span>: [<span class="string">"error"</span>, <span class="number">2</span>],</span><br><span class="line">        <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>],</span><br><span class="line">        <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="string">"no-console"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"arrow-parens"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的 webpack 引入 eslint 已经完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>webpack 确实是一个功能强大的模块打包工具，丰富的 loader 和 plugin 使得其功能多而强。学习 webpack 使得我们可以自定义自己的开发环境，无需依赖 create-react-app 和 Vue-Cli 这类脚手架，也可以针对不同的需求对代码进行不同方案的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。&lt;/p&gt;
    
    </summary>
    
      <category term="matengfei" scheme="http://xgfe.github.io/categories/matengfei/"/>
    
    
      <category term="webpack" scheme="http://xgfe.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Web 前端安全科普之 XSS</title>
    <link href="http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/"/>
    <id>http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/</id>
    <published>2018-06-13T03:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.258Z</updated>
    
    <content type="html"><![CDATA[<p>Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。</p><p>XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。</p><p>在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。</p><a id="more"></a><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>跨站脚本的重点在脚本上，绝大多数的 XSS 会采用一段远程或者第三方域上的脚本资源，这样做的好处是攻击代码容易控制。script 标签可以嵌入第三方资源，这是浏览器允许的，对于嵌入的脚本内容，会与本域的脚本内容一样，在整个脚本上下文环境中存在，那么在这个场景中的各种功能都可以由嵌入的脚本实现，也就是说 JavaScript 能做到什么效果，XSS 的威力就有多大。</p><p>JavaScript 可以用用来获取的 Cookie、改变网页内容、URL 跳转，那么存在 XSS 漏洞的网站，就可以盗取用户 Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向 Web 页面中注入 JavaScript 代码。</p><p>XSS 攻击原理主要包括三个部分：</p><ul><li><p>攻击者对某含有漏洞的服务器发起 XSS 攻击（注入 JS 代码）。</p></li><li><p>诱使受害者打开受到攻击的服务器 URL（邮件、留言等，此步骤可选项）。</p></li><li><p>受害者在 Web 浏览器中打开 URL，恶意脚本执行。</p></li></ul><p>XSS 构造的例子：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入内容直接拼接到返回 HTML 里</span><br><span class="line">res.body = &apos;...&lt;div&gt;&apos; + data.用户输入的内容 + &apos;&lt;/div&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入的内容直接拼接到了页面元素的属性中</span><br><span class="line">res.body = &apos;...&lt;img src=&quot; + data.用户输入的图片地址 + &quot;&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&quot; /&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面中</span><br><span class="line">div.innerHTML = data.用户输入的内容</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，innerHTML 中的 script 标签不会被执行，但是攻击者可以这么写：</span><br><span class="line">&lt;img src=&quot;x.png&quot; onload=&quot;alert(123)&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面元素的属性中</span><br><span class="line">a.href = data.用户输入的链接</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，给元素的属性赋值时内容总会被当成字符串，但是攻击者可以这么写，如用户点了链接就会受到攻击：</span><br><span class="line">javascript:alert(123)</span><br></pre></td></tr></table></figure></code></pre><h2 id="XSS-类型"><a href="#XSS-类型" class="headerlink" title="XSS 类型"></a>XSS 类型</h2><p>XSS 有三种类型，分别是反射型 XSS、存储型 XSS、DOM XSS，下面分别对这三种 XSS 进行介绍。</p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 也被称为非持久性 XSS，是最容易出现的一种 XSS 漏洞，指的是发送请求时，XSS 代码出现在 URL 中，作为输入提交到服务端，服务端解析后响应，在响应内容中出现这段 XSS 代码，最后被浏览器解析执行。这个过程就像是一次反射，故称为反射型 XSS。它的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">&lt;?php</span><br><span class="line">    echo $_GET[&apos;x&apos;];</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">// 在浏览器地址栏中输入</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/a7271f75b155dbab2e0c3fb758cbe111100565.png" alt="反射型XSS"></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型 XSS 又被称为永久性 XSS，是最危险的一种跨站脚本，指的是发送请求时，提交的 XSS 代码会存储在服务端（不管是数据库、内存还是文件系统），下次请求目标页面时不用再提交 XSS 代码，存储型 XSS 的攻击是最隐蔽的，其危害性也更大。与反射型 XSS 和 DOM XSS 相比，存储型 XSS 的执行不需要手动触发。最典型的例子是留言板 XSS，用户提交一条包含 XSS 代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容就会从数据库查询出来并显示，浏览器发现有 XSS 代码，就当做正常的 HTML 与 JS 解析执行，于是就触发了 XSS 攻击。它的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。</p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>DOM XSS 指的是 XSS 代码并不需要服务器解析响应的直接参与，触发 XSS 靠的就是浏览器端的 DOM 解析，可以认为完全是客户端的事情。它的数据流向是：URL-&gt;浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 客户端的脚本</span><br><span class="line">&lt;script&gt;eval(location.hash.substr(1));&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 用户点击这个 URL# 后的内容不会发送到服务端，仅在客户端被接收并解释执行。</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/919bcf853c27bbd16656cfa83b8b6ef887889.png" alt="DOM XSS"></p><h4 id="DOM-XSS-场景一：在前端实现页面跳转"><a href="#DOM-XSS-场景一：在前端实现页面跳转" class="headerlink" title="DOM XSS 场景一：在前端实现页面跳转"></a>DOM XSS 场景一：在前端实现页面跳转</h4><p>在前端实现页面跳转，前端通常会通过 JavaScript 实现跳转，最常用到的方法有: location.href / location.replace() / location.assign()。 在该场景下，可以通过伪协议“javascript:”、“data:”在浏览器下执行脚本。但是这种通过伪协议进行攻击已经随着前端工程处理对相关跳转代码逻辑做了很好的完善，基本上不会再出现上述的这种情况。但是如下两种情况却为 Web 攻击打开了天窗：</p><ul><li><p>使用 indexOf 判断 URL 参数是否合法，indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。所以如果 URL 中包含了伪代码及攻击代码，就会被攻击。</p></li><li><p>正则表达式判断 URL 是否合法，为了避免使用 indexOf 判断 URL 带来的缺陷，有些开发人员会想到用正则表达式，但忘了一个神奇的符号“^”，加上和不加上，过滤的效果具有天壤之别，如果没有加“^”，攻击者仍然可以绕过正则的过滤，在URL中植入伪代码和攻击代码。</p></li><li><p>修复方案：在前端实现页面跳转业务场景下，正确的过滤实现方法是，严格限制跳转范围。一方面要限制能够跳转页面的协议：只能是 http、https 或是其他指可控协议；另一方面，要严格限制跳转的范围，如果业务只要跳转到指定的几个页面，可以直接从数组中取值判断是否这几个页面，如果跳转范围稍大，正确使用正则表达式将跳转URL严格限制到可控范围内。 </p></li></ul><h4 id="DOM-XSS-场景二：取值写入页面或动态执行"><a href="#DOM-XSS-场景二：取值写入页面或动态执行" class="headerlink" title="DOM XSS 场景二：取值写入页面或动态执行"></a>DOM XSS 场景二：取值写入页面或动态执行</h4><p>除接收 URL 参数经后端处理最后在前端展示外，在 Web 前端通过 JavaScript 获取不同来源的参数值，不经后端处理即刻在 Web 页面进行展示或动态执行的业务场景也十分常见，想要在客户端实现接受参数并写入页面或动态执行，就不得不用到 innerHTML、document.write、eval。因为 JavaScript 取值的来源纷繁复杂，如果忘记做转义处理，或过分相信取值来源的数据，直接将分离出的参数值交给 JavaScriptinnerHTML、document.write、eval处理，就有可能招来 DOM-XSS。下面是三种常见的缺陷： </p><ul><li><p>从 URL 中的取参数值写入页面或动态执行，如直接从 URL 的锚参数（即位于#后面的参数）中取值，不经过任何处理直接 innerHTML 写入页面，导致攻击者只需要构造如下URL即可完成一次 DOM XSS 攻击。由于整个攻击过程在客户端侧完成，不需要向服务器发送任何请求数据，所以即便业务接入了对抗反射型 XSS 的 Web 应用防火墙（WAF），这类 DOM XSS 也无法被感知，攻击者便可畅通无阻的利用漏洞对用户开展攻击。 </p></li><li><p>从 Cookie 中的取参数值写入页面或动态执行，原理基本同从 URL 中的取参数值写入页面或动态执行，只是换了一个取值来源而已。</p></li><li><p>从 LocalStorage、Referer、Window name、SessionStorage中的取参数值写入页面或动态执行 ，如取 window.name 的值，最后直接 innerHTML 到页面中。一般情况下，页面的 window.name 攻击者不可控，故往往会被认为来源相对可信。但借助i frame 的 name 属性，攻击者可以将页面的 window.name 设置为攻击代码，仍然可以构造 DOM XSS。</p></li><li><p>修复方案：</p><ul><li><p>写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的 HTML 特殊字符进行转义处理能防止大部分 DOM-XSS 的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。 </p></li><li><p>慎用危险的“eval”。需要强调的是，由于 JavaScript 中的 eval 函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用 eval<br>函数处理不可控的外部数据。 </p></li><li><p>编写安全的函数方法，从看似“可靠”的数据源获取参数值。无论是从 Cookie，还是从LocalStorage、Referer、Window name、SessionStorage 中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。 </p></li></ul></li></ul><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><ul><li><p>盗取用户的 Cookie，Cookie 经常被用来存储用户的会话信息，比如用户登录认证后的 session，之后同域内发出的请求都会自动带上认证后的会话信息。如果 Cookie被盗取，攻击者就可以不用通过密码而直接登录用户的账户。Cookie 的重要字段：[name] [value] [domain] [path] [expires] [httponly] [secure]，其含义依次是：名称、值、所属域名、所属相对根路径、过期时间、是否有 HttpOnly 标志、是否有 Secure 标志。如果设置了 HttpOnly 标志，客户端脚本就无法通过document.cookie 获取该 Cookie，这样就能有效地防御 XSS 攻击获取 Cookie。</p></li><li><p>构建 GET 和 POST 请求，如果 Cookie 设置了 HttpOnly 标志，则无法直接劫持 Cookie 来使用了，但是 XSS 可以在 JavaScript 中构建 GET 或者 POST 请求，来实现自己的攻击。只要让用户执行下面这段脚本，就能发起 GET 请求，攻击者通过 XSS 诱导用户来执行。XSS 的攻击过程都是在浏览器通过执行 JavaScript 脚本自动进行，缺少与用户交互的过程。例如在 POST 的请求中，如果需要输入验证码，JS 代码无法解析验证码，攻击也就无法实现。但是针对验证码这种情况，如果 XSS 可以通过把验证码的图片发到远端攻击服务器，服务器解析验证码然后把结果返回给 JS 代码，JS 获取后继续进行攻击，不过就是成本有点高。</p></li><li><p>XSS 钓鱼：上面模拟用户的 POST 请求貌似成本有点高，攻击者可以将 XSS 和钓鱼结合在一起，例如通过 JavaScript 代码模拟出网站的登录框，用户输入用户名和密码后，XSS 将这些信息发送到服务器端，用来进行攻击。</p></li><li><p>获取用户系统信息，此外 XSS 还可以识别用户的浏览器信息、用户安装的软件以及用户真实的 IP 等信息。</p></li><li><p>XSS Worm：这是 XSS 的一种终极利用方式，破坏力和影响力是巨大的，与蠕虫病毒一样具有“传染性”，与系统病毒的唯一区别就是无法对系统底层操作。XSS 蠕虫是针对浏览器的攻击，网站规模越大，攻击效果就越大。一般来说，用户直接发生交互行为的页面，如果存在存储型 XSS，则比较容易发起 Worm 攻击。</p></li></ul><h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><ul><li><p>任何由用户输出的数据都是不可信的。</p></li><li><p>不要在奇怪的地方插入不可信的数据。</p><p><img src="http://vfile.meituan.net/xgfe/0a853e1b33a7dfaeb4aa47f12453026b97763.png" alt="不可信数据"></p></li><li><p>进行输入输出检查，将期望被当成字符串的不可信数据转义后再插入文档中，不同位置需要使用不同的转义逻辑。</p><p><img src="http://vfile.meituan.net/xgfe/3df441ed85fa308c54a059924acd16e0248873.png" alt="输入输出检查"></p></li><li><p>将期望被当成 HTML 的不可信数据使用专业的库消毒后再插入文档中。</p></li><li><p>使用 HttpOnly 的 Cookie，给关键的 Cookie 设置 HttpOnly 属性，这样能够避免 JS 读取 Cookie信息，设置后有助于缓解 XSS，但是 XSS 除了劫持 Cookie 之外，还可以模拟用户的身份进行操作。</p></li><li><p>使用内容安全策略（CSP）是对抗 XSS 的深度防御策略，内容安全策略可以以白名单的方式限定哪些地方的内容可以被加载和执行，如果不存在可以通过本地文件放置恶意代码的其他漏洞，则该策略是有效的。</p></li><li><p>使用设计上就会自动编码来解决XSS问题的框架，如：React JS。了解每个框架的 XSS 保护的局限性，并适当地处理未覆盖的用例。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">XSS攻击手册</a></p></li><li><p><a href="https://www.owasp.org/index.php/XSS_Prevention_Cheat_Sheet" target="_blank" rel="noopener">XSS防御手册</a></p></li><li><p>《Web前端黑客技术揭秘》</p></li><li><p>《Web安全深度剖析》</p></li><li><p>《白帽子讲Web安全》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。&lt;/p&gt;
&lt;p&gt;XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。&lt;/p&gt;
&lt;p&gt;CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。&lt;/p&gt;
&lt;p&gt;界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。&lt;/p&gt;
&lt;p&gt;在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpeiyu" scheme="http://xgfe.github.io/categories/wangpeiyu/"/>
    
    
      <category term="XSS" scheme="http://xgfe.github.io/tags/XSS/"/>
    
      <category term="Web 安全" scheme="http://xgfe.github.io/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
      <category term="前端安全" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前后端通信的几种方式</title>
    <link href="http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/"/>
    <id>http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-10-26T08:09:54.357Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。</p><a id="more"></a><h2 id="一、前后端通信（同源）简介"><a href="#一、前后端通信（同源）简介" class="headerlink" title="一、前后端通信（同源）简介"></a>一、前后端通信（同源）简介</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>同源策略显示从一个源加载的文档或脚本如何来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。源包含三部分内容（协议，端口和域名，默认端口是 80 ）。<br>同源的限制：<br>（1）Cookie , LocalStorage 和 IndexDB 无法获取<br>（2）DOM无法获得和操作<br>（3）Ajax请求不能发送，只是用与同源通信</p><h3 id="2-前后端通信的几种方式"><a href="#2-前后端通信的几种方式" class="headerlink" title="2.前后端通信的几种方式"></a>2.前后端通信的几种方式</h3><ul><li>Ajax（同源下面的通信方式）</li><li>WebSocket（不受同源策略限制）</li><li>CORS（支持跨域也支持同源）</li></ul><h3 id="3-如何创建一个Ajax"><a href="#3-如何创建一个Ajax" class="headerlink" title="3.如何创建一个Ajax"></a>3.如何创建一个Ajax</h3><p>发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）<br>（1）创建 XMLHttpRequest 对象。<br>（2）使用 open 方法设置请求的参数。open ( method , url, 是否异步)。<br>（3）发送请求。<br>（4）注册事件。 注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。<br>（5）获取返回的数据，更新UI。<br>post 请求举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 建立XMLHttpRequest对象       </span><br><span class="line">var xhr = new XMLHttpRequest();        </span><br><span class="line">xhr.open(&apos;post&apos;, &apos;02.post.php&apos;);           </span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">// 将数据通过send方法传递       </span><br><span class="line">xhr.send(&apos;name=fox&amp;age=18&apos;);            </span><br><span class="line">xhr.onreadystatechange = function () &#123;                 </span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; </span><br><span class="line">        //判断返回状态  </span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-实际开发中用的原生Ajax请求"><a href="#4-实际开发中用的原生Ajax请求" class="headerlink" title="4.实际开发中用的原生Ajax请求"></a>4.实际开发中用的原生Ajax请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">var util = &#123;&#125;;      </span><br><span class="line">//获取 Ajax 请求之后的 json     </span><br><span class="line">util.json = function (options) &#123;</span><br><span class="line">    var opt = &#123;</span><br><span class="line">        url: &apos;&apos;,</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    Object.assign(opt, options);</span><br><span class="line">    //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api             </span><br><span class="line">    var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    var data = opt.data,</span><br><span class="line">    var type = opt.type.toUpperCase();</span><br><span class="line">    var dataArr = [];</span><br><span class="line">    if (opt.url) &#123;   </span><br><span class="line">        var url = opt.url;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var key in data) &#123;</span><br><span class="line">        dataArr.push(key + &apos;=&apos; + data[key]);</span><br><span class="line">    &#125; </span><br><span class="line">    if (type === &apos;GET&apos;) &#123;</span><br><span class="line">        url = url + &apos;?&apos; + dataArr.join(&apos;&amp;&apos;);</span><br><span class="line">        xhr.open(type, url.replace(/\?$/g, &apos;&apos;), true);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    if (type === &apos;POST&apos;) &#123;</span><br><span class="line">        xhr.open(type, url, true);</span><br><span class="line">        // 如果想要使用post提交数据,需要明确设置Request Header    </span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.send(dataArr.join(&apos;&amp;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.status === 200 || xhr.status === 304) &#123;</span><br><span class="line">            //304表示：用缓存即可。206表示获取媒体资源的前面一部分                </span><br><span class="line">            var res;</span><br><span class="line">            if (opt.success &amp;&amp; opt.success instanceof Function) &#123;</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                if (typeof res === &apos;string&apos;) &#123;</span><br><span class="line">                    //将字符串转成json</span><br><span class="line">                    res = JSON.parse(res);                           </span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (opt.error &amp;&amp; opt.error instanceof Function) &#123;</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-WebSocket-介绍"><a href="#5-WebSocket-介绍" class="headerlink" title="5.WebSocket 介绍"></a>5.WebSocket 介绍</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。所以出现了 WebSocket 。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br>其他特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p><p>通常WebSocket协议的链接如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure></p><p>WebSocket 的实现需要后端搭建一个 WebSocket 服务器，但是如果想搭建一个 WebSocket 服务器就没有那么轻松了，因为 WebSocket 是一种新的通信协议，目前还是草案，没有成为标准，比如 PyWebSocket , WebSocket-Node , LibWebSockets 等等，这些库文件已经实现了WebSocket 数据包的封装和解析，我们可以调用这些接口，这在很大程度上减少了我们的工作量。<br>具体的实现方式：（在客户端）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 再js文件中 创建WebSocket对象</span><br><span class="line">var ws = new WebSocket(‘wss://echo.WebSocket.org’);</span><br><span class="line">ws.onopen = function (evt) &#123;</span><br><span class="line">    console.log(‘connnection……’);</span><br><span class="line">    ws.send(&apos;hello WebSocket&apos;);</span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage = function (evt) &#123;</span><br><span class="line">    console.log(&apos;received message&apos; + evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;</span><br><span class="line">ws.onclose = dunction(evt)&#123;</span><br><span class="line">    console.log(&apos;connection closed.&apos;);</span><br><span class="line">&#125;   </span><br><span class="line">// ws的使用，以为按钮添加发送信息事件为例</span><br><span class="line">$(&quot;#send&quot;).click(function()&#123;</span><br><span class="line">    ws.send($(&quot;#msg&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="6-CORS-介绍"><a href="#6-CORS-介绍" class="headerlink" title="6.CORS 介绍"></a>6.CORS 介绍</h3><p>CORS是一个 W3C 标准，跨域资源共享（CORS ）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。CORS 系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。简言之， CORS 就是为了让 AJAX 可以实现可控的跨域访问而生的。<br>下图为各浏览器对于 CORS 的支持情况，看起来相当乐观。主流浏览器都已基本提供对跨域资源共享的支持，所以，CORS 才会在国外使用的如此普遍。<br><img src="http://vfile.meituan.net/xgfe/d87439988ef5ab43251311a668d027d6233940.png" alt=""><br>使用 CORS 需要做服务端和前端的配置：</p><h4 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h4><p>以下是 CORS 协议规定的 HTTP 头，用来进行浏览器发起跨域资源请求时进行协商：</p><ol><li>Origin。HTTP 请求头，任何涉及 CORS 的请求都必需携带。</li><li>Access-Control-Request-Method。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的方法。</li><li>Access-Control-Request-Headers。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的自定义 Header 列表。</li><li>Access-Control-Allow-Origin。HTTP 响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符 * 表示允许任何域的JavaScript 访问资源，但是在响应一个携带身份信息( Credential )的 HTTP 请求时，Access-Control-Allow-Origin 必需指定具体的域，不能用通配符。</li><li>Access-Control-Allow-Methods。HTTP 响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。</li><li>Access-Control-Allow-Headers。HTTP 响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。</li><li>Access-Control-Max-Age。HTTP 响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。</li><li>Access-Control-Allow-Credentials。HTTP 响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回。</li></ol><p>实际应用中，服务端例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//允许跨域访问  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,PUT&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Test&quot;);</span><br></pre></td></tr></table></figure><h4 id="前端的配置"><a href="#前端的配置" class="headerlink" title="前端的配置"></a>前端的配置</h4><p>前端的配置主要从简单请求、非简单请求和携带身份凭证这三点进行讲解。<br>浏览器将CORS请求分成两类：简单请求（ simple request ）和非简单请求（ not-so-simple request ）。<br>1.简单请求：<br>使用下列方法：GET、 HEAD、 POST<br>HTTP的头信息主要是以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type 的值属于下列之一: <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><p>简单请求如图所示：<br><img src="http://vfile.meituan.net/xgfe/63958e7743ea262c379f4466c52844a636486.png" alt=""><br>2.非简单请求：<br>不满足简单请求条件的请求则要先进行预检请求，即使用 OPTIONS 方法发起一个预检请求到服务器，已获知服务器是否允许该实际请求。<br>非简单请求如下所示：<br><img src="http://vfile.meituan.net/xgfe/cf3757d6cc10ac2d4c9c023af564900f126443.png" alt=""><br>浏览器与服务器之间请求只进行了一次。<br>下面是 PUT 请求第一次返回的结果：<br><img src="http://vfile.meituan.net/xgfe/33d389422e08f9f730faa7757ef26bba81218.png" alt=""><br><img src="http://vfile.meituan.net/xgfe/000d4cf1b6d92837affcddef925df2a176640.png" alt=""><br>通过PUT请求结果可以看出，当检测到 PUT 请求为非简单请求时，浏览器便会发送一个预检请求，目的是询问，自定义头部 X-Custom-Header 的 PUT 请求是否被允许，浏览器返回了所有可以请求的方法和自定义的头部（把所有可以的返回是为了避免多次预检请求），这时候预检请求成功了，便会发送真正的PUT请求。</p><p>关于预检请求，需要注意一下两点：</p><ul><li>预检请求对 js 来说是透明的，js 获取不到预检请求的任何信息。</li><li>预检请求并不是每次请求都发生，服务端设置的 Access-Control-Max-Age 头部指定了预检请求的有效期，在有效期内的非简单请求不需要再次发生预检请求。</li></ul><p>3.携带身份凭证<br>大部分的请求是需要用户携带着用户信息的，比如在一个登录的系统中，用户会携带着相应的 cookie 或 token ，但 CORS 跨域默认是不带身份凭证的。<br>如果需要附带身份凭证，在发送请求时，通过将 withCredentials 属性设置为 true ，可以指定某个请求可以发送凭据。<br>下面提供针对 XMLHttpRequest 附带身份凭证的兼容性写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function createCORSRequest(method, url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr == 304) &#123;</span><br><span class="line">                console.log(xhr.response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&apos;Request was unsuccessful: &apos; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    if(&apos;withCredentials&apos; in xhr) &#123;</span><br><span class="line">        xhr.open(method,url, true);</span><br><span class="line">    &#125; else if(typeof XDomainRequest != &apos;undefined&apos;) &#123;</span><br><span class="line">        xhr = new XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附带身份凭证对服务端有两个要求：</p><ol><li>服务端的 Access-Control-Allow-Origin 头部不能设置为 *</li><li>服务端的 Access-Control-Allow-Credentials 头部设置为 true</li></ol><h2 id="二、-前后端跨域通信"><a href="#二、-前后端跨域通信" class="headerlink" title="二、 前后端跨域通信"></a>二、 前后端跨域通信</h2><ul><li>JSONP</li><li>Hash</li><li>WebSocket</li><li>CORS</li></ul><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP 的工作原理：<br>本质是利用了 script 标签具有可跨域的特性，由服务端返回预先定义好的 javascript 全局函数的调用，并且将服务端数据以该函数参数的形式传递过来。比如说，客户端这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>实际开发中，前端的 JSONP 是这样实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> var util = &#123;&#125;; </span><br><span class="line"> //定义方法：动态创建script标签</span><br><span class="line"> util.createScript = function (url, charset) &#123;</span><br><span class="line">     var script = document.createElement(&apos;script&apos;);</span><br><span class="line">     script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">     charset &amp;&amp; script.setAttribute(&apos;charset&apos;, charset);</span><br><span class="line">     script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">     script.async = true;</span><br><span class="line">     return script;</span><br><span class="line">&#125;;</span><br><span class="line"> util.jsonp = function (url, onsuccess, onerror, charset) &#123;  </span><br><span class="line">     //事先约定好的函数名</span><br><span class="line">     var callbackName = util.getName(&apos;tt_player&apos;);  </span><br><span class="line">     //根据回调名称注册一个全局的函数 </span><br><span class="line">     window[callbackName] = function () &#123;               </span><br><span class="line">         if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span><br><span class="line">             onsuccess(arguments[0]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //动态创建一个script标签</span><br><span class="line">     var script = util.createScript(url + &apos;&amp;callback=&apos; + callbackName, charset);   </span><br><span class="line">     //监听加载成功的事件，获取数据</span><br><span class="line">     script.onreadystatechange = function () &#123;      </span><br><span class="line">         if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123;              </span><br><span class="line">             if (script.parentNode) &#123;</span><br><span class="line">                 // 删除函数或变量</span><br><span class="line">                 script.parentNode.removeChild(script);  </span><br><span class="line">             &#125;      </span><br><span class="line">             //最后不要忘了删除           </span><br><span class="line">             window[callbackName] = null;  </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     script.onerror = function () &#123;                              </span><br><span class="line">         if (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span><br><span class="line">             onerror();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //往html中增加这个标签，目的是把请求发送出去</span><br><span class="line">     document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h3><p>url 的#后面的内容就叫 Hash 。Hash 的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。<br>补充：url 的?后面的内容叫 Search 。 Search 的改变，会导致页面刷新，因此不能做跨域通信。<br>使用举例：<br>场景：我的页面 A 通过 iframe 或 frame 嵌入了跨域的页面 B。<br>现在，我这个 A 页面想给B页面发消息，怎么操作呢？<br>（1）首先，在我的A页面中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码  </span><br><span class="line">var B = document.getElementsByTagName(&apos;iframe&apos;);  </span><br><span class="line">//我们可以把JS对象，通过JSON.stringify()方法转成json字符串，发给B   </span><br><span class="line">B.src = B.src + &apos;#&apos; + &apos;jsonString&apos;;</span><br></pre></td></tr></table></figure><p>（2）然后，在 B 页面中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// B 中的伪代码     </span><br><span class="line">window.onhashchange = function () &#123; </span><br><span class="line">     //通过onhashchange方法监听，url中的hash是否发生变化         </span><br><span class="line">     var data = window.location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>总结：<br>本文主要对前后端通信的几种方式做了简单介绍，希望对大家对前后端通信方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://blog.csdn.net/a54654132/article/details/77604597" target="_blank" rel="noopener">https://blog.csdn.net/a54654132/article/details/77604597</a><br><a href="https://www.cnblogs.com/yanglang/p/6720887.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/6720887.html</a><br><a href="https://www.cnblogs.com/smyhvae/p/8523576.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/8523576.html</a><br><a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/6337580.html</a><br><a href="https://blog.csdn.net/qq_27905183/article/details/71023542" target="_blank" rel="noopener">https://blog.csdn.net/qq_27905183/article/details/71023542</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="ANJING" scheme="http://xgfe.github.io/categories/ANJING/"/>
    
    
      <category term="前后端通信" scheme="http://xgfe.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>数组去重的十种方法</title>
    <link href="http://xgfe.github.io/2018/06/07/yuxue/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://xgfe.github.io/2018/06/07/yuxue/数组去重的十种方法/</id>
    <published>2018-06-07T03:12:00.000Z</published>
    <updated>2018-10-24T08:01:13.336Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。</p><a id="more"></a><h2 id="一、-双重遍历"><a href="#一、-双重遍历" class="headerlink" title="一、 双重遍历"></a>一、 双重遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.splice(j,<span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr.unique();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr1.unique1();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>双重遍历的方式是最容易想到且最容易实现的方式，兼容性比较好，但是时间复杂度比较高；还有一点是不能对 NaN 进行去重。</p><h2 id="二、-indexOf"><a href="#二、-indexOf" class="headerlink" title="二、 indexOf"></a>二、 indexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(newArr.indexOf(<span class="keyword">this</span>[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2.unique2();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="三、-数组下标判断"><a href="#三、-数组下标判断" class="headerlink" title="三、 数组下标判断"></a>三、 数组下标判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) === i) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line">arr3.unique3();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>因为 indexOf 使用的内部严格相等比较算法，所以在检索NaN时会返回-1 ，进而会导致方法3直接过滤掉了 NaN。</p><h2 id="四、排序再去重"><a href="#四、排序再去重" class="headerlink" title="四、排序再去重"></a>四、排序再去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];<span class="keyword">this</span>.sort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] !== newArr[newArr.length<span class="number">-1</span>]) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr4.unique4();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>优点是利用 js 内置的排序方法，速度快，比较的是排序后的相邻元素。最大的不同是更改了原数组的排序。</p><h2 id="五、利用对象的属性"><a href="#五、利用对象的属性" class="headerlink" title="五、利用对象的属性"></a>五、利用对象的属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique5 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!obj[<span class="keyword">this</span>[i]])&#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">obj[<span class="keyword">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr5.unique5();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">let</span> arr6 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique6 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> tmpKey;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">tmpKey = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i]);</span><br><span class="line"><span class="keyword">if</span>(!obj[tmpKey]) &#123;</span><br><span class="line">obj[tmpKey] = <span class="number">1</span>;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr6.unique6();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>由于对象的键名只能是 String，所以版本1的局限性在于</p><ol><li><p>无法区分隐式类型转换成字符串后一样的值，比如 1 和 “1”</p></li><li><p>无法处理复杂类型，比如对象（因为对象作为key会变成[ object Object ]）</p></li><li><p>特殊数据，比如 <code>__proto__</code> 会挂掉，因为obj对象的 <code>__proto__</code> 属性无法被重写</p></li></ol><p>版本2的优化则解决了这三个问题。缺点就是实现的方式比较麻烦。</p><h2 id="六、-reduce"><a href="#六、-reduce" class="headerlink" title="六、 reduce"></a>六、 reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr7 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique7 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">initialValue, current</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(initialValue.length === <span class="number">0</span> || initialValue[initialValue.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">initialValue.push(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> initialValue;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr7.unique7();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>原理实际同方法四，都是进行排序后比较相邻的两个值。</p><h2 id="七、-filter"><a href="#七、-filter" class="headerlink" title="七、 filter"></a>七、 filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr8 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique8 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index,res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.indexOf(ele) === index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr8.unique8();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><h2 id="八、-es6-includes"><a href="#八、-es6-includes" class="headerlink" title="八、 es6 includes"></a>八、 es6 includes</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr9 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>,  <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique9 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!newArr.includes(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr9.unique9();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>与 indexOf 类似，但不同的是 indexOf 使用的严格比较，includes 使用的是叫做 SameValueZero 的比较，规范中给出 If x is NaN and y is NaN, return true. 也就是 includes 可以对NaN去重。</p><h2 id="九、-es6-Map"><a href="#九、-es6-Map" class="headerlink" title="九、 es6 Map"></a>九、 es6 Map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr10 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique10 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tmp.get(<span class="keyword">this</span>[i]))&#123;</span><br><span class="line">tmp.set(<span class="keyword">this</span>[i], <span class="number">1</span>);</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr10.unique10();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="十、-es6-Set"><a href="#十、-es6-Set" class="headerlink" title="十、 es6 Set"></a>十、 es6 Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr11 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr11)]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>利用 set 对象存储任何类型的唯一值的特性来达到去重的目的。</p><p>再来来看看这几种方式直观的性能对比。<br>通过以下的模拟数据的形式来执行我们上面介绍的每一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复100次生成1~10000的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArr</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> create = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line">            create.push(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算去重函数的时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTime</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    fn();</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">var</span> result = date2 - date1;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lgArr = createArr();</span><br><span class="line"><span class="keyword">const</span> res = checkTime(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> lgArr.unique()&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&#123;method：loop，time:"</span> + res + <span class="string">"&#125;"</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://vfile.meituan.net/xgfe/84a60f898fc7283c3ce2dc70d770b137116872.png" alt=""></p><p>在考虑兼容性,并且可以接受以上所说的 Object.key 的限制时，用对象属性方式是最快的。如果考虑这些限制，就要用到对象属性的优化方案，增加对 key 的类型的判断，但这样做显然会麻烦很多，如果处理不好还可能导致结果出错。那么在数据量比较小的情况下，选用 indexof 不失为一种更加稳妥的办法。</p><p>在现代浏览器中当然首选的是 es6 的 set 和 map ,方便易用。在不关注排序的情况下，reduce 和 sort 也是比较可取的方式。<br>以上仅仅是从时间维度上的个人分析。实际工作中还要根据情况进行综合考虑来选择最合适的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。&lt;/p&gt;
    
    </summary>
    
      <category term="yuxue" scheme="http://xgfe.github.io/categories/yuxue/"/>
    
    
      <category term="数组" scheme="http://xgfe.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="去重" scheme="http://xgfe.github.io/tags/%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>移动前端开发中的伪装术</title>
    <link href="http://xgfe.github.io/2018/05/30/zhaojun/hybrid/"/>
    <id>http://xgfe.github.io/2018/05/30/zhaojun/hybrid/</id>
    <published>2018-05-30T04:00:00.000Z</published>
    <updated>2018-10-24T07:51:20.238Z</updated>
    
    <content type="html"><![CDATA[<p>本文从一个web前端的角度讲述了在移动端开发中H5,Hybrid,react-native与原生应用的差距，探讨了如何将自己的应用，尽可能在UI，交互体验，流畅度方面去接近原生应用。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年双十一，中国客单占比中，有近90%的用户，使用移动设备下单。移动互联网在中国的普及程度可见一斑。正是因为用户终端的转变，前端攻城狮们的技能树也需要改变。</p><h2 id="战场的转移"><a href="#战场的转移" class="headerlink" title="战场的转移"></a>战场的转移</h2><p>目前前端攻城狮（由于背景是针对原本的web前端，本文暂时不把iOS和Android开发归入前端攻城狮的队伍中，虽然现在广义上来说app开发也属于前端开发）在移动端的主要战场有以下几个：</p><ol><li>普通浏览器网页的移动端响应式适配</li><li>hybrid（含微信小程序）</li><li>react native</li><li>PWA（暂时还是非主流）</li></ol><p>用一个表格整理一下</p><table><thead><tr><th></th><th>流畅度</th><th>交互体验</th><th>开发学习成本</th><th>功能及限制</th><th>发布</th></tr></thead><tbody><tr><td>移动端网页</td><td>最低</td><td>差</td><td>低，兼容性和响应式</td><td>需要浏览器运行，功能被浏览器限制</td><td>与web前端一致</td></tr><tr><td>Hybrid（含小程序）</td><td>低</td><td>较好</td><td>一套代码两端复用</td><td>通过JSBridge，SDK调用原生功能</td><td>通过热更新</td></tr><tr><td>React Native</td><td>高</td><td>好</td><td>一套代码两端复用，有个别组件和属性有平台差异</td><td>本身有组件和API可以调用部分原生功能，也可以用Bridge</td><td>通过热更新</td></tr><tr><td>原生APP</td><td>最高</td><td>最佳</td><td>学习成本大，需要开发ios端和安卓端</td><td>无限制</td><td>有审核，版本兼容问题多</td></tr></tbody></table><p>前端攻城狮在移动互联网的时代中是既希望保留前端开发敏捷灵活的特点，也希望可以给用户更好的交互体验。</p><h2 id="原生APP的交互体验"><a href="#原生APP的交互体验" class="headerlink" title="原生APP的交互体验"></a>原生APP的交互体验</h2><p>一个好的APP到底会和一个移动端网页有什么样的区别，这些差异能不能通过一些技术上的优化来抹平？</p><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>原生APP与WEB网页最直观的的区别就是UI上，APP和网页在设计上有很多各自的风格，当然这种风格上的差距是可以轻易抹平的。<br>UI的设计资源在前端团队中是非常的重要。比如说Ant Design提供的一些思路和实践：字体，行高，空白的大小都可以固定为一些常量，交互和组件UI包含在了组件之中。<br>简单说一下取色的过程。<a href="http://ant.design/docs/spec/colors-cn" target="_blank" rel="noopener">参考链接</a><br><img src="https://ws1.sinaimg.cn/large/6f3ac581gy1fv7x26gopdj20ow0gkmy0.jpg" alt=""><br>一般来说在设计过程中，一个应用多数是会有主色，辅助色，强调色。而在实际的开发中，例如图中蓝色的主色又会衍生为hover、click、disable等几种状态，如果一个项目并没有UI的介入，此时自动通过一个主色调，衍生出多种色彩就显得很重要。除了通过类似<a href="https://ant.design/docs/spec/colors-cn" target="_blank" rel="noopener">Ant Design的取色板</a>帮助取色外，也可以通过代码的手段。衍生颜色的过程其实就是HSV颜色空间的变化。这里不详述这一点了。</p><h3 id="交互感"><a href="#交互感" class="headerlink" title="交互感"></a>交互感</h3><p>以下是一些良好交互的例子：</p><ul><li>每个按钮在用户点击后都有反馈，例如颜色的变化或者是出现波纹</li><li>每个页面进出时或者是tab切换时都有动画</li><li>列表下拉上拉时出现弹性的动作</li></ul><p>这些良好的交互都是需要前端去实现的。<br>目前用户已经养成了一些移动端APP的使用习惯，比如用户会认为一个列表下拉的时候数据会重新刷新，上拉到底的时候数据会加载更多，一个按钮点击的时候会产生背景颜色的变化等等。所以需要将交互的模式和动画利用UI、UE积累的设计资源沉淀到组件中。假设这些交互动画都可以流畅的实现，并且形成一套移动端的组件库，那么使用这套组件库开发的一个应用就可以有比较优秀的用户体验。比如说RN官方提供的<a href="https://reactnative.cn/docs/0.51/touchablenativefeedback.html#content" target="_blank" rel="noopener">TouchableNativeFeedback组件</a>，就实现了可以实现涟漪状的波纹。<br>另一个问题就是交互动画的流畅度能不能和原生应用媲美呢。由于手机的性能瓶颈，目前在移动端的动画仍然需要去进行优化保证动画的流畅度，就动画方面是有一些手段可以提升流畅度的：</p><ol><li>动画尽可能使用transform，而非直接操作dom</li><li>必要情况下使用will-change或者transform3D()去让Webview调用GPU做渲染</li><li>如果有dom操作考虑回流和重绘的优化。<a href="http://xgfe.github.io/2018/04/15/zhangjianfeng/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">可参考</a></li><li>防抖和节流，优化一些频繁操作</li></ol><p>RN实现动画的话，则可以通过Animated库实现流畅又好看的动效。<a href="https://reactnative.cn/docs/0.51/animations.html" target="_blank" rel="noopener">RN动画参考</a></p><h3 id="手势操作"><a href="#手势操作" class="headerlink" title="手势操作"></a>手势操作</h3><p>多点触控可以组成一系列的手势操作，这个是智能手机的体验优势，原生的APP可以很好的支持手势事件，做出流畅的交互体验。JS也可以通过touch库去监听到手势，并作出交互；另外在RN上对手势则有天然的支持。<a href="https://reactnative.cn/docs/0.51/gesture-responder-system.html#content" target="_blank" rel="noopener">参考链接</a></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>下图是一个react的Hybrid项目在webview中渲染出来的过程<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1frt5z11h1kj20ta088q37.jpg" alt=""></p><p>基于这个过程有以下一些加速方案，主要分为两类，网络类和渲染类。<br>首先是网络类</p><ul><li>在兼顾APP包大小的前提下，将一部分资源放入离线包。</li><li>采用HTTP缓存，减少资源的重复请求。</li><li>拆分快慢接口，首屏展示时尽可能不要先请求慢接口。</li><li>升级到HTTP2，多路复用。</li><li>DNS寻址优化。</li><li>本地数据缓存，先使用本地数据渲染页面，然后等线上数据更新下来后再更新视图。</li><li>缓存的差分更新。</li><li>减少cookie的传输。</li></ul><p>附上一个<a href="https://zhuanlan.zhihu.com/p/24202408" target="_blank" rel="noopener">美团大众点评Hybrid</a>资源预加载的方案<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1fv7wzeaxgfj20k00d6aar.jpg" alt=""></p><p>渲染类</p><ul><li>在页面拿到基础的dom结构后，优先用占位符的方式，尽快缩减页面渲染的体感时长。</li><li>MVVM框架中减少不必要的的DOM更新。</li><li>首屏渲染的直出。</li><li>尽可能减少Webview中的JS代码，让Webview专一的处理渲染工作，业务和框架JS放入JSCore中，Webview和JSCore通过桥通信更新DOM<br>节点。</li></ul><h4 id="Webview与jsCore"><a href="#Webview与jsCore" class="headerlink" title="Webview与jsCore"></a>Webview与jsCore</h4><p>微信小程序就是二者分离的典型实践。微信小程序直接进行平时前端的DOM操作是不支持的，原因就是脚本的运行环境是JSCore并不支持DOM和BOM对象。微信小程序对MVVM模式在Hybrid上给出的最佳实践就是：业务脚本，虚拟DOM的diff交给JSCore，让Webview可以专心致志的去完成DOM的渲染，事件监听，DOM的更新工作。<br>Hybrid一个桥连接Webview和native的实践很常见，如果像微信一样用到Webview和JSCore的话需要两个桥。<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1frtbophcnfj20g503xmx5.jpg" alt=""><br>JSBridge实际上可以算作是一个<a href="https://segmentfault.com/a/1190000014206309" target="_blank" rel="noopener">EventEmitter</a>的变形。<br>JS部分的核心接口的伪代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册函数，用于被native调用</span></span><br><span class="line"><span class="keyword">const</span> addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(fn)) <span class="keyword">return</span>;<span class="comment">//判断是否在监听中添加的是合法的函数</span></span><br><span class="line">    <span class="comment">//判断type是否添加过，添加过一个还是多个函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.event[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray(<span class="keyword">this</span>.event[type]))&#123;</span><br><span class="line">            <span class="comment">//如果想要实现preadd将push改为unshift即可</span></span><br><span class="line">            <span class="keyword">this</span>.event[type].push(fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果想要实现preadd改变顺序</span></span><br><span class="line">            <span class="keyword">this</span>.event[type] = [<span class="keyword">this</span>.event[type], fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.event[type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是向native发送消息的postMessage函数，核心的信息是option</p><ul><li>name: 对应了在addListener中的type</li><li>data: 给native中传递的数据</li><li>callback: 回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//postMessage是用于调用native</span></span><br><span class="line"><span class="keyword">const</span> nativeBridge = getBridge();<span class="comment">//根据平台获取bridge</span></span><br><span class="line"><span class="keyword">const</span> postMessage = <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = createID(option.name);<span class="comment">//生成唯一id</span></span><br><span class="line">    addListener(id, option.callBack);</span><br><span class="line">    nativeBridge.post(&#123;</span><br><span class="line">        name: option.name,</span><br><span class="line">        data: option.data,</span><br><span class="line">        cbId: id</span><br><span class="line">    &#125;);<span class="comment">//通知native</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> receiveMessage = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">this</span>.event[option.cbId];</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(handle.call(<span class="literal">null</span>, option.message)).then(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        postMessage(&#123;</span><br><span class="line">            name: option.name,</span><br><span class="line">            data: args</span><br><span class="line">        &#125;);<span class="comment">//执行native的回调</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用两个桥在JSCore中可以在执行业务逻辑代码，及虚拟dom diff后将需要进行dom修改结果通过告知native<br>option可以如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'domUpdate'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        pageId: <span class="string">'xxx'</span>,</span><br><span class="line">        componentId: <span class="string">'xxx'</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            type: <span class="string">'text'</span>,</span><br><span class="line">            content: <span class="string">'换了换了'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            type: <span class="string">'span'</span>,</span><br><span class="line">            children: [&#123;</span><br><span class="line">                type: <span class="string">'text'</span>,</span><br><span class="line">                content: <span class="string">'我也换了'</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;],</span><br><span class="line">        type:</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'updateDown'</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native发现是domUpdate后通知webview的DomUpdate，根据page，component及data进行DOM的更新</p><p>以上就是利用JSCore进行渲染加速的一点思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在做Hybrid项目和RN项目中，更多的关注性能和体验，渲染层面的优化很多需要整体方案的革新或者整个框架的支持，不过在组件层面交互的优化是性价比最高，也相对容易实现的手段。这就需要在移动端的业务开发工作中积累组件，雕琢交互体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从一个web前端的角度讲述了在移动端开发中H5,Hybrid,react-native与原生应用的差距，探讨了如何将自己的应用，尽可能在UI，交互体验，流畅度方面去接近原生应用。&lt;/p&gt;
    
    </summary>
    
      <category term="zhaojun" scheme="http://xgfe.github.io/categories/zhaojun/"/>
    
    
      <category term="React Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="前端优化实践" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="移动端" scheme="http://xgfe.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="hybrid" scheme="http://xgfe.github.io/tags/hybrid/"/>
    
  </entry>
  
  <entry>
    <title>Egg.js 体验</title>
    <link href="http://xgfe.github.io/2018/05/26/guanxiaofeng/Eggjs/"/>
    <id>http://xgfe.github.io/2018/05/26/guanxiaofeng/Eggjs/</id>
    <published>2018-05-26T07:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Egg.js 在项目中的使用以及框架的扩展。<br><a id="more"></a></p><h2 id="Egg-js-是什么"><a href="#Egg-js-是什么" class="headerlink" title="Egg.js 是什么?"></a>Egg.js 是什么?</h2><p>﻿Egg.js 是一个强约束的 Node 框架，这也是和 Express / Koa 最大的不同，后者对开发者相对宽松，主要体现在目录结构、编写方式等均可以自定义，标准的 mvc 模式有千奇百怪的写法。</p><p> Egg.js 奉行『约定优于配置』，他规定一定的约定，让开发者都按照统一的约定去开发，降低团队协作成本，减少差异，求同存异，提升项目阅读和维护性。但约定不等于扩展性差，相反 Egg.js 有很高的扩展性。</p><h3 id="特性"><a href="#特性" class="headerlink" title="﻿特性"></a>﻿特性</h3><pre><code>* 提供基于 Egg 定制上层框架的能力* 高度可扩展的插件机制* 内置多进程管理* 基于 Koa 开发，性能优异* 框架稳定，测试覆盖率高* 渐进式开发</code></pre><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>官方推荐使用脚手架快速生成项目：</p><pre><code>$ npm install egg-init -g$ egg-init egg-test --type=simple$ cd egg-test$ npm install$ npm run dev$ open localhost:7001</code></pre><p>Egg.js 给我们规定的目录结构如下图：</p><pre><code>﻿egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app|   ├── router.js│   ├── controller│   |   └── home.js│   ├── service (可选)│   |   └── user.js│   ├── middleware (可选)│   |   └── response_time.js│   ├── schedule (可选)│   |   └── my_task.js│   ├── public (可选)│   |   └── reset.css│   ├── view (可选)│   |   └── home.tpl│   └── extend (可选)│       ├── helper.js (可选)│       ├── request.js (可选)│       ├── response.js (可选)│       ├── context.js (可选)│       ├── application.js (可选)│       └── agent.js (可选)├── config|   ├── plugin.js|   ├── config.default.js│   ├── config.prod.js|   ├── config.test.js (可选)|   ├── config.local.js (可选)|   └── config.unittest.js (可选)└── test    ├── middleware    |   └── response_time.test.js    └── controller        └── home.test.js</code></pre><p>﻿其中包括 controller、router 、config 等等，然后我们需要先添加一个渲染模版；Eggjs 提供了很多 view 模版，这里选择 Egg-view-ejs 为例，安装完插件后需要在 config 里面开启插件，同时需要在 app 文件夹下新建 view 文件夹，放置页面文件。<br> 配置需要用的插件，在 config / plugin.js 中添加</p><pre><code>﻿exports.ejs = {    enable: true,    package: &apos;egg-view-ejs&apos;};// 使用 mysql 插件exports.mysql = {    enable: true,    package: &apos;egg-mysql&apos;,};</code></pre><p>开启插件，config.default.js 中增加</p><pre><code>﻿config.view = {    defaultViewEngine: &apos;ejs&apos;,    mapping: {        &apos;.html&apos;: &apos;ejs&apos;,    }，};// 设置 mysqlconfig.mysql = {    clients: {        // clientId, 获取 client 实例，需要通过 app.mysql.get(&apos;clientId&apos;) 获取        db: {            ...        }    },    // 是否加载到 app 上，默认开启    app: true,};</code></pre><p>﻿其中 defaultViewEngine 表示使用的模版，当然也可以使多种模版。mapping 设置的属性名表示 view 中文件的扩展名，属性值表示对应的模板；接下来就可以编写 controller 和 router 了。<br> 定义 controller，﻿在 controller 文件夹下的 home.js 中：</p><pre><code>﻿const Controller = require(&apos;egg&apos;).Controller;// eggjs 推荐使用类形式来定义class HomeController extends Controller {  async index() {      await this.ctx.render(&apos;site/home.html&apos;);  }}module.exports = HomeController;</code></pre><p>定义路 router，在 router.js 文件中：</p><pre><code>﻿module.exports = app =&gt; {    const { router, controller } = app;    router.get(&apos;/&apos;, controller.home.index);    router.get(&apos;/login&apos;, controller.login.index);};</code></pre><p>﻿Context 对象上提供了 3 个渲染模版的接口，返回值均为 Promise:</p><pre><code>﻿// render ：渲染模版文件，data 为传入模版的数据，并赋值给 ctx.bodyawait ctx.render(&apos;home/index.tpl&apos;, data);// renderView ：渲染模版文件，data 为传入模版的数据，需要主动赋值ctx.body = await ctx.renderView(&apos;path/to/file.tpl&apos;, data);// renderString ：渲染模版字符串，data 为传入模版的数据，需要主动赋值ctx.body = await ctx.renderString(&apos;hi, {{ name }}&apos;, data, {    // 需要指定模板引擎    viewEngine: &apos;nunjucks&apos;,});</code></pre><h2 id="内置基础对象扩展"><a href="#内置基础对象扩展" class="headerlink" title="内置基础对象扩展"></a>内置基础对象扩展</h2><p>框架包括从 Koa 继承而来的 4 个对象（ Application、Context、Request、Response )以及框架扩展的一些对象（ Controller、Service、Helper、Config、Logger ）。</p><h3 id="Application-扩展"><a href="#Application-扩展" class="headerlink" title="Application 扩展"></a>Application 扩展</h3><p>app 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建。在 Controller、Middleware、Helper、Service 中都可以通过<br>this.app 访问到 Application 对象。框架会把 app/extend/application.js 中定义的对象与 Koa Application 的 prototype 对象进行合并，在应用启动时会基于扩展后的 prototype 生成 app 对象。这样能在其他地方使用 Application 中扩展的方法。</p><pre><code>﻿// app/extend/application.jsmodule.exports = {  foo(params) {    // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性  },};</code></pre><h3 id="Context-扩展"><a href="#Context-扩展" class="headerlink" title="﻿Context 扩展"></a>﻿Context 扩展</h3><p>Context 指的是 Koa 的请求上下文，这是请求级别的对象，每次请求生成一个 Context 实例，通常我们也简写成 ctx。在所有的文档中，Context 和 ctx 都是指 Koa 的上下文对象。如下做的是对数据返回的扩展：</p><pre><code>﻿// app/extend/context.jsmodule.exports = {  returnJson(code,data,msg) {    // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性    this.body={code,data,msg};    return  }};在 controller 中就可以直接使用这个方法了async info() {    const userId = this.ctx.query.id;    const res = await this.ctx.service.getInfo(userId);    this.ctx.returnJson(0, res, &quot;请求成功&quot;);}</code></pre><h3 id="Request-和-Response-扩展"><a href="#Request-和-Response-扩展" class="headerlink" title="﻿Request 和 Response 扩展"></a>﻿Request 和 Response 扩展</h3><p> ﻿ctx 上的很多属性和方法都被代理到 request 和 response 对象上，对于这些属性和方法使用 ctx 和使用 request 去访问它们是等价的，例如 ctx.url === ctx.request.url、ctx.status === ctx.response.status 。<br> 框架会把 app/extend/request.js 中定义的对象与内置 request 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 request 对象；Response 的扩展和 Request 相同。</p><pre><code>﻿// app/extend/request.jsmodule.exports = {  get foo() {    return this.get(&apos;request-foo&apos;);  },};// app/extend/response.jsmodule.exports = {  set bar(value) {    this.set(&apos;response-bar&apos;, value);  },};</code></pre><h3 id="Helper-扩展"><a href="#Helper-扩展" class="headerlink" title="﻿Helper 扩展"></a>﻿Helper 扩展</h3><p>﻿Helper 函数用来提供一些常用的方法或自定义的方法，可以将项目中用的多的函数封装在成对的函数，并且 Helper 对象可以在 ctx 对象里面访问到。</p><pre><code>﻿// app/extend/helper.jsmodule.exports = {  foo(param) {    // this 是 helper 对象，在其中可以调用其他 helper 方法    // this.ctx =&gt; context 对象    // this.app =&gt; application 对象  },};</code></pre><h2 id="service-服务层"><a href="#service-服务层" class="headerlink" title="﻿service 服务层"></a>﻿service 服务层</h2><p>﻿service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。可以将数据逻辑的处理都放在 service 中</p><pre><code>﻿const Service = require(&apos;egg&apos;).Service;class UserService extends Service {  async find(uid) {    const user = await app.mysql.get(&apos;db&apos;).query(`select * from user where uid = ${uid}`);    return user;  }}module.exports = UserService;</code></pre><h2 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="﻿Middleware 中间件"></a>﻿Middleware 中间件</h2><p>﻿Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。约定中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数：</p><pre><code>options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。app: 当前应用 Application 的实例。</code></pre><p>﻿定义一个中间件：</p><pre><code>﻿module.exports = (options,app) =&gt; {    return async function checkLogin() {        if(!(this.session &amp;&amp; this.session.userid)){            this.redirect(&apos;/login&apos;);            return;        };        // 刷新 session 时间        this.session.save();    };}</code></pre><p>﻿在应用中，我们可以完全通过配置来加载自定义的中间件，并决定它们的顺序。配置最终将在启动时合并到 app.config.appMiddleware 中。在 config.default.js 中配置如下：</p><pre><code>﻿// 配置需要的中间件，数组顺序即为中间件的加载顺序config.middleware= [&apos;checkLogin&apos;];// 配置 checkLogin 中间件的配置config.checkLogin= {    // 设置需要忽略检查的路径    ignore: &apos;/login&apos;};</code></pre><p> ﻿利用上述定义的中间件，如下是做的一个简单的登录</p><pre><code>﻿// router.jsmodule.exports = app =&gt; {    const { router, controller } = app;    router.get(&apos;/login&apos;, controller.login.index);    router.post(&apos;/login/vaild&apos;, controller.login.valid);    // 登陆后获取用户名    router.get(&apos;/user/admin&apos;, controller.login.userinfo);    // 退出登录    router.get(&apos;/logout&apos;, controller.login.logout);}// app/controller/login.jsmodule.exports = app =&gt; {    class LoginController extends app.Controller {        async index() {                await this.ctx.render(&apos;site/login.html&apos;);        }        async valid() {            const name = this.ctx.request.body.username;            const pwd = this.ctx.request.body.password;            if (!name || !pwd) {                // 1表示没有填写                this.ctx.returnJson(1,&apos;&apos;,&quot;请填写帐号和密码。&quot;)                return;            }            const user = await app.mysql.get(&apos;db&apos;).query(`select id,username  from user WHERE username= &apos;${name}&apos; AND password =&apos;${pwd}&apos;`);            if (user.length != 0) {                // 登录成功，下发 session                this.ctx.session.username = user[0].username;                this.ctx.session.userid = user[0].id;                // 设置过期时间为3小时                this.ctx.session.maxAge = 3 * 3600 * 1000;                // 调用 rotateCsrfSecret 刷新用户的 CSRF token                this.ctx.rotateCsrfSecret();                this.ctx.returnJson(0, &apos;&apos;, &quot;登录成功&quot;);            } else {                this.ctx.returnJson(2,&apos;&apos;,&quot;帐号或密码错误&quot;);            };        }        async userinfo() {            const uid = this.ctx.query.uid;            let user = await this.ctx.service.UserService.find(uid)            this.ctx.returnJson(0,user ,&quot;操作成功&quot;);        }        async logout() {            this.ctx.session = null;            this.ctx.redirect(&apos;/login&apos;);        }    }    return LoginController;};</code></pre><p>在这里面遇到一个坑就是通过 get 请求和 post 请求时，获取参数的方式不一样。</p><pre><code>* 在 get 请求中要通过 this.ctx.query 去获取参数；在 post 请求中是通过 this.ctx.request.body 去获取参数。</code></pre><p>﻿这些只是 Eggjs 的一小部分内容，框架还有很多扩展，插件，进程管理等等，接下来会通过自己的学习慢慢总结，有不对的地方还希望各位前辈指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Egg.js 在项目中的使用以及框架的扩展。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="nodejs" scheme="http://xgfe.github.io/tags/nodejs/"/>
    
      <category term="Eggjs" scheme="http://xgfe.github.io/tags/Eggjs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 WEB 缓存</title>
    <link href="http://xgfe.github.io/2018/05/07/zhangjihu/%E6%B5%85%E8%B0%88web%E7%BC%93%E5%AD%98/"/>
    <id>http://xgfe.github.io/2018/05/07/zhangjihu/浅谈web缓存/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.264Z</updated>
    
    <content type="html"><![CDATA[<p>在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 缓存是指一个 Web 资源（如 html 页面，图片，js ，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存根据进来的请求保存输出内容的副本，当再次请求的时候，如果是相同的URL，会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器发送请求。<br>Web 缓存机制的有多种，在这里主要探讨以浏览器为载体的 HTTP 缓存机制，希望对自己和大家都有所帮助。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器缓存（ Brower Caching ）是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，浏览器缓存的优点：</p><ul><li>减少了冗余的数据传输，节省了网费</li><li>减少了服务器的负担，大大提升了网站的性能</li><li>加快了客户端加载网页的速度</li></ul><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即：浏览器发起 HTTP 请求–服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/fbbc80627083b6bbe7ecb9525a36189434504.webp" alt=""></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取。</p><h2 id="浏览器缓存类型"><a href="#浏览器缓存类型" class="headerlink" title="浏览器缓存类型"></a>浏览器缓存类型</h2><p>我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control ，<strong>其中 Cache-Control 优先级比 Expires 高</strong>。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 HTTP / 1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header ，如：</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/417893a96e4205a4c13acbc58941d25850878.png"></p><p>2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header ）；<br>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。<br>4、如果缓存没有命中，浏览器直接向服务器发送请求，Expires Header 在重新加载的时候会被更新。<br>到了 HTTP / 1.1 ，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么 Cache-Control 又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在 HTTP / 1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：可以被所有的用户缓存，包括客户端和 CDN 等中间代理服务器，默认值</li><li>private：只能被客户端缓存，不允许 CDN 等中间代理服务器对其缓存，Cache-Control 的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存，每次请求该资源直接向服务器发送请求，每次都会下载完整的资源</li><li>max-age=xxx：（单位为 s ）：缓存内容将在 xxx 秒后失效，当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了</li><li>s-maxage=xxx：（单位为 s ）：同 max-age ，只用于共享缓存（比如 CDN 缓存），覆盖掉 max-age 和 Expires</li></ul><p>接下来，我们直接看一个例子，如下：</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header ；<br>2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；<br>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/2f10fb6c2edd15f829d36330bee33b6b57447.png" alt=""></p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p><p>由上面的例子我们可以知道：</p><ul><li>HTTP 响应报文中 expires 的时间值，是一个绝对时间的GMT格式的时间字符串</li><li>HTTP 响应报文中 Cache-Control 为 max-age = 7200 ，是相对值，代表着资源的有效期</li></ul><p>由于 Cache-Control 的优先级比 expires ，那么直接根据 Cache-Control 的值进行缓存，意思就是说在 7200 秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。<br>注：在无法确定客户端的时间是否与服务端的时间同步的情况下， Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，就会携带缓存标识向服务器发起请求，验证协商缓存是否命中，由服务器根据缓存标识决定是否使用缓存，如果协商缓存命中，请求响应返回的 http 状态为 304 。</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/165599b6e70d5fcc1258be192f6db41b36954.png" alt=""></p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/0416603a7ed8b6c6d8af6f548a6c570c26337.png" alt=""></p><p>查看单个请求的 ResponseHeader，也能看到 304 的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源。</p><h4 id="主要有以下两种情况："><a href="#主要有以下两种情况：" class="headerlink" title="主要有以下两种情况："></a>主要有以下两种情况：</h4><p>协商缓存生效，返回 304 ，如下:</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/cac3ffaa672010fee74692465e9c17f021484.webp" alt=""></p><blockquote><p>304</p></blockquote><p>协商缓存失效，返回 200 和请求结果结果，如下:</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/76908dc6fb49340ad92d97ff2ed759ba22094.riff" alt=""></p><blockquote><p>200</p></blockquote><p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match ，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。</p><h5 id="【-Last-Modified，If-Modified-Since-】"><a href="#【-Last-Modified，If-Modified-Since-】" class="headerlink" title="【 Last-Modified，If-Modified-Since 】:"></a>【 Last-Modified，If-Modified-Since 】:</h5><p>Last-Modified 是该资源文件最后一次更改时间，服务器会在 response header 里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到 request header 里的 If-Modified-Since 里，服务器在接收到后也会做比对，如果相同则命中协商缓存，具体情况如下：</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</p><p><img src="http://vfile.meituan.net/xgfe/d5788526358fd1f02278de827d0cc8f481865.png" alt=""></p><p>2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</p><p><img src="http://vfile.meituan.net/xgfe/b150d289f5ec7c2921d175d4aad1dd8a81884.png" alt=""></p><p>3、服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容，状态码为 200。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header 。<br>4、浏览器收到 304 的响应后，就会从缓存中加载资源。<br>5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p><h5 id="【-ETag-、If-None-Match-】"><a href="#【-ETag-、If-None-Match-】" class="headerlink" title="【 ETag 、If-None-Match 】:"></a>【 ETag 、If-None-Match 】:</h5><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header ，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</p><p><img src="http://vfile.meituan.net/xgfe/f8e13201a0acfa1c34a07f978ab8eb1560458.png" alt=""></p><p>2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header ，这个 header 的值就是上一次请求时返回的 ETag 的值：</p><p><img src="http://vfile.meituan.net/xgfe/b3ee027ffc12d12ee34cfdeaebff931f103431.png" alt=""></p><p>3、服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag ，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified ，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：<br>4、浏览器收到 304 的响应后，就会从缓存中加载资源。</p><h5 id="为什么要有-Etag"><a href="#为什么要有-Etag" class="headerlink" title="为什么要有 Etag"></a>为什么要有 Etag</h5><p>你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？ HTTP 1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：<br>    • 一些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET ；<br>    • 某些文件修改非常频繁，比如在秒以下的时间内进行修改，（比方说 1 s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）；<br>    • 某些服务器不能精确的得到文件的最后修改时间。<br>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag ，一致的情况下，才会继续比对 Last-Modified ，最后才决定是否返回 304 。</p><h3 id="强缓存与协商缓存的区别"><a href="#强缓存与协商缓存的区别" class="headerlink" title="强缓存与协商缓存的区别"></a>强缓存与协商缓存的区别</h3><p>强缓存与协商缓存的区别可以用下表来表示：</p><p><img src="http://vfile.meituan.net/xgfe/f0eb26fac54900ef2272f4c3e3e233ef20064.png" alt=""></p><p>强制缓存优先于协商缓存进行，若强制缓存（ Expires 和 Cache-Control ）生效则直接使用缓存，若不生效则进行协商缓存（ Last-Modified / If-Modified-Since 和 Etag / If-None-Match ），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304 ，继续使用缓存。</p><h3 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h3><p>1、浏览器第一次加载资源，服务器返回 200，浏览器将资源文件从服务器上请求下载下来，并把 response header 及该请求的返回时间一并缓存；<br>2、下一次加载资源时，先比较当前时间和上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age ，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持 HTTP 1.1 ，则用 expires 判断是否过期）；如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求；<br>3、服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304 ；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200 ；<br>4、如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304 ；不一致则返回新的 last-modified 和文件并返回 200 ；</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/735836ddebf6bf03fb577902c88afd6925020.webp" alt=""></p><h3 id="用户行为对缓存的影响"><a href="#用户行为对缓存的影响" class="headerlink" title="用户行为对缓存的影响"></a>用户行为对缓存的影响</h3><p>地址栏访问，点击链接跳转是正常用户行为，将会触发浏览器缓存机制，浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容；<br>F5 刷新，浏览器会设置 max-age = 0，跳过强缓存判断，会进行协商缓存判断；<br>ctrl + F5 刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</p><p><img src="http://vfile.meituan.net/xgfe/72ef16289230d836b2027eb7f6a6845c27545.png" alt=""></p><h3 id="已经缓存的响应，如何更新或废弃？"><a href="#已经缓存的响应，如何更新或废弃？" class="headerlink" title="已经缓存的响应，如何更新或废弃？"></a>已经缓存的响应，如何更新或废弃？</h3><p>一般情况下，浏览器发出的所有 HTTP 请求会首先被路由到浏览器的缓存，以查看是否缓存了可以用于实现请求的有效响应。如果有匹配的响应，会直接从缓存中读取响应，这样就避免了网络延迟以及传输产生的数据成本。然而，如果我们希望更新或废弃已缓存的响应，该怎么办？<br>假设我们已经告诉访问者某个 CSS 样式表缓存长达 24 小时（ max-age = 86400 ），但是设计人员刚刚提交了一个更新，我们希望所有用户都能使用。我们该如何通知所有访问者缓存的 CSS 副本已过时，需要更新缓存？<br>实际上以前没有请求过该资源的新的用户会得到更新的资源，但是请求过资源的用户将在过期时间达到之前一直得到旧的被缓存的资源，直到他手动的去清理了浏览器的缓存。手动清理浏览器缓存这种事可能只有程序员才会做，那么我们要怎么做才能让用户得到更新后的资源呢？<br>其实很简单，我们可以在资源的内容更改后，更改资源的网址，强制用户下载新响应。比如在资源链接后添加参数：</p><p><img src="http://vfile.meituan.net/xgfe/29b12a26033d0eccff1a6d503ae8f9f674695.png" alt=""></p><p>（有兴趣的可以阅读：<a href="https://www.zhihu.com/question/20790576）" target="_blank" rel="noopener">https://www.zhihu.com/question/20790576）</a></p><h2 id="web-缓存作用"><a href="#web-缓存作用" class="headerlink" title="web 缓存作用"></a>web 缓存作用</h2><p>1、减少网络带宽消耗<br>无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当 Web 缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。</p><p>2、降低服务器压力<br>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p><p>3、减少网络延迟，加快页面打开速度<br>缓存的使用能够明显加快页面打开速度，提高网页性能，达到更好的体验。</p><h2 id="其它-web-缓存机制"><a href="#其它-web-缓存机制" class="headerlink" title="其它 web 缓存机制"></a>其它 web 缓存机制</h2><p>1、数据库缓存<br>我们可能听说过 memcached ，它就是一种数据库层面的缓存方案。数据库缓存是指，当 web 应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。</p><p>2、CDN 缓存<br>CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向 CDN 网关发起 Web 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个 CDN 就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><p>3、代理服务器缓存<br>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起 Web 请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。</p><p>4、应用层缓存<br>应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前端开发中，浏览器缓存是 web 性能优化的重要方面，是提升 web 性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题。所以对于缓存的应用需要综合考虑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="zhangjihu" scheme="http://xgfe.github.io/categories/zhangjihu/"/>
    
    
      <category term="缓存" scheme="http://xgfe.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="web 缓存" scheme="http://xgfe.github.io/tags/web-%E7%BC%93%E5%AD%98/"/>
    
      <category term="浏览器缓存" scheme="http://xgfe.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redux,react-redux简单实现</title>
    <link href="http://xgfe.github.io/2018/05/01/wangpan/redux,react-redux%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2018/05/01/wangpan/redux,react-redux简单实现/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redux解决了react只专注view层却没有涉及到的 代码结构 和组件通信的关键问题，本文主要目的是实现一个简单的redux和react-redux并且实现其middleware中间件机制。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在react项目中，如果你的UI层非常简单，没有很多的互动，那么redux是没有必要的。<br>redux是一个有用状态架构，所有的状态保存在一个对象中，对于大型的复杂应用， 代码结构和组件通信是极为关键的，而redux就是解决这两方面的问题。</p><h3 id="一、redux使用场景"><a href="#一、redux使用场景" class="headerlink" title="一、redux使用场景"></a>一、redux使用场景</h3><p><strong>适用redux的场景</strong>：</p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p><strong>从组件角度看</strong>:</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><h3 id="二、redux常用API"><a href="#二、redux常用API" class="headerlink" title="二、redux常用API"></a>二、redux常用API</h3><ul><li>createStore<store>()    创建stroe 返回store对象</store></li><li>store.getState<state>() 返回state</state></li><li>store.subscribe()       订阅store</li><li>store.dispatch()        提交状态变更的申请</li></ul><h3 id="三、redux简单实现"><a href="#三、redux简单实现" class="headerlink" title="三、redux简单实现"></a>三、redux简单实现</h3><p>整体架构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscirbe</span>(<span class="params">listener</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 初始执行一次，获得初始化状态</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@first_init@wangpan'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState, subscribe, dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span> (<span class="params">creator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(creator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> bindAcitonCreators(creators, dispatch) &#123;</span><br><span class="line">    <span class="keyword">let</span> bound = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(creators).forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> creator = creators[v]</span><br><span class="line">        bound[v] = bindActionCreator(creator, dispatch)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>subcribe函数，传入监听函数，注意对参数校验，因为只是简单实现，我这就不写啦<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subscribe订阅函数 传入listener函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span> (<span class="params">listenr</span>) </span>&#123;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dispatch函数，传入action,同样可以对参数进行校验<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    currentState = reducer(currentState, aciton)</span><br><span class="line">    <span class="comment">// state改变，执行订阅函数，这就是一个最基本的发布者订阅者模式</span></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v())</span><br><span class="line">    <span class="keyword">return</span> aciton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上一个最简单的redux就是实现了，现在暂且不实现redux中间件，下面我们看看react-redux实现</p><h3 id="四、react-redux简单实现"><a href="#四、react-redux简单实现" class="headerlink" title="四、react-redux简单实现"></a>四、react-redux简单实现</h3><p>在实现react-redux之前，先来看看react的context,这是实现react-redux的关键<br>在react父子组件通信是非常简单的，通过props就可以实现，但是在多层级的场景下通信通过props一层一层传递是非常麻烦而且不友好的,所以react提供context实现组件的跨多层级通信。</p><p>react-redux基本架构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Proptypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindAcitonCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 负责链接组件，将redux中的数据放入组件</span></span><br><span class="line"><span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect(mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> state, mapDispatchToProps = &#123;&#125;) =&gt;<span class="function">(<span class="params">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">            store: PropTpes.object</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">constructor</span> (props, context) &#123;</span><br><span class="line">            <span class="keyword">super</span>(props)</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                props: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">this</span>.update()</span><br><span class="line">            <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">            store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">            <span class="keyword">this</span>.update()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update () &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">            <span class="keyword">const</span> stateProps = mapStateToProps(store.getState())</span><br><span class="line">            <span class="keyword">const</span> dispatchProps = bindAcitonCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                props: &#123;</span><br><span class="line">                    ...this.state.props</span><br><span class="line">                    ...stateProps</span><br><span class="line">                    ...dispatchProps</span><br><span class="line">                    ...this.props</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// Provider组件，把strore放入context中，所有子元素可以直接去到store</span></span><br><span class="line"><span class="xml">export class Provider extends React.Component &#123;</span></span><br><span class="line"><span class="xml">    static childContextTypes = &#123;</span></span><br><span class="line"><span class="xml">        store: Proptypes.object</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    getchildContext () &#123;</span></span><br><span class="line"><span class="xml">        return &#123;</span></span><br><span class="line"><span class="xml">            store: this.store</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    constructor (props, context) &#123;</span></span><br><span class="line"><span class="xml">        super(props, context)</span></span><br><span class="line"><span class="xml">        this.store = props.store</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    render () &#123;</span></span><br><span class="line"><span class="xml">        return Children.only(this.props.children)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="五、中间件机制"><a href="#五、中间件机制" class="headerlink" title="五、中间件机制"></a>五、中间件机制</h3><p>在之前的redux基础上添加applyMiddleware函数，并且扩展crateStore函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果中间件存在</span></span><br><span class="line">    <span class="keyword">if</span> (enhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">        <span class="keyword">const</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> midApi = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch = middleware(midApi)(store, dispatch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="六、redux-thunk简单实现"><a href="#六、redux-thunk简单实现" class="headerlink" title="六、redux-thunk简单实现"></a>六、redux-thunk简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> action(dispatch, getState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure><p>以上就基本实现了一个最简单的redux和react-redux</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;redux解决了react只专注view层却没有涉及到的 代码结构 和组件通信的关键问题，本文主要目的是实现一个简单的redux和react-redux并且实现其middleware中间件机制。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpan" scheme="http://xgfe.github.io/categories/wangpan/"/>
    
    
      <category term="react" scheme="http://xgfe.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://xgfe.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>动画库 Lottie 的使用</title>
    <link href="http://xgfe.github.io/2018/04/26/wangpeng/lottie_android/"/>
    <id>http://xgfe.github.io/2018/04/26/wangpeng/lottie_android/</id>
    <published>2018-04-26T08:26:00.000Z</published>
    <updated>2018-08-24T03:48:57.259Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍动画开源库 Lottie 在 Android 中的使用。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常APP开发中，为了提升用户感官舒适度等原因，我们会在APP中加入适量动画。<br>而传统手写动画方式往往存在诸多问题:</p><ul><li><p><strong>动画复杂而实现困难</strong></p></li><li><p><strong>图片素材占用体积过大</strong></p></li><li><p><strong>不同Native平台都需各自实现，开发成本高</strong></p></li><li><p><strong>不同Native平台实现的最终效果不一致</strong></p></li><li><p><strong>后期视觉联调差异化大</strong></p></li></ul><p><img src="http://p0.meituan.com/tuanpic/lottie_android_headache.jpeg" alt="">  </p><p><em>难道就没有一种简便且高效的方案来减缓或解决上述问题吗？</em></p><p>答: 有的，那就是本文要介绍的主角 <strong>Lottie</strong>。</p><h2 id="一、Lottie-是什么？"><a href="#一、Lottie-是什么？" class="headerlink" title="一、Lottie 是什么？"></a>一、Lottie 是什么？</h2><blockquote><p>Lottie是Airbnb开源的一个面向IOS、Android、React Native的动画库，可以解析用 Adobe After Effects 制作动画后通过 Bodymovin 插件导出的 Json 数据文件并在移动端原生渲染。</p></blockquote><p>通俗点说，它是一款动画开源库，通过解析特定的Json文件或Json文本，可直接在移动端上渲染出复杂的动画效果。</p><p><img src="http://p0.meituan.com/tuanpic/lottie_android_flow.png" alt="参考图释"></p><h2 id="二、Lottie-能干什么"><a href="#二、Lottie-能干什么" class="headerlink" title="二、Lottie 能干什么?"></a>二、Lottie 能干什么?</h2><p><strong>它可以简便高效的实现复杂动画，替代传统低效的手写动画方式。</strong> </p><p>动画展示:</p><p><img src="http://p0.meituan.com/tuanpic/lottie_android_example_4.gif" alt=""></p><p>上方的动画是通过Lottie直接实现的。</p><p>如果我们使用手写代码方式实现，可以说是很难！  </p><p>而通过 Lottie 实现时，需要的仅是一个Json文件或一段Json文本，并通过简洁的代码集成即可。</p><p>集成代码可能精简到如下模样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_rawRes</span>=<span class="string">"@raw/anim_lottie"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_loop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_autoPlay</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、为什么使用-Lottie"><a href="#三、为什么使用-Lottie" class="headerlink" title="三、为什么使用 Lottie?"></a>三、为什么使用 Lottie?</h2><ul><li><p><strong>简便，开发成本低</strong><br>相对于传统方式，动画不再是全部手写，所需做得只是嵌入XML并配置动画属性，集成快，开发时间少，开发成本低。    </p></li><li><p><strong>不同 Native 平台效果基本一致</strong><br>渲染交由Lottie引擎内部实现，无需开发者处理平台差异，多平台共用同一个动画配置文件，效果一致性高。    </p></li><li><p><strong>占用包体积小</strong><br>Lottie配置文件由Json文本串构成，相对于图片，占用体积更小。</p></li><li><p><strong>动画效果不失真</strong><br>传统图片拉伸或压缩导致失真，而Lottie为矢量图展示，不会出现失真情况。</p></li><li><p><strong>动画效果可以云端控制</strong><br>由于Lottie动画基于Json文件或文本解析，因此可以实现云端下发，实现动态加载，动态控制动画样式。</p></li></ul><h2 id="四、如何使用-Lottie？"><a href="#四、如何使用-Lottie？" class="headerlink" title="四、如何使用 Lottie？"></a>四、如何使用 Lottie？</h2><p>Lottie 仅支持用 Gradle 构建配置，最低支持安卓版本 16。     </p><h3 id="1-添加依赖到-build-gradle"><a href="#1-添加依赖到-build-gradle" class="headerlink" title="1. 添加依赖到 build.gradle"></a>1. 添加依赖到 build.gradle</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.airbnb.android:lottie:2.5.4'</span></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">"com.airbnb.android:lottie:$&#123;全局版本变量&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-添加-Adobe-After-Effects-导出的动画-Json-文件"><a href="#2-添加-Adobe-After-Effects-导出的动画-Json-文件" class="headerlink" title="2. 添加 Adobe After Effects 导出的动画 Json 文件"></a>2. 添加 Adobe After Effects 导出的动画 Json 文件</h3><p>通常由视觉工程师确认动效后通过AE导出, 我们只需将该Json文件保存至 /raw 或 /assets文件夹下。  </p><h3 id="3-XML中嵌入基本布局"><a href="#3-XML中嵌入基本布局" class="headerlink" title="3. XML中嵌入基本布局"></a>3. XML中嵌入基本布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-加载播放动画，两类方式可选"><a href="#4-加载播放动画，两类方式可选" class="headerlink" title="4. 加载播放动画，两类方式可选"></a>4. 加载播放动画，两类方式可选</h3><h4 id="①-XML中静态配置-举例"><a href="#①-XML中静态配置-举例" class="headerlink" title="① XML中静态配置, 举例:"></a>① XML中静态配置, 举例:</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">       </span></span><br><span class="line"><span class="tag">    //加载方式如下<span class="attr">2</span>种任选其一</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_rawRes</span>=<span class="string">"@raw/hello_world"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_fileName</span>=<span class="string">"hello_world.json"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //循环播放</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_loop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    //加载完毕后自动播放</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_autoPlay</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②-代码动态配置-举例"><a href="#②-代码动态配置-举例" class="headerlink" title="② 代码动态配置, 举例:"></a>② 代码动态配置, 举例:</h4><p><em>如下代码会在后台异步加载动画文件，并在加载完成后开始渲染动画。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LottieAnimationView animationView = ...;</span><br><span class="line">animationView.setAnimation(R.raw.hello_world);</span><br><span class="line">animationView.loop(<span class="keyword">true</span>);</span><br><span class="line">animationView.playAnimation();</span><br></pre></td></tr></table></figure><h2 id="五、其他拓展使用"><a href="#五、其他拓展使用" class="headerlink" title="五、其他拓展使用"></a>五、其他拓展使用</h2><h3 id="1-直接解析Json文本串加载动画"><a href="#1-直接解析Json文本串加载动画" class="headerlink" title="1. 直接解析Json文本串加载动画"></a>1. 直接解析Json文本串加载动画</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JsonReader jsonReader = <span class="keyword">new</span> JsonReader(<span class="keyword">new</span> StringReader(jsonStr));</span><br><span class="line">lottieView.setAnimation(jsonReader);</span><br><span class="line">lottieView.playAnimation();</span><br><span class="line">或</span><br><span class="line">Cancellable cancellable = LottieComposition.Factory.fromJsonString(jsonStr, composition -&gt; &#123;</span><br><span class="line">            lottieView.setComposition(composition);</span><br><span class="line">            lottieView.playAnimation();</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//必要时取消进行中的异步操作</span></span><br><span class="line">cancellable.cancel();</span><br></pre></td></tr></table></figure><h3 id="2-配合网络下载，实现下载Json配置并动态加载"><a href="#2-配合网络下载，实现下载Json配置并动态加载" class="headerlink" title="2. 配合网络下载，实现下载Json配置并动态加载"></a>2. 配合网络下载，实现下载Json配置并动态加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;ResponseBody&gt; call = RetrofitComponent.fetchLottieConfig();<span class="comment">//伪代码</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//String json = response.body().string();</span></span><br><span class="line">                <span class="comment">//交由Lottie处理...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//do something.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-动画加载监听器"><a href="#3-动画加载监听器" class="headerlink" title="3. 动画加载监听器"></a>3. 动画加载监听器</h3><p>根据业务需要进行动画过程监听:    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">animationView.addAnimatorUpdateListener((animation) -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something.</span></span><br><span class="line">&#125;);</span><br><span class="line">animationView.playAnimation();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (animationView.isAnimating()) &#123;</span><br><span class="line"><span class="comment">// do something.</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">animationView.setProgress(<span class="number">0.5f</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-LottieDrawable-的使用"><a href="#4-LottieDrawable-的使用" class="headerlink" title="4. LottieDrawable 的使用"></a>4. LottieDrawable 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LottieDrawable drawable = <span class="keyword">new</span> LottieDrawable();</span><br><span class="line">LottieComposition.Factory.fromAssetFileName(getApplicationContext(), <span class="string">"lottie_pin_jump.json"</span>, composition -&gt; &#123;</span><br><span class="line">            drawable.setComposition(composition);</span><br><span class="line">            <span class="comment">//目前显示为静态图</span></span><br><span class="line">            ivLottie.setImageDrawable(drawable);</span><br><span class="line">            <span class="comment">//调用start()开始播放动画</span></span><br><span class="line">            drawable.start();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="5-更多使用可参考文末官方链接"><a href="#5-更多使用可参考文末官方链接" class="headerlink" title="5. 更多使用可参考文末官方链接"></a>5. 更多使用可参考文末官方链接</h3><h2 id="六、需要考虑的问题"><a href="#六、需要考虑的问题" class="headerlink" title="六、需要考虑的问题"></a>六、需要考虑的问题</h2><ol><li>由于是依赖于AE做的动画，估计以后不只是要求视觉设计师精通AE，连前端开发都需要了解AE  </li><li>Lottie 对 Json 文件的支持待完善，目前存在部分AE导出成 Json 文件无法渲染或渲染不佳</li><li>支持的功能存在限制，可参考 <a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">功能支持列表</a>。</li></ol><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>尽管Lottie还存在诸多小问题，但它所带来的效率提升绝对是传统开发方式无法比拟的。我们要做的是正确善用它。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">官网网址</a><br><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Github地址</a><br><a href="https://github.com/airbnb/lottie-android/tree/master/LottieSample/src/main/assets" target="_blank" rel="noopener">测试用Json文件</a><br><a href="https://github.com/bigxixi/lottie-android" target="_blank" rel="noopener">项目中文翻译版 (略有差异)</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍动画开源库 Lottie 在 Android 中的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="w.p" scheme="http://xgfe.github.io/categories/w-p/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="animation" scheme="http://xgfe.github.io/tags/animation/"/>
    
      <category term="lottie" scheme="http://xgfe.github.io/tags/lottie/"/>
    
  </entry>
  
  <entry>
    <title>实现React国际化</title>
    <link href="http://xgfe.github.io/2018/04/26/jiangxiang/internationalize-your-react-project/"/>
    <id>http://xgfe.github.io/2018/04/26/jiangxiang/internationalize-your-react-project/</id>
    <published>2018-04-26T07:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.242Z</updated>
    
    <content type="html"><![CDATA[<p> React 最早由 Facebook 的软件工程师 Jordan Walke 创建，它在 2011 年首次部署在 Facebook 的新闻源中，由于其性能优势明显，很快获得了广泛关注和大规模的使用，如今发展已经非常成熟。<br>基于 React 的渲染原理可以实现很多有意思的功能，例如实现一个 React 的国际化工具。(React v16.3)</p><a id="more"></a><h2 id="一、现状"><a href="#一、现状" class="headerlink" title="一、现状"></a>一、现状</h2><h3 id="1-1-目前-React-国际化常用的解决方案："><a href="#1-1-目前-React-国际化常用的解决方案：" class="headerlink" title="1.1 目前 React 国际化常用的解决方案："></a>1.1 目前 React 国际化常用的解决方案：</h3><ol><li>打包时翻译</li><li>动态翻译</li><li>生成多个版本</li></ol><p>比较流行的为 webpack 团队基于打包时翻译的 webpack-i18n-plugin 和 yahoo 团队基于动态翻译的 React-intl</p><h3 id="1-2-对比"><a href="#1-2-对比" class="headerlink" title="1.2 对比"></a>1.2 对比</h3><ol><li>打包时翻译<br>优点：方案比较成熟，已有成功案例（如很多资讯网站、博客，如 mdn ）<br>缺点：翻译表一旦更新，需要重新打包发布，本地要维护大量的翻译表文件，过于繁琐</li><li>动态翻译<br>优点：灵活，翻译表放进 cdn 一句 sql 可以更新，可操作性强<br>缺点：兼容性有待考察，对于不同的项目结构要设置特有的配置</li><li>多版本<br>优点：产生的打包文件最小，无需配置<br>缺点：修改过程复杂，应用场景不广泛</li></ol><h2 id="二、大概的设想"><a href="#二、大概的设想" class="headerlink" title="二、大概的设想"></a>二、大概的设想</h2><h3 id="3-1-翻译语法"><a href="#3-1-翻译语法" class="headerlink" title="3.1 翻译语法"></a>3.1 翻译语法</h3><p>语法分为批量翻译或指定单句不翻译<br>具体通过<code>&lt;Provider/&gt;</code>类以及属性 no-translate 实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 批量翻译</span><br><span class="line">&lt;Provider value=&#123;&#123;</span><br><span class="line">    languageMap, // 语言包</span><br><span class="line">    language, // 语言类型</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">    ... (要翻译的代码块)</span><br><span class="line">&lt;/Provider&gt;</span><br><span class="line">// 指定不翻译</span><br><span class="line">&lt;div no-translate&gt;...(不翻译的字符串)&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-方便获取在线的语言包"><a href="#3-2-方便获取在线的语言包" class="headerlink" title="3.2 方便获取在线的语言包"></a>3.2 方便获取在线的语言包</h3><p>可以通过请求获得在线语言包，在下载完成后进行更新</p><h2 id="三、核心思路"><a href="#三、核心思路" class="headerlink" title="三、核心思路"></a>三、核心思路</h2><p>实现多语言通俗来说就是：</p><ol><li>先找到要翻译的文字</li><li>请求在线语言包</li><li>再对要翻译的文字进行翻译</li></ol><p>基于以上基本思路再思考，我们都知道， JSX 是 react 的语法糖，而使用高阶函数<code>React.createElement</code>可以重新定义组件的渲染，我们只需要将要翻译的文字在该方法中处理即可。</p><p>以下两种写法经 babel 转义，本质上没有区别！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return React.createElement(&apos;div&apos;, null, `Hello $&#123;this.props.toWhat&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Hello, &#123;toWhat: &apos;World&apos;&#125;, null),</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>基于这个想法，通过设置 no-translate 属性，<code>&lt;Provider/&gt;</code>，并在<code>createElement</code>中判断，就知道哪里的文字需要翻译，也知道要翻译成哪种语言了（第一步）！</li><li>(第二步比较简单，暂时忽略…)</li><li>再定义一个<code>translate</code>函数，接受文字，语言包和翻译表，返回翻译后的文字（第三步）</li></ul><p>下面的流程图展示了整体的思路：</p><p><img src="http://vfile.meituan.net/xgfe/2f1f2dac01553645441f63da880b712937156.png" alt=""></p><h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><p>毕竟是要做一个工具库，首先新建一个工程，在 core 文件目录下创建具体文件</p><h3 id="4-1-定义一个-languageMap"><a href="#4-1-定义一个-languageMap" class="headerlink" title="4.1 定义一个 languageMap"></a>4.1 定义一个 languageMap</h3><p> languageMap 一定得是单例模式，方便全局调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/languageMap.js</span><br><span class="line">const translateMap = &#123;&#125;;</span><br><span class="line">export default translateMap;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-再写一个translate函数"><a href="#4-2-再写一个translate函数" class="headerlink" title="4.2 再写一个translate函数"></a>4.2 再写一个translate函数</h3><p>任何需要翻译的地方，都将会使用这个<code>translate</code>函数，它接受三个参数：</p><ul><li>content：要翻译的文字</li><li>languageMap：语言包</li><li>language：语言类型</li></ul><p>设置 middleware 作为中间件，可以操作翻译前后的字段，可以解决一些兼容性问题，或者实现一些彩蛋的效果…</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/translate.js</span><br><span class="line">const middleware = &#123;</span><br><span class="line">  merge: function(obj) &#123;</span><br><span class="line">    Object.keys(obj).forEach(function(key) &#123;</span><br><span class="line">      if (key !== &quot;merge&quot;) &#123;</span><br><span class="line">        middleware[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const translate = (content, languageMap, language) =&gt; &#123;</span><br><span class="line">  if (!content) &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!language) &#123;</span><br><span class="line">    throw new Error(&quot;you should define specific language type!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // beforeRender middleware</span><br><span class="line">  if (middleware.beforeRender) content = middleware.beforeRender(content);</span><br><span class="line">  // translate words</span><br><span class="line">  if (language &amp;&amp; languageMap &amp;&amp; languageMap[language]) &#123;</span><br><span class="line">    languageMap[language][content] &amp;&amp;</span><br><span class="line">      (content = languageMap[language][content]);</span><br><span class="line">  &#125;</span><br><span class="line">  // afterRender middleware</span><br><span class="line">  if (middleware.afterRender) content = middleware.afterRender(content);</span><br><span class="line">  return content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-再创建-translateClass"><a href="#4-3-再创建-translateClass" class="headerlink" title="4.3 再创建 translateClass"></a>4.3 再创建 translateClass</h3><p>为了使用Context API，我们需要一个辅助类来接受<code>&lt;Provider/&gt;</code>传过来的 languageMap 和 language 等字段</p><p>先创建一个./core/context.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const &#123; Provider, Consumer &#125; = React.createContext();</span><br></pre></td></tr></table></figure></p><p>在创建一个./core/translateClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/translateClass.jsx</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; translate &#125; from &quot;./translate&quot;;</span><br><span class="line">import &#123; Consumer &#125; from &quot;./context&quot;;</span><br><span class="line"></span><br><span class="line">class Translate extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const noTranslate = this.props[&quot;no-translate&quot;];</span><br><span class="line">    return (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;context =&gt;</span><br><span class="line">          noTranslate</span><br><span class="line">            ? this.props.children</span><br><span class="line">            : translate(</span><br><span class="line">                this.props.children,</span><br><span class="line">                context.languageMap,</span><br><span class="line">                context.language</span><br><span class="line">              )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Translate;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-改写-createElement"><a href="#4-4-改写-createElement" class="headerlink" title="4.4 改写 createElement"></a>4.4 改写 createElement</h3><p>有了之前的铺垫，可以很快的实现我们自己的<code>createElement</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/translateTag.jsx</span><br><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import Translate from &quot;./translateClass&quot;;</span><br><span class="line"></span><br><span class="line">const createElement = React.createElement;</span><br><span class="line"></span><br><span class="line">React.createElement = (...args) =&gt; &#123;</span><br><span class="line">  let children = args.slice(2);</span><br><span class="line"></span><br><span class="line">  // ① console.log(args)</span><br><span class="line">  children = children.map(child =&gt; &#123;</span><br><span class="line">    if (typeof args[0] === &quot;string&quot; &amp;&amp; typeof child === &quot;string&quot;) &#123;</span><br><span class="line">      if (args[1] &amp;&amp; args[1][&quot;no-translate&quot;]) &#123;</span><br><span class="line">        return &lt;Translate no-translate&gt;&#123;child&#125;&lt;/Translate&gt;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &lt;Translate&gt;&#123;child&#125;&lt;/Translate&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return createElement(args[0], args[1], ...children);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在标志①处打印 args 可以看到 ReactDom 的结构，它包含了$$typeof,props,ref,children等属性， $$typeof 代表组件类型， props 是属性， children 是子节点的若干元素，将其 children 获取到，进行如下判断：</p><ol><li>如果类型是 Object 就不做任何操作</li><li>如果 child 类型是字符串就进行翻译</li><li>如带有 no-translate 属性将不对其进行翻译</li></ol><p>通过改变<code>&lt;Provider/&gt;</code>的位置，可以设置不同区块的 context ，这样可以改变不同区块的翻译表和语言类型</p><p>到这里， translate 工具类基本完成</p><h2 id="五、进行测试"><a href="#五、进行测试" class="headerlink" title="五、进行测试"></a>五、进行测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import ReactDom from &quot;react-dom&quot;;</span><br><span class="line">import languageMap from &quot;./core/languageMap&quot;;</span><br><span class="line">import &#123; translate, middleware &#125; from &quot;./core/translate&quot;;</span><br><span class="line">import &#123; Provider &#125; from &quot;./core/context&quot;;</span><br><span class="line">// 全局更新createElement</span><br><span class="line">import &quot;./core/translateTag.jsx&quot;;</span><br><span class="line"></span><br><span class="line">const styles = &#123;</span><br><span class="line">  fontFamily: &quot;sans-serif&quot;,</span><br><span class="line">  textAlign: &quot;center&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    this.fetchTranslateList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchTranslateList() &#123;</span><br><span class="line">    languageMap[&quot;en&quot;] = &#123;</span><br><span class="line">      你好: &quot;Hello&quot;,</span><br><span class="line">      国际化: &quot;intl&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    languageMap[&quot;france&quot;] = &#123;</span><br><span class="line">      你好: &quot;Bonjour&quot;,</span><br><span class="line">      国际化: &quot;intl&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const enConfig = &#123; language: &quot;en&quot;, languageMap &#125;;</span><br><span class="line">    const franceConfig = &#123; language: &quot;france&quot;, languageMap &#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123;styles&#125;&gt;</span><br><span class="line">        &lt;Provider value=&#123;enConfig&#125;&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;你好&lt;/h1&gt;</span><br><span class="line">            &lt;span&gt;</span><br><span class="line">              你好</span><br><span class="line">              &lt;Provider value=&#123;franceConfig&#125;&gt;</span><br><span class="line">                &lt;h1 no-translate&gt;</span><br><span class="line">                  你好</span><br><span class="line">                  &lt;div&gt;国际化&lt;/div&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">                &lt;span&gt;国际化&lt;/span&gt;</span><br><span class="line">              &lt;/Provider&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.body.appendChild(document.createElement(&quot;div&quot;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以上代码，我们创建了一个入口文件，分别将中文翻译成了英文和法文，最终运行正常！</p><h2 id="六、兼容性"><a href="#六、兼容性" class="headerlink" title="六、兼容性"></a>六、兼容性</h2><p>写这个工具的初衷当然是无缝兼容各种 react 项目，但事实上并不简单<br>举例来说，目前出现的很多的前端组件库与这个工具有很多兼容性冲突，这些库主要有：</p><ol><li>ant-design/ant-mobile（蚂蚁金服团队的前端UI组件库，链接：<a href="https://ant.design/index-cn）" target="_blank" rel="noopener">https://ant.design/index-cn）</a></li><li>element-react（饿了么团队的前端UI组件库react版本，链接：<a href="https://eleme.github.io/element-react/）" target="_blank" rel="noopener">https://eleme.github.io/element-react/）</a></li></ol><p>实际操作中发现了不兼容的问题很多，想必要做到开箱即用是不可能了~~~<br>寄希望于无缝兼容，不如提供中间件接口来让使用者自行配置 o(╥﹏╥)o</p><h3 id="6-1-ant-design"><a href="#6-1-ant-design" class="headerlink" title="6.1 ant-design"></a>6.1 ant-design</h3><p>例如，在 ant-design 组件库中，<code>&lt;input/&gt;</code>的 placeholder 属性，如不进行检测，将不会被翻译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123;filter&#125; from &apos;./core/translate.js&apos;;</span><br><span class="line"></span><br><span class="line">filter.forAntDesign = (props,language) =&gt; &#123;</span><br><span class="line">    let props = Object.assign(&#123;&#125;, props);</span><br><span class="line">            if (language &amp;&amp; props.placeholder) &#123;</span><br><span class="line">                if (languageMap[language]) &#123;</span><br><span class="line">                    if (/[^\u4e00-\u9fa5]/g.test(props.placeholder)) &#123;</span><br><span class="line">                        props.placeholder = props.placeholder.replace(/([\u4e00-\u9fa5]+)/g, (match) =&gt; &#123;</span><br><span class="line">                            return languageMap[language][match] ? languageMap[language][match] : match</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        languageMap[language][props.placeholder] &amp;&amp; (props.placeholder = languageMap[language][props.placeholder]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;input</span><br><span class="line">                &#123;...props&#125;</span><br><span class="line">                ref=&quot;input&quot;</span><br><span class="line">                onInput=&#123;e =&gt; &#123;this.value = e.target.value; this.props.onInput &amp;&amp; this.props.onInput(e);&#125;&#125;&gt;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/input&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上对 placeholder 的过滤操作，可以实现 ant-design 输入框的多语言翻译。<br>再如，<code>&lt;Select/&gt;</code>组件，它约定元素 option 的属性 value 强等于内容 children 时才认为当前选项是被选中，解决办法这里不再赘述，它们都可以通过增加中间件，修改<code>props.children</code>的过滤机制进而解决！</p><h3 id="6-2-其他react组件库"><a href="#6-2-其他react组件库" class="headerlink" title="6.2 其他react组件库"></a>6.2 其他react组件库</h3><p>也有一些框架或者自行编写的组件，如 element-react ，一些 dom 文字并不会放在 text 中，更确切地说其组件内部进行了重构，并不会将文字简单的向外展示，这就需要额外的编写特殊的 filter 了</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>到这里，我们的 React 国际化工具已经实现了，这里是一个简单的在线 demo</p><iframe src="https://codesandbox.io/embed/64zx97v9qr" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><ul><li>完整代码参考 github: <a href="https://github.com/ranrantu/react-i18" target="_blank" rel="noopener">https://github.com/ranrantu/react-i18</a></li></ul><p>总之，这可以说是 React 动态翻译的一种思路，这种实现至今还是有不足的地方，还请各位拍砖指正，感谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; React 最早由 Facebook 的软件工程师 Jordan Walke 创建，它在 2011 年首次部署在 Facebook 的新闻源中，由于其性能优势明显，很快获得了广泛关注和大规模的使用，如今发展已经非常成熟。&lt;br&gt;基于 React 的渲染原理可以实现很多有意思的功能，例如实现一个 React 的国际化工具。(React v16.3)&lt;/p&gt;
    
    </summary>
    
      <category term="jiangxiang" scheme="http://xgfe.github.io/categories/jiangxiang/"/>
    
    
      <category term="React" scheme="http://xgfe.github.io/tags/React/"/>
    
      <category term="国际化" scheme="http://xgfe.github.io/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>web前端性能优化</title>
    <link href="http://xgfe.github.io/2018/04/15/zhangjianfeng/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://xgfe.github.io/2018/04/15/zhangjianfeng/web前端性能优化/</id>
    <published>2018-04-15T07:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.264Z</updated>
    
    <content type="html"><![CDATA[<p>在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。本文主要围绕以下几点讲解：</p><ol><li>客户端请求</li><li>客户端渲染</li><li>服务端响应</li><li>网络<a id="more"></a></li></ol><h2 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h2><p>每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象。</p><h3 id="资源压缩与合并"><a href="#资源压缩与合并" class="headerlink" title="资源压缩与合并"></a>资源压缩与合并</h3><p>压缩可以减少资源的体积，从而增加加载速度。将资源文件合并，减少资源的请求数。但并不意味着，一个资源越大越好，资源太大，会影响资源加载速度。针对这一问题，利用webpack模块化打包工具分块打包、按需加载以及提取公共部分代码，利用缓存可以得到解决。具体可参考<a href="http://mp.weixin.qq.com/s/BVYgLeOEIJp5xY55Rcrszg" target="_blank" rel="noopener">webpack的使用</a>。</p><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><p>从用户输入一个网址到网页最终展现到用户面前，中间的大致发生以下几个流程：</p><ol><li>发送到DNS（域名服务器）获得域名对应的WEB服务器的IP地址。</li><li>客户端浏览器与WEB服务器建立TCP（传输控制协议）连接。</li><li>客户端浏览器向对应IP地址的WEB服务器发送相应的HTTP或HTTPS请求。</li><li>WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。</li><li>客户端浏览器下载数据，解析HTML源文件，解析的过程中实现对页面的排版，解析完成后，在浏览器中显示基础的页面。</li><li>分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。<br>DNS解析时间可能导致大量用户感知延迟，DNS解析所需的时间差异非常大，延迟范围可以从1ms（本地缓存结果）到普遍的几秒钟时间。所以利用DNS预解析是有意义的。<br>具体实现方式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"hostname"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源。页面提供给浏览器需要预加载的集合。浏览器载入当前页面完成后，将会在后台下载需要预加载的页面并添加到缓存中。当用户访问某个预加载的链接时，如果从缓存命中，页面就得以快速呈现。 实现方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面，可以使用绝对或者相对路径</span></span><br><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"page2.html"</span> /&gt; </span><br><span class="line"><span class="comment">// 图片，也可以是其他类型的文件</span></span><br><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"sprite.png"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>从上面的HTML代码可以看出，预加载使用 <link> 标签，并指定 rel=”prefetch” 属性，而href属性就是需要预加载的文件路径。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>一个页面有很多图片，而首屏出现的图片大概就一两张，如果一次性把所有图片都加载出来，不仅影响页面渲染速度，还浪费带宽。这也就是们通常所说的首屏加载，其中要用的技术就是图片懒加载–到可视区域再加载。简单实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有要进行懒加载的图片</span></span><br><span class="line">    <span class="keyword">var</span> eles = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img[data-original][lazyload]'</span>);</span><br><span class="line">    <span class="keyword">var</span> viewHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    eles.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rect;</span><br><span class="line">        <span class="keyword">if</span> (item.dataset.original === <span class="string">''</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rect = item.getBoundingClientRect();</span><br><span class="line">        <span class="comment">// 图片一进入可视区，动态加载</span></span><br><span class="line">        <span class="keyword">if</span> (rect.bottom &gt;= <span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><br><span class="line">            item.src = item.dataset.original;</span><br><span class="line">            item.removeAttribute(<span class="string">'data-original'</span>);</span><br><span class="line">            item.removeAttribute(<span class="string">'lazyload'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>合并 CSS图片，也就是通过将多个图片或者icon放在一张图片中，利用css的background-position属性控制每个图片或icon的位置。</p><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><p>客户端优化 dom、css 和 js 的代码和加载顺序</p><h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h3><blockquote><p>Document Object Model 文档对象模型</p></blockquote><p>DOM是Model，是Object Model，对象模型，是为HTML（and XML）提供的API。HTML（Hyper Text Markup Language）是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器端，我们可以用脚本语言（JavaScript）通过DOM去操作HTML内容。</p><h3 id="为什么DOM很慢"><a href="#为什么DOM很慢" class="headerlink" title="为什么DOM很慢"></a>为什么DOM很慢</h3><p>首先，我们来了解一下网页的生成过程。浏览器在收到 HTML 文档之后会对文档进行解析开始构建 DOM （Document Object Model） 树，进而在文档中发现样式表，开始解析 CSS 来构建 CSSOM（CSS Object Model）树，这两者都构建完成后，开始构建渲染树。大致可分为以下几个过程：</p><ol><li>构建DOM树</li><li>构建CSSOM树</li><li>生成render树</li><li>Layout 布局</li><li>Paint 绘制</li></ol><p>在每次修改了 DOM 或者其样式之后都要进行 DOM树的构建，CSSOM 的重新计算，进而得到新的渲染树。浏览器会利用新的渲染树对页面进行重排和重绘，以及图层的合并。通常浏览器会批量进行重排和重绘，以提高性能。但当我们试图通过 JavaScript 获取某个节点的尺寸信息的时候，为了获得当前真实的信息，浏览器会立刻进行一次重排。</p><p>通过js操作DOM，影响页面性能的主要原因有如下几点：</p><ul><li>访问和修改DOM元素</li><li>修改DOM元素的样式，导致重绘和重排</li><li>通过对DOM元素的事件处理，完成与用户的交互功能</li></ul><h3 id="重绘（也称为回流reflow）和重排"><a href="#重绘（也称为回流reflow）和重排" class="headerlink" title="重绘（也称为回流reflow）和重排"></a>重绘（也称为回流reflow）和重排</h3><p>重排和重绘是DOM编程中耗能的主要原因之一。</p><blockquote><p>重绘</p></blockquote><p>重绘意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了。</p><blockquote><p>引起重绘的操作</p></blockquote><ul><li>重排必定引起repaint重绘，重绘可以单独触发</li><li>背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</li></ul><blockquote><p>重排</p></blockquote><p>根据Render Tree布局（几何属性），意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。</p><blockquote><p>引起重排的操作</p></blockquote><ul><li>内容改变<br>  文本改变或图片尺寸改变</li><li>DOM元素的几何属性的变化<br>  例如改变DOM元素的宽高值时，原渲染树中的相关节点会失效，浏览器会根据变化后的DOM重新排建渲染树中的相关节点。如果父节点的几何属性变化时，还会使其子节点及后续兄弟节点重新计算位置等，造成一系列的重排。</li><li>DOM树的结构变化<br>  添加DOM节点、修改DOM节点位置及删除某个节点都是对DOM树的更改，会造成页面的重排。浏览器布局是从上到下的过程，修改当前元素不会对其前边已经遍历过的元素造成影响，但是如果在所有的节点前添加一个新的元素，则后续的所有元素都要进行重排。</li><li>浏览器窗口尺寸改变<br>  窗口尺寸的改变会影响整个网页内元素的尺寸的改变，即DOM元素的集合属性变化，因此会造成重排。</li><li>获取某些属性<br>  除了渲染树的直接变化，当获取一些属性值时，浏览器为取得正确的值也会发生重排，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()。</li></ul><h3 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h3><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。<br>提高网页性能，就是要降低“重排”和“重绘”的频率和成本，尽量少触发重新渲染。<br>前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = <span class="string">'blue'</span>;</span><br><span class="line">div.style.marginTop = <span class="string">'30px'</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。</p><p>如果写得不好，就会触发两次重排和重绘。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="keyword">var</span> margin = <span class="built_in">parseInt</span>(div.style.marginTop);</span><br><span class="line">div.style.marginTop = (margin + <span class="number">10</span>) + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码对div元素设置颜色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。</p><p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p><pre><code>* offsetTop/offsetLeft/offsetWidth/offsetHeight* scrollTop/scrollLeft/scrollWidth/scrollHeight* clientTop/clientLeft/clientWidth/clientHeight* getComputedStyle()</code></pre><p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="keyword">var</span> left = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> top  = div.offsetTop;</span><br><span class="line">div.style.left = left + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">div.style.top = top + <span class="number">10</span> + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="关于DOM操作的几个技巧"><a href="#关于DOM操作的几个技巧" class="headerlink" title="关于DOM操作的几个技巧"></a>关于DOM操作的几个技巧</h3><ul><li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li><li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li><li><p>不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure></li><li><p>先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</p></li><li>position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li><li>只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。</li><li><p>在涉及到吸顶相关及scroll滚动优化</p><ol><li>尽量控制DOM的显示或隐藏，而不是删除或添加</li><li>一次性操作DOM</li><li>多做缓存</li><li><p>注意节流，避免频繁触发滚动事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">fn, threshhold = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> last;</span><br><span class="line">    <span class="keyword">var</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                last = now;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;, threshhold);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = now;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="代码优化和加载顺序"><a href="#代码优化和加载顺序" class="headerlink" title="代码优化和加载顺序"></a>代码优化和加载顺序</h3><p>尽量较少不必要的代码，比如html和css的多层嵌套，代码结构尽量精简。了解js内存泄漏，避免导致内存泄漏的写法。HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。js脚本会阻塞浏览器解析，将脚本放在页面底部加载。</p><h2 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h2><p>尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，加快文件读取速度，优化服务端的缓存策略。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。</p><h3 id="浏览器并发请求限制"><a href="#浏览器并发请求限制" class="headerlink" title="浏览器并发请求限制"></a>浏览器并发请求限制</h3><p>基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制。浏览器的并发请求数目限制是针对同一域名的。因此静态资源可以引用不同域名下的资源文件，间接增加浏览器请求资源的并发数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上介绍了性能优化的几个方面，因个人能力有限，有总结不到或者错误的地方，还请各位大神不吝指教。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。本文主要围绕以下几点讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端请求&lt;/li&gt;
&lt;li&gt;客户端渲染&lt;/li&gt;
&lt;li&gt;服务端响应&lt;/li&gt;
&lt;li&gt;网络
    
    </summary>
    
      <category term="zhangjianfeng" scheme="http://xgfe.github.io/categories/zhangjianfeng/"/>
    
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="web性能" scheme="http://xgfe.github.io/tags/web%E6%80%A7%E8%83%BD/"/>
    
      <category term="前端优化实践" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>routable-ios 源码解析</title>
    <link href="http://xgfe.github.io/2018/04/07/chenyu/routable-ios_sourceAnalysis/"/>
    <id>http://xgfe.github.io/2018/04/07/chenyu/routable-ios_sourceAnalysis/</id>
    <published>2018-04-07T05:12:00.000Z</published>
    <updated>2018-08-24T03:48:57.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析 <a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="noopener">routable-ios</a> 源码，通过本文可以了解路由的原理及使用。本文分为六个部分，从代码结构到具体的类依次介绍，文章最后会给出在项目中注册路由常用的方式。</p><a id="more"></a><h2 id="一、routable-ios-是什么？可以用来做什么？与之类似的框架还有哪些？"><a href="#一、routable-ios-是什么？可以用来做什么？与之类似的框架还有哪些？" class="headerlink" title="一、routable-ios 是什么？可以用来做什么？与之类似的框架还有哪些？"></a>一、routable-ios 是什么？可以用来做什么？与之类似的框架还有哪些？</h2><ul><li>routable-ios 是一个路由框架，由两个文件四个类组成，其中核心的类就一个。</li><li>可以很方便的实现 iOS 中<code>UIViewController</code>之间的跳转。跳转方式也可以灵活的设置，后面具体会讲到。</li><li>类似的框架还有 <a href="https://github.com/aaronbrethorst/ABRouter" target="_blank" rel="noopener">ABRouter</a> &amp; <a href="https://github.com/lightory/HHRouter" target="_blank" rel="noopener">HHRouter</a>。后期的文章也会对 HHRouter 做介绍。</li></ul><h2 id="二、routable-ios-中类的关系"><a href="#二、routable-ios-中类的关系" class="headerlink" title="二、routable-ios 中类的关系"></a>二、routable-ios 中类的关系</h2><p>&nbsp;&nbsp;了解类与类之间的关系，有助于理解整个框架。<code>Routable</code>继承自<code>UPRouter</code>，主要的功能都在<code>UPRouter</code>类中，路由主要的功能其实就两个：</p><ul><li>注册希望路由跳转的类及<code>URL</code></li><li>进行跳转</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/142772-7f18a54a0a327233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="routable-ios 类组织结构.png"></p><h2 id="三、routable-ios-如何使用"><a href="#三、routable-ios-如何使用" class="headerlink" title="三、routable-ios 如何使用"></a>三、routable-ios 如何使用</h2><ul><li>将<code>routable-ios</code>导入项目</li><li><p>注册路由：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[Routable sharedRouter] map:@&quot;user/:name/:age&quot; toController:[UserController class]];</span><br></pre></td></tr></table></figure></li><li><p>调用路由进行跳转：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[Routable sharedRouter] open:@&quot;user/chenyu/28&quot;];</span><br></pre></td></tr></table></figure></li><li><p>在 VC 中获取传递的参数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation UserController</span><br><span class="line"></span><br><span class="line">- (id)initWithRouterParams:(NSDictionary *)params &#123;</span><br><span class="line">  if ((self = [self initWithNibName:nil bundle:nil])) &#123;</span><br><span class="line">    self.title = @&quot;User&quot;;</span><br><span class="line">      NSLog(@&quot;name: %@&quot;,[params objectForKey:@&quot;name&quot;]); //chenyu</span><br><span class="line">      NSLog(@&quot;age: %@&quot;,[params objectForKey:@&quot;age&quot;]);   //28</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、routable-ios-中的核心类"><a href="#四、routable-ios-中的核心类" class="headerlink" title="四、routable-ios 中的核心类"></a>四、routable-ios 中的核心类</h2><p>&nbsp;&nbsp;核心类分别有：<code>Routable</code>，<code>UPRouterOptions</code>，<code>RouterParams</code>，<code>UPRouter</code></p><h3 id="1-Routable"><a href="#1-Routable" class="headerlink" title="1.Routable"></a>1.<code>Routable</code></h3><p>&nbsp;&nbsp;<code>Routable</code>继承自<code>UPRouter</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedRouter; //提供单例方法，用来创建路由类</span><br><span class="line">+ (instancetype)newRouter;     //另一种创建路由的方式，一般不推荐，不是单例。</span><br></pre></td></tr></table></figure><h3 id="2-UPRouterOptions"><a href="#2-UPRouterOptions" class="headerlink" title="2.UPRouterOptions"></a>2.<code>UPRouterOptions</code></h3><p>&nbsp;&nbsp;<code>UPRouterOptions</code>继承自<code>NSObject</code>。首先看一下这个类提供的一些属性，我们就知道这个类是做什么的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, getter=isModal) BOOL modal;  //是否是模态视图</span><br><span class="line">@property (readwrite, nonatomic) UIModalPresentationStyle presentationStyle;  //VC 显示的样式</span><br><span class="line">@property (readwrite, nonatomic) UIModalTransitionStyle transitionStyle;  //VC 出现时的动画</span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *defaultParams;  //默认的数据</span><br><span class="line">@property (readwrite, nonatomic, assign) BOOL shouldOpenAsRootViewController; //是否是根视图</span><br><span class="line"></span><br><span class="line">//.m 文件中的两个属性</span><br><span class="line">@property (readwrite, nonatomic, strong) Class openClass;  //注册的类</span><br><span class="line">@property (readwrite, nonatomic, copy) RouterOpenCallback callback;  //block 回调</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;通过以上内容，可以看到<code>UPRouterOptions</code>其实就是一个配置类，里面存储路由跳转时需要的一些数据，可以理解成一个辅助的类。这个类中提供了一系列的工厂方法，用来创建不同类型的对象，比如（只列举部分函数，其他同类型的函数还有很多，功能大体一致，只是某个配置项不同而已。）：</p><ul><li><p>全部使用默认配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Default construction; like [NSArray array]</span><br><span class="line">+ (instancetype)routerOptions &#123;</span><br><span class="line">  return [self routerOptionsWithPresentationStyle:UIModalPresentationNone</span><br><span class="line">                                  transitionStyle:UIModalTransitionStyleCoverVertical</span><br><span class="line">                                    defaultParams:nil</span><br><span class="line">                                           isRoot:NO</span><br><span class="line">                                          isModal:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传入所有参数创建对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Explicit construction</span><br><span class="line">+ (instancetype)routerOptionsWithPresentationStyle: (UIModalPresentationStyle)presentationStyle</span><br><span class="line">                                   transitionStyle: (UIModalTransitionStyle)transitionStyle</span><br><span class="line">                                     defaultParams: (NSDictionary *)defaultParams</span><br><span class="line">                                            isRoot: (BOOL)isRoot</span><br><span class="line">                                           isModal: (BOOL)isModal &#123;</span><br><span class="line">  UPRouterOptions *options = [[UPRouterOptions alloc] init];</span><br><span class="line">  options.presentationStyle = presentationStyle;</span><br><span class="line">  options.transitionStyle = transitionStyle;</span><br><span class="line">  options.defaultParams = defaultParams;</span><br><span class="line">  options.shouldOpenAsRootViewController = isRoot;</span><br><span class="line">  options.modal = isModal;</span><br><span class="line">  return options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义部分参数创建对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Custom class constructors, with heavier Objective-C accent</span><br><span class="line">+ (instancetype)routerOptionsAsModal &#123;</span><br><span class="line">  return [self routerOptionsWithPresentationStyle:UIModalPresentationNone</span><br><span class="line">                                  transitionStyle:UIModalTransitionStyleCoverVertical</span><br><span class="line">                                    defaultParams:nil</span><br><span class="line">                                           isRoot:NO</span><br><span class="line">                                          isModal:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩余的基本就是一些快捷的方法及一些<code>setters</code>方法，可以查看源码。</p></li></ul><h3 id="3-RouterParams"><a href="#3-RouterParams" class="headerlink" title="3.RouterParams"></a>3.<code>RouterParams</code></h3><p>&nbsp;&nbsp;<code>RouterParams</code>继承自<code>NSObject</code>。<code>RouterParams</code>并没有在.h 文件中做声明，这个类只在<code>Routable</code>和<code>UPRouter</code>中的实现中才用到，而这三个类都在一个文件中，所以也没有必要出现在 .h 文件中。<br>首先看一下<code>RouterParams</code>的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface RouterParams : NSObject</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, strong) UPRouterOptions *routerOptions;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *openParams; </span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *extraParams;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *controllerParams;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这个类的出现，主要作用是将跳转时匹配好的所有内容存起来，缓存到另一个字典中，未来再次跳转的时候，直接可以拿出来用，你也许会问，我们的路由不是在一个字典里吗，也可以直接拿出来用，为什么还要缓存，后续到源代码的地方会细说，为什么要缓存，为什么跳转的时候不是直接去 map 中寻找。</p><h3 id="4-UPRouter"><a href="#4-UPRouter" class="headerlink" title="4.UPRouter"></a>4.<code>UPRouter</code></h3><p>&nbsp;&nbsp;<code>UPRouter</code>继承自<code>NSObject</code>，首先看一下类的声明，删除了很多注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface UPRouter : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The UINavigationController instance which mapped UIViewControllers will be pushed onto.</span><br><span class="line"> */</span><br><span class="line">@property (readwrite, nonatomic, strong) UINavigationController *navigationController;</span><br><span class="line"></span><br><span class="line">- (void)pop;</span><br><span class="line">- (void)popViewControllerFromRouterAnimated:(BOOL)animated;</span><br><span class="line">- (void)pop:(BOOL)animated;</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, assign) BOOL ignoresExceptions;</span><br><span class="line"></span><br><span class="line">- (void)map:(NSString *)format toCallback:(RouterOpenCallback)callback;</span><br><span class="line">- (void)map:(NSString *)format toCallback:(RouterOpenCallback)callback withOptions:(UPRouterOptions *)options;</span><br><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass;</span><br><span class="line">//注册路由，本篇主要分析的方法。上面的方法最终会调用这个方法，options 传入的是 nil</span><br><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)openExternal:(NSString *)url;</span><br><span class="line">- (void)open:(NSString *)url;</span><br><span class="line">- (void)open:(NSString *)url animated:(BOOL)animated;</span><br><span class="line">//路由跳转，本篇主要分析的方法。上面两个方法最终都会调用这个方法。</span><br><span class="line">- (void)open:(NSString *)url animated:(BOOL)animated extraParams:(NSDictionary *)extraParams;</span><br><span class="line"></span><br><span class="line">- (NSDictionary*)paramsOfUrl:(NSString*)url;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface UPRouter ()</span><br><span class="line"></span><br><span class="line">// 存储注册的路由</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *routes;</span><br><span class="line">// 缓存已跳转过的路由</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *cachedRoutes;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;注册路由比较简单，就是将传入的<code>URL</code>作为 key，将<code>Class</code>作为值存入已初始化的<code>routes</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass &#123;</span><br><span class="line">  [self map:format toController:controllerClass withOptions:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options &#123;</span><br><span class="line">  if (!format) &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;RouteNotProvided&quot;</span><br><span class="line">                                   reason:@&quot;Route #format is not initialized&quot;</span><br><span class="line">                                 userInfo:nil];</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //如果没有传入 options，则会创建一个默认的配置对象</span><br><span class="line">  if (!options) &#123;</span><br><span class="line">    options = [UPRouterOptions routerOptions];</span><br><span class="line">  &#125;</span><br><span class="line">  options.openClass = controllerClass;</span><br><span class="line">  [self.routes setObject:options forKey:format];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;路由跳转一共有三个比较重要的方法，首先看<code>open:animated:extraParams:</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (void)open:(NSString *)url</span><br><span class="line">    animated:(BOOL)animated</span><br><span class="line"> extraParams:(NSDictionary *)extraParams</span><br><span class="line">&#123;</span><br><span class="line">  //获取路由跳转相关的参数，往下滑动，先看怎么获取的数据，看完下面的方法再回来看这个方法</span><br><span class="line">  RouterParams *params = [self routerParamsForUrl:url extraParams: extraParams];</span><br><span class="line">  UPRouterOptions *options = params.routerOptions;</span><br><span class="line">  </span><br><span class="line">  //好了，拿到数据了，开始跳转。先判断是否有回调，如果有的话，则去执行 block</span><br><span class="line">  if (options.callback) &#123;</span><br><span class="line">    RouterOpenCallback callback = options.callback;</span><br><span class="line">    callback([params controllerParams]);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //此处删除了判断 self.navigationController 是否存在的容错代码，无关紧要。</span><br><span class="line">  </span><br><span class="line">  //获取将要跳转的 VC，并且将我们传递的数据以字典的形式，传递给这个 VC</span><br><span class="line">  //controllerForRouterParams 这个方法比较简单，打断点进去看看就 OK 了。</span><br><span class="line">  UIViewController *controller = [self controllerForRouterParams:params];</span><br><span class="line">  </span><br><span class="line">  //判断当前是否有 presented 的 UIViewController，有的话要 dismiss，因为接下来要跳转或者 presentViewController</span><br><span class="line">  if (self.navigationController.presentedViewController) &#123;</span><br><span class="line">    [self.navigationController dismissViewControllerAnimated:animated completion:nil];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //是否是以模态的方式弹出 UIViewController</span><br><span class="line">  if ([options isModal]) &#123;</span><br><span class="line">    if ([controller.class isSubclassOfClass:UINavigationController.class]) &#123;</span><br><span class="line">      [self.navigationController presentViewController:controller</span><br><span class="line">                                              animated:animated</span><br><span class="line">                                            completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:controller];</span><br><span class="line">      navigationController.modalPresentationStyle = controller.modalPresentationStyle;</span><br><span class="line">      navigationController.modalTransitionStyle = controller.modalTransitionStyle;</span><br><span class="line">      [self.navigationController presentViewController:navigationController</span><br><span class="line">                                              animated:animated</span><br><span class="line">                                            completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (options.shouldOpenAsRootViewController) &#123;</span><br><span class="line">    //设置根视图</span><br><span class="line">    [self.navigationController setViewControllers:@[controller] animated:animated];</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //直接 push 一个 UIViewController</span><br><span class="line">    [self.navigationController pushViewController:controller animated:animated];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;获取路由跳转相关的参数方法（删除了一些容错处理的代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams &#123;</span><br><span class="line">  //如果缓存中已经有了（证明之前已经跳转过这个 VC），并且传递的参数没有变化。</span><br><span class="line">  //这里需要注意了，如果传递的参数你也不确定是不是没变化，最好给 extraParams 给个值，这样就不会走缓存了</span><br><span class="line">  //否则可能传递的数据变了，但是走的还是之前的缓存。</span><br><span class="line">  //如果 VC 之间不要传递数据，不用考虑这个问题</span><br><span class="line">  if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) &#123;</span><br><span class="line">    return [self.cachedRoutes objectForKey:url];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  NSArray *givenParts = url.pathComponents;</span><br><span class="line">  NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;];</span><br><span class="line">  //这里判断传入的路由路径是否正确，如果传入这样的 &quot;iOS/app//first&quot; 路径，则会警告。</span><br><span class="line">  //也许你的路由路径是&quot;iOS/app&quot;，这样写你就少传了一个实参</span><br><span class="line">  if ([legacyParts count] != [givenParts count]) &#123;</span><br><span class="line">    NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url);</span><br><span class="line">    givenParts = legacyParts;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //使用枚举的方式去匹配，这里不能从 self.routes 中通过 [self.routes objectForKey:@&quot;key&quot;] 的方式获取，</span><br><span class="line">  //因为注册的时候，你后面添加的是参数（形参），在跳转的时候传递的是数据（实参）。</span><br><span class="line">  //这里也就是为什么需要缓存的原因了，每次跳转都要枚举这个字典，缓存了以后时间复杂度直接降到了 O(1)。</span><br><span class="line">  __block RouterParams *openParams = nil;</span><br><span class="line">  [self.routes enumerateKeysAndObjectsUsingBlock:</span><br><span class="line">   ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) &#123;</span><br><span class="line">     //routerUrl 是枚举到的 key，也是当时注册路由时添加进去的 url，routerOptions 是枚举到的 value</span><br><span class="line"></span><br><span class="line">     NSArray *routerParts = [routerUrl pathComponents];</span><br><span class="line">     //判断注册的路由地址和跳转的带参数的地址是否一致，最简单的办法就是判断他们包含的元素个数是否一致，如果一致，再做更详细的判断</span><br><span class="line">     if ([routerParts count] == [givenParts count]) &#123;</span><br><span class="line">       //如果个数一致，再判断是否匹配</span><br><span class="line">       NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</span><br><span class="line">       if (givenParams) &#123;</span><br><span class="line">         //givenParams 存储的是路由地址中给的数据，再将 extraParams 一起传入 RouterParams，创建 RouterParams 的对象。</span><br><span class="line">         openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</span><br><span class="line">         *stop = YES;//结束遍历</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br><span class="line">  </span><br><span class="line">  //如果没有匹配到路由</span><br><span class="line">  if (!openParams) &#123;</span><br><span class="line">    //用户设置了忽略异常，直接返回 nil，否则会走 @throw</span><br><span class="line">    if (_ignoresExceptions) &#123;</span><br><span class="line">      return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot;</span><br><span class="line">                                   reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]</span><br><span class="line">                                 userInfo:nil];</span><br><span class="line">  &#125;</span><br><span class="line">  //将我们辛辛苦苦封装好的路由相关的所有数据缓存起来，下次在走这个 url 的时候，直接取缓存中的数据，这就是为什么要缓存了。</span><br><span class="line">  //除非你传递的参数变了，那么一定传给 extraParams，相关方法检测到 extraParams 不为空，会重新组装数据。</span><br><span class="line">  [self.cachedRoutes setObject:openParams forKey:url];</span><br><span class="line">  return openParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//判断注册的路由和跳转的路由是否一致</span><br><span class="line">- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents</span><br><span class="line">                     routerUrlComponents:(NSArray *)routerUrlComponents &#123;</span><br><span class="line">  </span><br><span class="line">  __block NSMutableDictionary *params = [NSMutableDictionary dictionary];</span><br><span class="line">  [routerUrlComponents enumerateObjectsUsingBlock:</span><br><span class="line">   ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">     </span><br><span class="line">     NSString *givenComponent = givenUrlComponents[idx];</span><br><span class="line">     //判断是否是形参，所以在注册路由时，一定要注意，参数以:开始，否则会当成路径字符串</span><br><span class="line">     if ([routerComponent hasPrefix:@&quot;:&quot;]) &#123;</span><br><span class="line">       //去除参数的:，然后将参数名作为 key，将对应的 givenComponent 作为值存入字典中，所以在调用路由的时候，传递参数（实参）顺序要一致，否则参数就错乱了</span><br><span class="line">       NSString *key = [routerComponent substringFromIndex:1];</span><br><span class="line">       [params setObject:givenComponent forKey:key];</span><br><span class="line">     &#125;</span><br><span class="line">     else if (![routerComponent isEqualToString:givenComponent]) &#123;</span><br><span class="line">       //在非传参数的情况下，如果路径不一致，则结束。结束后会去路由表中拿下一个路由来判断。</span><br><span class="line">       params = nil;</span><br><span class="line">       *stop = YES;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br><span class="line">  return params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;将路由跳转最重要的三个方法分析了一下，在重要的代码前都加上了注释。接下来总结一下整体的思路。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>&nbsp;&nbsp;注册的时候，比较简单，将我们的路径和 VC 传递进去，保存在字典中就可以了。跳转的时候，做的判断就比较多。首先判断缓存中是否有这个路径，如果有的话，直接跳转，在注释中也详细说明了为什么要缓存。如果没有的话，则去枚举这个路由字典，并组装数据，存入缓存中。</p><p>&nbsp;&nbsp;任何框架，都会有不完美的地方，没错，这里要说说了。如果需要给你跳转的 VC 传递数据，那么需要你的 VC 实现这个方法：<code>initWithRouterParams:params</code>，通过<code>params</code>去获取你的值。其实在这里也可以通过获取这个 VC 的所有属性，在创建这个 VC 的时候，通过 KVC 的方式把值赋给这个 VC 的属性。</p><p>&nbsp;&nbsp;另一种实现办法是扩展<code>UIViewController</code>，在这里可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Routable)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSDictionary *params;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController (Routable)</span><br><span class="line"></span><br><span class="line">static char kAssociatedParamsObjectKey;</span><br><span class="line"></span><br><span class="line">- (void)setParams:(NSDictionary *)params&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, params, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)params</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这样每个<code>UIViewController</code>中就不用实现固定的方法了，在使用的时候，直接调用<code>self.params</code>就可以拿到这个字典了。</p><h2 id="六、建议"><a href="#六、建议" class="headerlink" title="六、建议"></a>六、建议</h2><p>&nbsp;&nbsp;在<code>routable-ios</code>中给出的注册路由的方式是，一个 VC 一个 VC 的注册。可以将需要路由跳转的 VC 配置到 plist 文件中，写一个方法，读取 plist 文件，循环注册即可，在<code>application:didFinishLaunchingWithOptions:</code>方法中，调用注册路由的方法即可。</p><p>&nbsp;&nbsp;我 fork 了一份代码，并在里面添加了注释，想通过 Xcode 看的，可以下载下来看。 <a href="https://github.com/chenyu1520/routable-ios" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析 &lt;a href=&quot;https://github.com/clayallsopp/routable-ios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;routable-ios&lt;/a&gt; 源码，通过本文可以了解路由的原理及使用。本文分为六个部分，从代码结构到具体的类依次介绍，文章最后会给出在项目中注册路由常用的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="chenyu" scheme="http://xgfe.github.io/categories/chenyu/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="http://xgfe.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="路由" scheme="http://xgfe.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
</feed>
